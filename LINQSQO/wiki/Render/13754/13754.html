<div class="wikidoc"><div class="rss"><div class="accentbar"><span class="left">&nbsp;</span>B# .NET Blog News Feed<span class="right">&nbsp;</span></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2010/07/12/getting-started-with-active-directory-lightweight-directory-services.aspx">Getting Started with Active Directory Lightweight Directory Services</a></div><div class="moreinfo"><span class="date">Tuesday, July 13, 2010</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><h1>Introduction</h1>  <p>In preparation for some upcoming posts related to LINQ (what else?), Windows PowerShell and Rx, I had to set up a local LDAP-capable directory service. (Hint: It will pay off to read till the very end of the post if you’re wondering what I’m up to...) In this post I’ll walk the reader through the installation, configuration and use of <a href="http://www.microsoft.com/windowsserver2008/en/us/ad-lds.aspx">Active Directory Lightweight Directory Services (LDS)</a>, formerly known as Active Directory Application Mode (ADAM). Having used the technology several years ago, in relation to the <a href="http://linqtoad.codeplex.com/">LINQ to Active Directory</a> project (which as an extension to this blog series will receive an update), it was a warm and welcome reencounter.</p>  <p>&#160;</p>  <h1>What’s Lightweight Directory Services anyway?</h1>  <p>Use of hierarchical storage and auxiliary services provided by technologies like Active Directory often has advantages over alternative designs, e.g. using a relational database. For example, user accounts may be stored in a directory service for an application to make use of. While Active Directory seems the natural habitat to store (and replicate, secure, etc.) additional user information, IT admins will likely point you – the poor developer – at the door when asking to extend the schema. That’s one of the places where LDS comes in, offering the ability to take advantage of the programming model of directory services while keeping your hands off “the one and only AD schema”.</p>  <p>The <a href="http://www.microsoft.com/windowsserver2008/en/us/ad-lds.aspx#none">LDS website</a> quotes other use cases, which I’ll just copy here verbatim:</p>  <blockquote>   <p><em>Active Directory Lightweight Directory Service (AD LDS), formerly known as Active Directory Application Mode, can be used to provide directory services for directory-enabled applications. Instead of using your organization’s AD DS database to store the directory-enabled application data, AD LDS can be used to store the data. AD LDS can be used in conjunction with AD DS so that you can have a central location for security accounts (AD DS) and another location to support the application configuration and directory data (AD LDS). Using AD LDS, you can reduce the overhead associated with Active Directory replication, you do not have to extend the Active Directory schema to support the application, and you can partition the directory structure so that the AD LDS service is only deployed to the servers that need to support the directory-enabled application. </em></p>    <ul>     <li>       <p><em><b>Install from Media Generation.</b> The ability to create installation media for AD LDS by using Ntdsutil.exe or Dsdbutil.exe.</em></p>     </li>      <li>       <p><em><b>Auditing.</b> Auditing of changed values within the directory service.</em></p>     </li>      <li>       <p><em><b>Database Mounting Tool.</b> Gives you the ability to view data within snapshots of the database files.</em></p>     </li>      <li>       <p><em><b>Active Directory Sites and Services Support.</b> Gives you the ability to use Active Directory Sites and Services to manage the replication of the AD LDS data changes.</em></p>     </li>      <li>       <p><em><b>Dynamic List of LDIF files.</b> With this feature, you can associate custom LDIF files with the existing default LDIF files used for setup of AD LDS on a server.</em></p>     </li>      <li>       <p><em><b>Recursive Linked-Attribute Queries.</b> LDAP queries can follow nested attribute links to determine additional attribute properties, such as group memberships.</em></p>     </li>   </ul> </blockquote>  <p>Obviously that last bullet point grabs my attention through I will retain myself from digressing here.</p>  <p>&#160;</p>  <h1>Getting started</h1>  <p>If you’re running Windows 7, the following explanation is the right one for you. For older versions of the operating system, things are pretty similar though different downloads will have to be used. For Windows Server 2008, a server role exists for LDS. So, assuming you’re on Windows 7, start by <a href="http://www.microsoft.com/downloads/details.aspx?displaylang=en&amp;FamilyID=a45059af-47a8-4c96-afe3-93dab7b5b658">downloading the installation media over here</a>. After installing this, you should find an entry “Active Directory Lightweight Directory Services Setup Wizard” under the “Administrative Tools” section in “Control Panel”:</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb.png" width="587" height="330" /></a> </p>  <p>LDS allows you to install multiple instances of directory services on the same machine, just like SQL Server allows multiple server instances to co-exist. Each instance has a name and listens on certain ports using the LDP protocol. Starting this wizard – which lives under %SystemRoot%\ADAM\adaminstall.exe, revealing the former product name – brings us here:</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_3.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_3.png" width="513" height="398" /></a> </p>  <p>After clicking Next, we need to decide whether we create a new unique instance that hasn’t any ties with existing instances, or whether we want to create a replicate of an existing instance. For our purposes, the first option is what we need:</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_4.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_4.png" width="513" height="398" /></a> </p>  <p>Next, we’re asked for an instance name. The instance name will be used for the creation of a Windows Service, as well as to store some settings. Each instance will get its own Windows Service. In our sample, we’ll create a directory for the Northwind Employees tables, which we’ll use to create accounts further on.</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_5.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_5.png" width="513" height="398" /></a> </p>  <p>We’re almost there with the baseline configuration. The next question is to specify a port number, both for plain TCP and for SSL-encrypted traffic. The default ports, 389 and 636, are fine for us. Later we’ll be able to connect to the instance by connecting to LDP over port 389, e.g. using the System.DirectoryServices namespace functionality in .NET. Notice every instance of LDS should have its own port number, so only one can be using the default port numbers.</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_6.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_6.png" width="513" height="398" /></a> </p>  <p>Now that we have completed the “physical administration”, the wizard moves on to a bit of “logical administration”. More specifically, we’re given the option to create a directory partition for the application. Here we choose to create such a partition, though in many concrete deployment scenarios you’ll want the application’s setup to create this at runtime. Our partition’s distinguished name will mimic a “Northwind.local” domain containing a partition called “Employees”:</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_7.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_7.png" width="513" height="398" /></a> </p>  <p>After this bit of logical administration, some more physical configuration has to be carried out, specifying the data files location and the account to run the services under. For both, the default settings are fine. Also the administrative account assigned to manage the LDS instance can be kept as the currently logged in user, unless you feel the need to change this in your scenario:</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_8.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_8.png" width="513" height="398" /></a>&#160;<a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_9.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_9.png" width="513" height="398" /></a> </p>  <p>Finally, we’ve arrived at an interesting step where we’re given the option to import LDIF files. And LDIF file, with extension .ldf, contains the definition of a class that can be added to a directory service’s schema. Basically those contain things like attributes and their types. Under the %SystemRoot%\ADAM folder, a set of out-of-the-box .ldf files can be found:</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_10.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_10.png" width="669" height="293" /></a> </p>  <p>Instead of having to run the ldifde.exe tool, the wizard gives us the option to import LDIF files directly. Those classes are documented in various places, such as <a href="http://www.faqs.org/rfcs/rfc2798.html">RFC2798 for inetOrgPerson</a>. On TechNet, information is presented in a more structured manner, e.g revealing that <a href="http://msdn.microsoft.com/en-us/library/ms682282(VS.85).aspx">inetOrgPerson</a> is a subclass of <a href="http://msdn.microsoft.com/en-us/library/ms683980(v=VS.85).aspx">user</a>. Custom classes can be defined and imported after setup has completed. In this post, we won’t extend the schema ourselves but we will simply be using the built-in User class so let’s tick that one:</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_11.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_11.png" width="513" height="398" /></a> </p>  <p></p>  <p>After clicking Next, we get a last chance to revisit our settings or can confirm the installation. At this point, the wizard will create the instance – setting up the service – and import the LDIF files.</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_12.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_12.png" width="513" height="398" /></a>&#160;<a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_13.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_13.png" width="513" height="398" /></a> </p>  <p>Congratulations! Your first LDS instance has materialized. If everything went alright, the NorthwindEmployees service should show up:</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_14.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_14.png" width="1091" height="329" /></a> </p>  <p>&#160;</p>  <h1>Inspecting the directory</h1>  <p>To inspect the newly created directory instance, a bunch of tools exist. One is ADSI Edit which you could already see in the Administrative Tools. To set it up, open the MMC-based tool and go to Action, Connect to… In the dialog that appears, specify the server name and choose Schema as the Naming Context.</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_15.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_15.png" width="394" height="392" /></a> </p>  <p></p>  <p>For example, if you want to inspect the User class, simply navigate to the Schema node in the tree and show the properties of the User entry.</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_16.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_16.png" width="866" height="234" /></a> </p>  <p>To visualize the objects in the application partition, connect using the distinguished name specified during the installation:</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_17.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_17.png" width="394" height="392" /></a> </p>  <p>Now it’s possible to create a new object in the directory using the context menu in the content pane:</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_18.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_18.png" width="626" height="276" /></a> </p>  <p>After specifying the class, we get to specify the “CN” name (for common name) of the object. In this case, I’ll use my full name:</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_19.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_19.png" width="451" height="384" /></a>&#160;<a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_20.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_20.png" width="451" height="384" /></a> </p>  <p>We can also set additional attributes, as shown below (using the “physicalDeliveryOfficeName” to specify the office number of the user):</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_21.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_21.png" width="451" height="384" /></a>&#160;<a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_22.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_22.png" width="414" height="461" /></a> </p>  <p></p>  <p></p>  <p></p>  <p></p>  <p>After clicking Set, closing the Attributes dialog and clicking Finish to create the object, we see it pop up in the items view of the ADSI editor snap-in:</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_23.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_23.png" width="572" height="367" /></a> </p>  <p>&#160;</p>  <h1>Programmatic population of the directory</h1>  <p>Obviously we’re much more interested in a programmatic way to program Directory Services. .NET supports the use of directory services and related protocols (LDAP in particular) through the System.DirectoryServices namespace. In a plain new Console Application, add a reference to the assembly with the same name (don’t both about other assemblies that deal with account management and protocol stuff):</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_24.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_24.png" width="468" height="208" /></a> </p>  <p>For this sample, I’ll also assume the reader got a Northwind SQL database sitting somewhere and knows how to get data out of its Employees table as rich objects. Below is how things look when using the LINQ to SQL designer:</p>  <p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_25.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_25.png" width="260" height="495" /></a> </p>  <p>We’ll just import a few details about the users; it’s left to the reader to map other properties onto attributes using the <a href="http://msdn.microsoft.com/en-us/library/ms683980(v=VS.85).aspx">documentation about the user directory services class</a>. Just a few lines of code suffice to accomplish the task (assuming the System.DirectoryServices namespace is imported):</p>  <blockquote>   <pre class="code"><span style="color:blue;">static void </span>Main()<br />{<br />    <span style="color:blue;">var </span>path = <span style="color:#a31515;">&quot;LDAP://bartde-hp07/CN=Employees,DC=Northwind,DC=local&quot;</span>;<br />    <span style="color:blue;">var </span>root = <span style="color:blue;">new </span><span style="color:#2b91af;">DirectoryEntry</span>(path);<br /><br />    <span style="color:blue;">var </span>ctx = <span style="color:blue;">new </span><span style="color:#2b91af;">NorthwindDataContext</span>();<br />    <span style="color:blue;">foreach </span>(<span style="color:blue;">var </span>e <span style="color:blue;">in </span>ctx.Employees)<br />    {<br />        <span style="color:blue;">var </span>cn = <span style="color:#a31515;">&quot;CN=&quot; </span>+ e.FirstName + e.LastName;<br /><br />        <span style="color:blue;">var </span>u = root.Children.Add(cn, <span style="color:#a31515;">&quot;user&quot;</span>);<br />        u.Properties[<span style="color:#a31515;">&quot;employeeID&quot;</span>].Value = e.EmployeeID;<br />        u.Properties[<span style="color:#a31515;">&quot;sn&quot;</span>].Value = e.LastName;<br />        u.Properties[<span style="color:#a31515;">&quot;givenName&quot;</span>].Value = e.FirstName;<br />        u.Properties[<span style="color:#a31515;">&quot;comment&quot;</span>].Value = e.Notes;<br />        u.Properties[<span style="color:#a31515;">&quot;homePhone&quot;</span>].Value = e.HomePhone;<br />        u.Properties[<span style="color:#a31515;">&quot;photo&quot;</span>].Value = e.Photo.ToArray();<br />        u.CommitChanges();<br />    }<br />}</pre>
</blockquote>
<br /><p>After running this code – obviously changing the LDAP path to reflect your setup – you should see the following in ADSI Edit (after hitting refresh):</p><br /><br /><p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_26.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_26.png" width="918" height="338" /></a> </p><br /><br /><p>Now it’s just plain easy to write an application that visualizes the employees with their data. We’ll leave that to the UI-savvy reader (just to tease that segment of my audience, I’ve also imported the employee’s photo as a byte-array).</p><br /><br /><p>&#160;</p><br />
<h1>A small preview of what’s coming up</h1><br /><br /><p>To whet the reader’s appetite about next episodes on this blog, below is a single screenshot illustrating something – IMHO – rather cool (use of <a href="http://linqtoad.codeplex.com/">LINQ to Active Directory</a> is just an implementation <em>detail </em>below):</p><br /><br /><p><a href="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_27.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/GettingStartedwithActiveDirectoryLightwe_F193/image_thumb_27.png" width="681" height="205" /></a> </p><br /><br /><p><strong>Note:</strong> What’s shown here is the result of a <font color="#ff0000">very early experiment</font> done as part of my current job on “LINQ to Anything” here in the “Cloud Data Programmability Team”. Please don’t fantasize about it as being a vNext feature of any product involved whatsoever. The core intent of those experiments is to emphasize the omnipresence of LINQ (and more widely, monads) in today’s (and tomorrow’s) world. While we’re not ready to reveal the “LINQ to Anything” mission in all its glory (rather think of it as “LINQ to the unimaginable”), we can drop some hints.</p><br /><br /><p>Stay tuned for more!</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=21656" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2010/07/07/the-case-of-the-failed-demo-stackoverflowexception-on-x64.aspx">The Case of The Failed Demo – StackOverflowException on x64</a></div><div class="moreinfo"><span class="date">Wednesday, July 07, 2010</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><h1>Introduction</h1>  <p>A while ago I was explaining runtime mechanisms like the stack and the heap to some folks. (As an aside, I’m writing a debugger course on “Advanced .NET Debugging with WinDbg with SOS”, which is an ongoing project. Time will tell when it’s ready to hit the streets.) Since the context was <a href="http://community.bartdesmet.net/blogs/bart/archive/2009/11/08/jumping-the-trampoline-in-c-stack-friendly-recursion.aspx">functional programming where recursion is a typical substitute (or fuel if you will) for loops</a>, an obvious topic for discussion is the possibility to hit a stack overflow. Armed with my favorite editor, Notepad.exe, and the C# command-line compiler, I quickly entered the following sample to show “looping with recursion” and how disaster can strike:</p>  <blockquote>   <p><font face="Courier New">using System; </font></p>    <p><font face="Courier New">class Program       <br />{        <br />&#160;&#160;&#160; static void Main()        <br />&#160;&#160;&#160; {        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Rec(0);        <br />&#160;&#160;&#160; } </font></p>    <p><font face="Courier New">&#160;&#160;&#160; static void Rec(int n)       <br />&#160;&#160;&#160; {        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (n % 1024 == 0)        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(n); </font></p>    <p><font face="Courier New">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <strong>Rec(n + 1);</strong>        <br />&#160;&#160;&#160; }        <br />}</font></p> </blockquote>  <p>The module-based condition in there is to avoid excessive slowdowns due to Console.WriteLine use, which is rather slow due to the way the Win32 console output system works. To my initial surprise, the overflow didn’t come anywhere in sight and the application kept running happily:</p>  <p><a href="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_thumb.png" width="677" height="162" /></a> </p>  <p>I rather expected something along the following lines:</p>  <p><a href="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_3.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_thumb_3.png" width="677" height="162" /></a> </p>  <p>So, what’s going on here? Though I realized pretty quickly what the root cause is of this unexpected good behavior, I’ll walk the reader through the thought process used to “debug” the application’s code.</p>  <p>&#160;</p>  <h1>I made a call, didn’t I?</h1>  <p>The first thing to check is that we really are making a recursive call in our Rec method. Obviously ildasm is the way to go to inspect that kind of stuff, so here’s the output which we did expect.</p>  <p><a href="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_4.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_thumb_4.png" width="603" height="458" /></a> </p>  <p>In fact, the statement made above – “which we did expect” – is debatable. Couldn’t the compiler just turn the call into a jump right to the start of the method after messing around a bit with the local argument slot that holds argument value n? That way we wouldn’t have to make a call and the code would still work as expected. Essentially what we’re saying here is that the compiler could have turned the recursive call into a loop construct. And indeed, some compilers do exactly that. For example, consider the following F# sample:</p>  <blockquote>   <p><font face="Courier New">#light </font></p>    <p><font face="Courier New">let <strong>rec</strong> Rec n =        <br />&#160;&#160; if n % 1024 = 0 then        <br />&#160;&#160;&#160;&#160;&#160;&#160; printfn &quot;%d&quot; n </font></p>    <p><font face="Courier New">&#160;&#160; Rec (n + 1) </font></p>    <p><font face="Courier New">Rec 0</font></p> </blockquote>  <p>Notice the explicit indication of the recursive nature of a function by means of the “rec” keyword. After compiling this piece of code using fsc.exe, the following code is shown in Reflector (decompiling to C# syntax) for the Rec function:</p>  <p><a href="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_5.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_thumb_5.png" width="1106" height="373" /></a> </p>  <p>The mechanics of the printf call are irrelevant. What matters is the code that’s executed after the n++ statement, which isn’t a recursive call to Rec itself. Instead, the compiler has figured out a loop can be used. Hence, no StackOverflowException will result.</p>  <p>Back to the C# sample though. What did protect the code from overflowing the stack? Let’s have some further investigations, but first … some background.</p>  <p>&#160;</p>  <h1>Tail calls</h1>  <p>One optimization that can be carried out for recursive functions is to spot tail calls and optimize them away into looping – or at a lower level, jumps – constructs. A tail call is basically a call after which the current stack frame is no longer needed upon return from the call. For example, our simple sample can benefit from tail call optimization since the Rec method doesn’t really do anything anymore after returning from the recursive Rec call:</p>  <blockquote>   <p><font face="Courier New">static void Rec(int n)       <br />{        <br />&#160;&#160;&#160; if (n % 1024 == 0)        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(n); </font></p>    <p><font face="Courier New">&#160;&#160;&#160; <strong>Rec(n + 1);</strong>        <br />}</font></p> </blockquote>  <p>This kind of optimization – as carried out by F# in the sample shown earlier – can’t always take place. For example, consider the following definition of a factorial method:</p>  <blockquote>   <p><font face="Courier New">static int Fac(int n)       <br />{        <br />&#160;&#160;&#160; if (n == 0)        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return 1;        <br />        <br /></font><font face="Courier New"><strong>&#160;&#160;&#160; return n * Fac(n – 1);         <br /></strong>}</font></p> </blockquote>  <p>The above has quite a few issues such as the inability to deal with negative values and obviously the arithmetic overflow disaster that will strike when the supplied “n” parameter is too large for the resulting factorial to fit in an Int32. <a href="http://community.bartdesmet.net/blogs/bart/archive/2007/02/24/system-numeric-biginteger.aspx">The BigInteger type introduced in .NET 4 (and not in .NET 3.5 as originally planned)</a> would be a better fit for this kind of computation, but let’s ignore this fact for now.</p>  <p>A more relevant issue in the context of our discussion is the code’s use of recursion where a regular loop would suffice, but now I’m making a value judgment of imperative control flow constructs versus a more functional style of using recursion. That’s true nonetheless is the fact that the code above is not immediately amenable for tail call optimization. To see why this is, rewrite the code as follows:</p>  <blockquote>   <p><font face="Courier New">static int Fac(int n)       <br />{        <br />&#160;&#160;&#160; if (n == 0)        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return 1;        <br />        <br /></font><font face="Courier New"><strong>&#160;&#160;&#160; int t = Fac(n – 1);         <br />&#160;&#160;&#160; return n * t;</strong></font><font face="Courier New"><strong>         <br /></strong>}</font></p> </blockquote>  <p>See what’s going on? After returning from the recursive call to Fac, we still need to have access to the value of “n” in the current call frame. As a result, we can’t reuse the current stack frame when making the recursive call. Implementing the above in F# (just for the sake of it) and decompiling it, shows the following code:</p>  <p><a href="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_6.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_thumb_6.png" width="500" height="322" /></a> </p>  <p>The culprit keeping us from employing tail call optimization is the multiplication instruction needed after the return from the recursive call to Fac. (Note: the second operand to the multiplication was pushed onto the evaluation stack in IL_0005; in fact IL_0006 could also have been a dup instruction.) C# code will be slightly different but achieve the same computation (luckily!).</p>  <p>Sometimes it’s possible to make a function amenable for tail call optimization by carrying out a manual rewrite. In the case of the factorial method, we can employ the following trick:</p>  <blockquote><font face="Courier New">static int Fac(int n)     <br />{      <br />&#160;&#160;&#160; return Fac_(n, 1);      <br />}      <br /></font><font face="Courier New">     <br />static int Fac_(int n, int res)      <br />{      <br />&#160;&#160;&#160; if (n == 0)      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return <strong>res</strong>;      <br />      <br /></font><font face="Courier New"><strong>&#160;&#160;&#160; return Fac_(n – 1, n * res);</strong></font><font face="Courier New"><strong>       <br /></strong>}</font></blockquote>  <p>Here, we’re not only decrementing n in every recursive call, we’re also keeping the running multiplication at the same time. In my post <a href="http://community.bartdesmet.net/blogs/bart/archive/2009/11/08/jumping-the-trampoline-in-c-stack-friendly-recursion.aspx">Jumping the trampoline in C# – Stack-friendly recursion</a>, I explained this principle in the “Don’t stand on my tail!” section. The F# equivalent of the code, shown below, results in tail call optimization once more:</p>  <blockquote>   <p><font face="Courier New">let rec Fac_ n res =       <br />&#160;&#160; if n = 0 then        <br />&#160;&#160;&#160;&#160;&#160;&#160; res        <br />&#160;&#160; else        <br />&#160;&#160;&#160;&#160;&#160;&#160; Fac_ (n - 1) (n * res) </font></p>    <p><font face="Courier New">let Fac n =       <br />&#160;&#160; Fac_ n 1</font></p> </blockquote>  <p>The compilation result is shown below:</p>  <p><a href="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_7.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_thumb_7.png" width="506" height="383" /></a> </p>  <p>You can clearly see the reuse of local argument slots.</p>  <p>&#160;</p>  <h1>A smart JIT</h1>  <p>All of this doesn’t yet explain why the original C# code is just working fine though our look at the generated IL code in the second section of this post did reveal the call instruction to really be there. One more party is involved in getting our much beloved piece of C# code to run on the bare metal of the machine: the JIT compiler.</p>  <p>In fact, as soon as I saw the demo not working as intended, the mental click was made to go and check this possibility. Why? Well, the C# compiler doesn’t optimize tail calls into loops, nor does it emit <a href="http://bartdesmet.net/blogs/bart/archive/2006/09/22/4463.aspx">tail.call instructions</a>. The one and only remaining party is the JIT compiler. And indeed, since I’m running on x64 and am using the command-line compiler, the JIT compiler is more aggressive about performing tail call optimizations.</p>  <p>Let’s explain a few things about the previous paragraph. First of all, why does the use of the command-line compiler matter? Won’t the same result pop up if I used a Console Application project in Visual Studio? Not quite, if you’re using Visual Studio 2010 that is. One the decisions made in the last release is to mark executables IL assemblies (managed .exe files) as 32-bit only. That doesn’t mean the image contains 32-bit instructions (in fact, the C# compiler never emits raw assembler); all it does it tell the JIT to only emit 32-bit assembler at runtime, hence resulting in a WOW64 process on 64-bit Windows. The reasons for this are explained in the <a href="http://blogs.msdn.com/b/rmbyers/archive/2009/06/09/anycpu-exes-are-usually-more-trouble-then-they-re-worth.aspx">Rick Byer’s blog post on the subject</a>. In our case, we’re running the C# compiler without the /platform:x86 flag – which now is passed by the default settings of a Visual Studio 2010 executable (not library!) project – therefore resulting in an “AnyCPU” assembly. The corflags.exe tool can be used to verify this claim:</p>  <p><a href="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_8.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_thumb_8.png" width="614" height="400" /></a> </p>  <p>In Visual Studio 2010, a new Console Application project will have the 32-bit only flag set by default. Again, reasons for this decision are brought up in Rick’s post on the subject.</p>  <p><a href="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_9.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_thumb_9.png" width="658" height="295" /></a> </p>  <p>Indeed, when running the 32-bit only assembly, a StackOverflowException results. An alternative way to tweak the flags of a managed assembly is by using corflags.exe itself, as shown below:</p>  <p><a href="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_10.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_thumb_10.png" width="617" height="399" /></a> </p>  <p></p>  <p>It turns out when the 64-bit JIT is involved, i.e. when the AnyCPU Platform target is set – the default on the csc.exe compiler – tail call optimization is carried out for our piece of code. A whole bunch of conditions under which tail calls can be optimized by the various JIT flavors can be found on <a href="http://blogs.msdn.com/b/davbr/archive/2007/06/20/tail-call-jit-conditions.aspx">David Broman’s blog</a>. Grant Richins has been blogging about <a href="http://blogs.msdn.com/b/clrcodegeneration/archive/2009/05/11/tail-call-improvements-in-net-framework-4.aspx">improvements made in .NET 4</a> (which don’t really apply to our particular sample). One important change in .NET 4 is the fact the 64-bit JIT now honors the “tail.” prefix on call instructions, which is essential to the success of functional style languages like F# (indeed, F#’s compiler actually has a tailcalls flags, which is on by default due to the language’s nature).</p>  <p>&#160;</p>  <h1>Seeing the 64-bit JIT’s work in action</h1>  <p>In order to show the reader the generated x64 code for our recursive Rec method definition, we’ll switch gears and open up WinDbg, leveraging the SOS debugger extension. Obviously this requires one to install the <a href="http://www.microsoft.com/whdc/devtools/debugging/default.mspx">Debugging Tools for Windows</a>. Also notice the section’s title to apply to x64. For x86 users, the same experiment can be carried out, revealing the x86 instructions generated <em>without</em> the tail call optimization, hence explaining the overflow observed on 32-bit executions.</p>  <p>Loading the ovf.exe sample (making sure the 32-bit only flag is <em><u>not</u></em> set!) under the WinDbg debugger – using windbg.exe ovf.exe – brings us to the first loader breakpoint as shown below. In order to load the Son Of Strike (SOS) debugger extension, set a module load breakpoint for clrjit.dll (which puts us in a convenient spot where the CLR has been sufficiently loaded to use SOS successfully). When that breakpoint hits, the extension can be loaded using .loadby sos clr:</p>  <p><a href="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_11.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_thumb_11.png" width="867" height="407" /></a> </p>  <p>Next, we need to set a breakpoint on the Rec method. In my case, the assembly’s file name is ovf.exe, the class is Program and the method is Rec, requiring me to enter the following commands:</p>  <p><a href="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_12.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_thumb_12.png" width="368" height="58" /></a> </p>  <p>The !bpmd extension command is used to set a breakpoint based on a MethodDesc – a structure used by the CLR to describe a method. Since the method hasn’t been JIT compiled yet, and hence no physical address for the executable code is available yet, a pending breakpoint is added. Now we let go the debugger and end up hitting the breakpoint which got automatically set when the JIT compiler took care of compiling the method (since it came “in sight” for execution, i.e. because of Main’s call into it). Using the !U – for unassemble – command we can now see the generated code:</p>  <p><a href="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_13.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_thumb_13.png" width="957" height="657" /></a> </p>  <p>Notice the presence of code like InitializeStdOutError which is the result from inlining of the Console.WriteLine method’s code. What’s going on here with regards to the tail call behavior is the replacement of a call instruction with a jump simply to the beginning of the generated code. The rest of the code can be deciphered with a bit of x86/x64 knowledge. For one thing, you can recognize the 1024 value (used for our modulo arithmetic) in 3FF which is 1023. The module check stretches over a few instructions that basically use a mask over the value to see whether any of the low bits is non-zero. If so, the value is not dividable by 1024; otherwise, it is. Based on this test (whose value gets stored in eax), a jump is made or not, either going through the path of calling Console.WriteLine or not.</p>  <p>&#160;</p>  <h1>Contrasting with the x86 assembler being used</h1>  <p>In the x86 setting, we’ll see different code. To show this, let’s use a Console Application in Visual Studio 2010, whose default platform target is – as mentioned earlier – 32-bit. In order to load SOS from inside the Immediate Window, enable the native debugger through the project settings:</p>  <p><a href="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_14.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_thumb_14.png" width="666" height="417" /></a> </p>  <p>Using similar motions as before, we can load the SOS extension upon hitting a breakpoint. Instead of using !bpmd, we can use !name2ee to resolve the JITTED Code Address for the given symbol, in this case the Program.Rec method:</p>  <p><a href="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_15.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_thumb_15.png" width="503" height="579" /></a> </p>  <p>Inspecting the generated code, one will encounter the following call instruction to the same method. This is the regular recursive call without any tail call optimization carried out. Obviously this will cause a StackOverflowException to occur. Also notice from the output below that the Console.WriteLine method call didn’t get inlined in this particular x86 case.</p>  <p><a href="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_16.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_thumb_16.png" width="704" height="282" /></a> </p>  <p></p>  <p></p>  <p>&#160;</p>  <h1>Revisiting the tail. instruction prefix</h1>  <p>As <a href="http://bartdesmet.net/blogs/bart/archive/2006/09/22/4463.aspx">referred to before</a>, the IL instruction set has a tail. prefix for call instructions. Before .NET 4, this was merely a hint to the JIT compiler. For x86, it was (and still is) a request of the IL generator to the JIT compiler to perform a tail call. For x64, prior to CLR 4.0, this request was not always granted. For our x86 case, we can have a go at inserting the tail. prefix for the recursive call in the code generated by the C# compiler (which doesn’t emit this instruction by itself as explained before). Using ildasm’s /out parameter, you can export the ovf.exe IL code to a text file. Notice the COR flags have been set to “32-bit required” using either the x86 platform target flag on csc.exe or by using corflags /32bit+:</p>  <p><a href="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_17.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_thumb_17.png" width="579" height="424" /></a> </p>  <p>Now tweak the code of Rec as shown below. After a tail call instruction, no further code should execute other than a ret. If this rule isn’t obeyed, the CLR will throw an exception signaling an invalid program. Hence we remove the nop instruction that resulted from a non-optimized build (Debug build or csc.exe use without /o+ flag). To turn the call into a tail call one, we add the “tail.” prefix. Don’t forget the space after the dot though:</p>  <p><a href="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_18.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_thumb_18.png" width="1152" height="360" /></a> </p>  <p>The session of roundtripping through ILDASM and ILASM with the manual tweak in Notepad shown above is shown here:</p>  <p><a href="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_19.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/TheCaseofTheFailedDemoStackOverflowExcep_BE15/image_thumb_19.png" width="625" height="558" /></a> </p>  <p>With this change in place, the ovf.exe will keep on running without overflowing the stack. Looking at the generated code through the debugger, one would see a jmp instruction instead of a call, explaining the fixed behavior.</p>  <p>&#160;</p>  <h1>Conclusion</h1>  <p>Tail calls are the bread and butter of iterative programs written in a functional style. As such, the CLR has evolved to support tail call optimization in the JIT when the tail. prefix is present, e.g. as emitted by the F# compiler when needed (though the IL code itself may be turned into a loop by the compiler itself). One thing to know is that on x64, the JIT is more aggressive about detecting and carrying out tail recursive calls (since it has a good value proposition with regards to “runtime intelligence cost” versus “speed-up factor”). For more information, I strongly recommend you to have a look at the CLR team’s blog: <a href="http://blogs.msdn.com/b/clrcodegeneration/archive/2009/05/11/tail-call-improvements-in-net-framework-4.aspx">Tail Call Improvements in .NET Framework 4</a>.</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=21619" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2010/07/06/hosting-windows-powershell-2-0-under-clr-4-0.aspx">Hosting Windows PowerShell 2.0 under CLR 4.0</a></div><div class="moreinfo"><span class="date">Tuesday, July 06, 2010</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><h1>Introduction</h1>  <p>Recently I’ve been playing with Windows PowerShell 2.0 again, in the context of my day-to-day activities. One hint should suffice for the reader to get an idea of what’s going on: push-based collections. While I’ll follow up on this subject pretty soon, this precursor post explains one of the things I had to work around.</p>  <p>&#160;</p>  <h1>PowerShell: a managed application or not?</h1>  <p>Being designed around the concept of managed object pipelines, one may expect powershell.exe to be a managed executable. However, it turns out this isn’t the case completely. If you try to run ildasm.exe on the PowerShell executable (which lives in %windir%\system32\WindowsPowerShell\v1.0 despite the 2.0 version number, due to setup complications), you get the following message:</p>  <p><a href="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_thumb.png" width="496" height="171" /></a> </p>  <p>So much for the managed executable theory. What else can be going on to give PowerShell the power of managed objects. Well, it could be hosting the CLR. To check this theory, we can use the dumpbin.exe tool, using the /imports flag, checking for mscoree.dll functions being called. And indeed, we encounter the <a href="http://msdn.microsoft.com/en-us/library/99sz37yh.aspx">CorBindToRuntimeEx</a> function that’s been the way to host the CLR prior to .NET 4’s <a href="http://msdn.microsoft.com/en-us/magazine/ee819091.aspx">in-process side-by-side</a> introduction (a feature I should blog about as well since I wrote a CLR host for in-process side-by-side testing on my prior team here at Microsoft).</p>  <p><a href="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_3.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_thumb_3.png" width="677" height="414" /></a> </p>  <p></p>  <p>One of the parameters passed to CorBindToRuntimeEx is the version of the CLR to be loaded. Geeks can use WinDbg or cdb to set a breakpoint on this function and investigate the version parameter passed to it by the PowerShell code:</p>  <p><a href="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_4.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_thumb_4.png" width="1092" height="200" /></a> </p>  <p>Notice the old code name of PowerShell still being revealed in the third stack frame (from the top). In order to hit this breakpoint on a machine that has .NET 4 installed, I’ve used the mscoreei.dll module rather than mscoree.dll. The latter has become a super-shim in the System32 folder, while the former one is where the CLR shim really lives (“i” stands for “implementation”). This refactoring has been done to aid in servicing the CLR on different version of Windows, where the operating system “owns” the files in the System32 folder.</p>  <p>Based on this experiment, it’s crystal clear the CLR is hosted by Windows PowerShell, with hardcoded affinity to v2.0.50727. This is in fact a good thing since automatic roll-forward to whatever the latest version of the CLR is on the machine could cause incompatibilities. One can expect future versions of Windows PowerShell to be based on more recent versions of the CLR, once all required testing has been carried out. (And in that case, one will likely use the <a href="http://msdn.microsoft.com/en-us/library/dd233134.aspx">new “metahost” CLR hosting APIs</a>.)</p>  <p>&#160;</p>  <h1>Loading .NET v4 code in PowerShell v2.0</h1>  <p>The obvious question with regards to some of the stuff I’ve been working on was whether or not we can run .NET v4 code in Windows PowerShell v2.0? It shouldn’t be a surprise this won’t work as-is, since the v2.0 CLR is loaded by the PowerShell host. Even if the hosting APIs weren’t involved and the managed executable were compiled against .NET v2.0, that version’s CLR would take precedence. This is in fact the case for ISE:</p>  <p><a href="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_5.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_thumb_5.png" width="579" height="344" /></a> </p>  <p>Trying to load a v4.0 assembly in Windows PowerShell v2.0 pathetically fails – as expected – with the following message:</p>  <p><a href="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_6.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_thumb_6.png" width="677" height="174" /></a> </p>  <p>So, what are the options to get this to work? Let’s have a look.</p>  <p><font color="#ff0000"><strong>Warning:</strong>&#160; None of those hacks are officially supported. At this point, Windows PowerShell is a CLR 2.0 application, capable of loading and executing code targeting .NET 2.0 through .NET 3.5 SP1 (all of which run on the second major version of the CLR).</font></p>  <p>&#160;</p>  <h2>Option 1 – Hacking the parameter passed to CorBindToRuntimeEx</h2>  <p>If we just need an ad-hoc test of Windows PowerShell v2.0 running on CLR v4.0, we can take advantage of WinDbg once more. Simply break on the CorBindToRuntimeEx and replace the v2.0.50727 string in memory by the v4.0 version, i.e. v4.0.30319. The “eu” command used for this purpose stands for “edit memory Unicode”:</p>  <p><a href="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_7.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_thumb_7.png" width="1047" height="413" /></a> </p>  <p>If we let go the debugger after this tweak, we’ll ultimately get to see Windows PowerShell running seemingly fine, this time on CLR 4.0. One proof is the fact we can load the .NET 4 assembly we tried to load before:</p>  <p><a href="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_8.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_thumb_8.png" width="677" height="198" /></a> </p>  <p>Another proof can be found by looking at the DLL list for the PowerShell.exe instance in Process Explorer:</p>  <p><a href="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_9.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_thumb_9.png" width="540" height="377" /></a> </p>  <p>No longer we see mscorwks.dll (which is indicative of CLR 2.0 or below), but a clr.dll module appears instead. While this hack works fine for single-shot experiments, we may want to get something more usable for demo and development purposes.</p>  <p><strong>Note:</strong>&#160; Another option – not illustrated here – would be to use <a href="http://research.microsoft.com/en-us/projects/detours/">Detours</a> and intercept the CorBindToRuntimeEx call programmatically, performing the same parameter substitution as the one we’ve shown through the lenses of the debugger. Notice though the use of CorBindToRuntimeEx is deprecated since .NET 4, so this is and stays a bit of a hack either way.</p>  <p>&#160;</p>  <h2>Option 2 – Hosting Windows PowerShell yourself</h2>  <p>The second option we’ll explore is to host Windows PowerShell ourselves, not by hosting the CLR and mimicking what PowerShell.exe does, but by using the APIs provided for this purpose. In particular, the <a href="http://msdn.microsoft.com/en-us/library/microsoft.powershell.consoleshell(VS.85).aspx">ConsoleShell</a> class is of use to achieve this. Moreover, besides simply hosting PowerShell in a CLR v4 process, we can also load snap-ins out of the box. But first things first, starting with a .NET 4 Console Application, add a reference to the System.Management.Automation and Microsoft.PowerShell.ConsoleHost assemblies which can be found under %programfiles%\Reference Assemblies\Microsoft\WindowsPowerShell\v1.0:</p>  <p><a href="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_10.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_thumb_10.png" width="482" height="408" /></a> </p>  <p>The little bit of code required to get basic hosting to work is shown below:</p>  <blockquote>   <pre class="code"><span style="color:blue;">using </span>System;<br /><span style="color:blue;">using </span>System.Management.Automation.Runspaces;<br /><span style="color:blue;">using </span>Microsoft.PowerShell;<br /><br /><span style="color:blue;">namespace </span>PSHostCLRv4<br />{<br /><span style="color:blue;">    class </span><span style="color:#2b91af;">Program<br />    </span>{<br /><span style="color:blue;">        static int </span>Main(<span style="color:blue;">string</span>[] args)<br />        {<br />            <span style="color:blue;">var </span>config = <span style="color:#2b91af;">RunspaceConfiguration</span>.Create();<br />            <span style="color:blue;">return </span><span style="color:#2b91af;">ConsoleShell</span>.Start(<br />                config,<br />                <span style="color:#a31515;">&quot;Windows PowerShell - Hosted on CLR v4\nCopyright (C) 2010 Microsoft Corporation. All rights reserved.&quot;</span>,<br />                <span style="color:#a31515;">&quot;&quot;</span>,<br />                args<br />            );<br />        }<br />    }<br />}</pre>
</blockquote>
<br /><p>Using the RunspaceConfiguration object, it’s possible to load snap-ins if desired. Since that would reveal the reason I was doing this experiment, I won’t go into detail on that just yet :-). The tip in the introduction should suffice to get an idea of the experiment I’m referring to. Here’s the output of the above:</p><br /><br /><p><a href="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_11.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/HostingWindowsPowerShell2.0underCLR4.0_A80A/image_thumb_11.png" width="677" height="198" /></a> </p><br /><br /><p>While this hosting on .NET 4 is all done using legitimate APIs, it’s better to be conservative when it comes to using this in production since PowerShell hasn’t been blessed to be hosted on .NET 4. While compatibility between CLR versions and for the framework assemblies has been a huge priority for the .NET teams (I was there when it happened), everything should be fine. But the slightest bit of pixy dust (e.g. changes in timing for threading, a classic!) could reveal some issue. <font color="#ff0000">Till further notice, use this technique only for testing and experimentation.</font></p><br /><br /><p>Enjoy and stay tuned for more PowerShell fun (combined with other technologies)!</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=21616" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2010/07/02/where-s-bart-s-blog-been.aspx">Where’s Bart’s Blog Been?</a></div><div class="moreinfo"><span class="date">Friday, July 02, 2010</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><p>A quick update to my readers on a few little subjects. First of all, some people have noticed my blog welcomed readers with <strong>a not-so-sweet 404 error message</strong> the last few days. Turned out my monthly bandwidth was exceeded which was enough reason for my hosting provider to take the thing offline.</p>  <p><a href="http://bartdesmet.info/images_wlw/WheresBartsBlogBeen_49D/image.png"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="image" border="0" alt="image" src="http://bartdesmet.info/images_wlw/WheresBartsBlogBeen_49D/image_thumb.png" width="550" height="300" /></a> </p>  <p>Since this is quite inconvenient I’ve started some migration of image content to another domain, which is work in progress and should (hopefully) prevent the issue from occurring again. Other measures will be taken to limit the download volumes.</p>  <p>Secondly, many others have noticed <strong>it’s been quite silent on my blog lately</strong>. As my colleague <a href="http://blogs.msdn.com/wesdyer">Wes</a> warned me, once you start enjoying every day of functional programming hacking on Erik’s team, time for blogging steadily decreases. What we call “hacking” has been applied to many projects we’ve been working on over here in the Cloud Programmability Team, some of which are yet undisclosed. The most visible one today is obviously the <a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx">Reactive Extensions</a> both for .NET and for JavaScript, which I’ve been evangelizing both within and outside the company. Another one which I can only give the name for is dubbed “LINQ to Anything” that’s – as you can imagine – keeping me busy and inspired on a daily and nightly basis. On top of all of this, I’ve got some other writing projects going on that are nearing completion (finally).</p>  <p>Anyway, the big plan is to <strong><font color="#ff0000">break the silence</font></strong> and start blogging again about our established technologies, including Rx in all its glory. Subjects will include continuation passing style, duality between IEnumerable&lt;T&gt; and IObservable&lt;T&gt;, parameterization for concurrency, discussion of the plethora of operators available, a good portion of monads for sure, the IQbservable&lt;T&gt; interface (no, I won’t discuss the <a href="http://en.wikipedia.org/wiki/Color_of_the_bikeshed">color of the bikeshed</a>) and one of its applications (LINQ to WMI Events), etc. Stay tuned for a series on those subjects starting in the hopefully very near future.</p>  <p>See you soon!</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=21608" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2010/04/19/some-introductory-rx-samples.aspx">Some introductory Rx samples</a></div><div class="moreinfo"><span class="date">Monday, April 19, 2010</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><p>During my last tour I’ve been collecting quite some fundamental and introductory Rx samples as illustrations with my presentations on the topic. As promised, I’m sharing those out through my blog. More Rx content is to follow in the (hopefully near) future, with an exhaustive discussion of various design principles and choices, the underlying theoretical foundation of Rx and coverage of lots of operators.</p>  <p>In the meantime, <a href="http://www.bartdesmet.net/download/Rx40Samples.zip">download the sample project here</a>. While the project targets Visual Studio 2010 RTM, you can simply take the Program.cs file and build a Visual Studio 2008 project around it, referencing the necessary Rx assemblies (which you can download from <a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx">DevLabs</a>).</p>  <p>Enjoy!</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=15110" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2010/03/28/come-and-join-me-for-an-rx-talk-at-visug-on-april-6th-in-zaventem-belgium.aspx">Come and join me for an Rx talk at VISUG on April 6th in Zaventem, Belgium</a></div><div class="moreinfo"><span class="date">Sunday, March 28, 2010</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><p>As part of my three week African and European tour I have the honor to talk to the local Belgian Visual Studio User Group (VISUG) on April 6th in the Microsoft Belux offices in Zaventem, Belgium. Seats are limited, but there’s still time for you to register. More info <a href="http://www.visug.be/Eventdetails/tabid/95/EventId/24/Default.aspx">can be found here</a>. Oh, and there will be catering as well :-). Other opportunities to see me are on TechDays Belgium and DevDays Netherlands, which are both held next week. I’ll post resources about Rx talks to my blog later on and hope to find the bandwidth to write an extensive series on the topic, so stay tuned!</p>  <p><a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx"><img style="border-bottom:0px;border-left:0px;border-top:0px;border-right:0px;" title="" border="0" alt="" align="left" src="http://i.msdn.microsoft.com/ee794896.DevLabs_Rx_Project(en-us).png" /></a></p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=15103" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2010/03/05/new-drop-of-the-reactive-extensions-for-net-rx-available.aspx">New drop of the Reactive Extensions for .NET (Rx) available</a></div><div class="moreinfo"><span class="date">Friday, March 05, 2010</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><p>It&#39;s been a long time I&#39;ve written epic blog posts over here, but for a good reason. We&#39;ve been working very hard on getting a new Rx release out the door and I&#39;m proud to announce it&#39;s available now through <a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx">http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx</a>. Notice we got a .NET 4 RC compatible download available as well, so you can play with the latest and greatest of technologies in one big jar :-). More goodness will follow later, so stay tuned!</p><br /><p>At some point in the foreseeable future, I&#39;ll start a series on how Rx works and what its operators are as well. If you have any particular topics you&#39;d like to see covered, don&#39;t hesitate to let me know through my blog. In the meantime, make sure to evaporate all your feedback on the forums at <a href="http://social.msdn.microsoft.com/Forums/en-US/rx/threads">http://social.msdn.microsoft.com/Forums/en-US/rx/threads</a>. We love to hear what you think, what operators you believe are missing, any bugs you find, etc.</p><br /><p><strong>Update:</strong> We also have published a video on the new release at <a href="http://channel9.msdn.com/posts/J.Van.Gogh/Your-RxNET-Prescription-Has-Been-Refilled">http://channel9.msdn.com/posts/J.Van.Gogh/Your-RxNET-Prescription-Has-Been-Refilled</a>.</p><br /><p>Have fun!<br />Bart @ Rx</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=15080" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2010/01/10/2010-a-personal-change-putting-my-head-in-the-cloud.aspx">2010 – A Personal Change: putting my “Head In The Cloud”</a></div><div class="moreinfo"><span class="date">Monday, January 11, 2010</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><p>Slightly over two years after arriving here in Redmond to work on the WPF team, time has come for me to make a switch and pursue other opportunities within the company. Starting January 13th, I’ll be working on the <strong>SQL Cloud Data Programmability Team</strong> on various projects related to <em>democratizing the cloud</em>. While we have much more rabbits sitting in our magician hats, <a href="http://blogs.bartdesmet.net/blogs/bart/archive/tags/Rx/default.aspx">Rx</a> is the first big deliverable we’re working on.</p>  <blockquote>   <p><a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx"><img style="border-bottom:0px;border-left:0px;display:inline;margin-left:0px;border-top:0px;margin-right:0px;border-right:0px;" title="" border="0" alt="" src="http://i.msdn.microsoft.com/ee794896.DevLabs_Rx_Project(en-us).png" /></a></p> </blockquote>  <p>For my blog, there won’t be much change as I’ve always written on topics related to what I’ll be working on: language innovation, data access, LINQ, type systems, lambda fun, etc. I’m planning to stay committed to blogging and other evangelism activities, including speaking engagements from time to time, so feel free to ping me if I’m in your proximity (or if you’re visiting our campus). Next up and confirmed are TechDays “low lands” in <a href="http://www.techdays.be">Belgium</a> and the <a href="http://www.devdays.nl/">Netherlands</a>, end of March.</p>  <p>Needless to say, I’m thrilled to have this opportunity of working together with a relatively small group of smart and passionate people, on the things I’d spend all my free time on anyway. Having this one-to-one alignment between day-to-day professional activities at work and all sorts of free time hacking projects is like a dream coming true. Thanks <a>Danny</a>, <a href="http://research.microsoft.com/en-us/um/people/emeijer/">Erik</a>, <a>Jeffrey</a>, <a href="http://www.cartesianclosed.com/">Mark</a> and <a href="http://blogs.msdn.com/wesdyer">Wes</a> for taking me on board.</p>  <p>Expect to see more Rx blogging love over here, and watch out for more goodness to come your way in the foreseeable future. In the meantime, check out the following resources on the matter:</p>  <ul>   <li><a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx">MSDN DevLabs Rx homepage</a></li>    <li><a href="http://channel9.msdn.com/tags/Rx/">Channel 9 Rx videos</a></li>    <li><a href="http://blogs.bartdesmet.net/blogs/bart/archive/tags/Rx/default.aspx">My Rx blog category</a></li>    <li><a href="http://social.msdn.microsoft.com/Forums/en-US/rx/threads">Our forums</a></li> </ul>  <p>Please keep the feedback on Rx coming: help us, help you!</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=15042" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2010/01/07/more-linq-with-system-interactive-functional-fun-and-taming-side-effects.aspx">More LINQ with System.Interactive – Functional fun and taming side-effects</a></div><div class="moreinfo"><span class="date">Thursday, January 07, 2010</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><p>With the recent release of the <a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx">Reactive Extensions for .NET (Rx)</a> on <a href="http://msdn.microsoft.com/en-us/devlabs/default.aspx">DevLabs</a>, you’ll hear quite a bit about reactive programming, based on the IObservable&lt;T&gt; and IObserver&lt;T&gt; interfaces. A great amount of resources is available <a href="http://channel9.msdn.com/tags/Rx/">on Channel 9</a>. In this series, I’ll focus on the <a href="http://channel9.msdn.com/shows/Going+Deep/Expert-to-Expert-Brian-Beckman-and-Erik-Meijer-Inside-the-NET-Reactive-Framework-Rx/">dual</a> of the System.Reactive assembly, which is System.Interactive, providing a bunch of extensions to the <a href="http://www.codeplex.com/LINQSQO">LINQ Standard Query Operators</a> for IEnumerable&lt;T&gt;. In today’s installment we’ll talk about EnumerableEx’s facilities to tame side-effects in a functionally inspired manner:</p>  <p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveFunctionalfunandtamingsid_9DCC/image.png"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveFunctionalfunandtamingsid_9DCC/image_thumb.png" width="526" height="480" /></a></p>  <p>&#160;</p>  <h1>To side effect or not to side effect?</h1>  <p>Being rooted in query comprehensions as seen in various functional programming languages (including (the) pure one(s)), one would expect LINQ to have a very functional basis. Indeed it has, but being hosted in various not functionally pure languages like C# and Visual Basic, odds are off reasoning about side-effects in a meaningful and doable manner. As we’ve seen before, when talking about the Do and Run operators, it’s perfectly possible for a query to exhibit side-effects during iteration. You don’t even have to look that far, since every lambda passed to a query operator is an opportunity of introducing effects. The delayed execution nature of LINQ queries makes that those effects appear at the point of query execution. So far, nothing new.</p>  <p>So, the philosophical question ought to be whether or not we should embrace side-effects or go for absolute purity. While the latter would be preferable for various reasons, it’s not enforceable through the hosting languages for LINQ, so maybe we should exploit side-effects if we really want to do so. The flip side of this train of thought is that those side-effects could come and get us if we’re not careful, especially when queries get executed multiple times, potentially as part of a bigger query. In such a case, you’d likely not want effects to be duplicated. Below is a sample of such a problematic query expression:</p>  <blockquote>   <pre class="code"><span style="color:blue;">var </span>xrs = <span style="color:#2b91af;">EnumerableEx</span>.Generate(<span style="color:blue;">new </span><span style="color:#2b91af;">Random</span>(), rnd =&gt; <span style="color:#2b91af;">EnumerableEx</span>.Return(rnd.Next(100)), <span style="color:green;">/* iterate */ </span>_ =&gt; _);<br />xrs.Zip(xrs, (l, r) =&gt; l + r).Take(10).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p>Using Generate, we generate a sequence of random numbers. Recall the first argument is the state of the anamorphic Generate operator, which we get passed in the lambdas following it: once to produce an output sequence (just a single random number in our case) and once to iterate (just keeping the same random number generator here). What’s more important is we’re relying on the side-effect of reading the random number generator which, as the name implies, provides random answers to the Next inquiry every time it gets called. In essence, the side-effect can (not) be seen by looking at the signature of Random.Next, which says it returns an int. In .NET this means the method <em>may</em> return the <em>same</em> int every time it gets called, but there are no guarantees whatsoever (as there would be in pure functional programming languages).</p><br /><br /><p>This side-effect, innocent and intentional as it may seem, comes and gets us if we perform a Zip on the sequence with itself. Since Zip iterates both sides, we’re really triggering separate enumeration (“GetEnumerator”) over the same sequence two times. Though it’s the same sequence object, each of its iterations will produce different results. As a result, the expected invariant of the Zip’s output being only even numbers (based on the assumption l and r would be the same as they’re produced by the same sequence) doesn’t hold:</p><br /><br /><blockquote><br />  <p>52<br />    <br />114<br /><br />    <br />112<br /><br />    <br /><font color="#ff0000">103<br />      <br />41<br /><br />      <br />135</font><br /><br />    <br />78<br /><br />    <br />114<br /><br />    <br /><font color="#ff0000">59<br />      <br />137</font></p>
</blockquote>
<br /><p>While random number generation is a pretty innocent side-effect, not having it under control properly can lead to unexpected results as shown above. We can visualize this nicely using another side-effect introduced by Do:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>xrs = <span style="color:#2b91af;">EnumerableEx</span>.Generate(<span style="color:blue;">new </span><span style="color:#2b91af;">Random</span>(), rnd =&gt; <span style="color:#2b91af;">EnumerableEx</span>.Return(rnd.Next(100)), <span style="color:green;">/* iterate */ </span>_ =&gt; _)<br />    .Do(xr =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;! -&gt; &quot; </span>+ xr));<br /><font color="#ff0000">xrs</font>.Zip(<font color="#ff0000">xrs</font>, (l, r) =&gt; l + r).Take(10).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>This will print a message for every number flowing out of the random number generating sequence, as shown below:</p><br /><br /><blockquote><br />  <p>! -&gt; 97<br />    <br />! -&gt; 78<br /><br />    <br />175<br /><br />    <br />! -&gt; 11<br /><br />    <br />! -&gt; 6<br /><br />    <br />17<br /><br />    <br />! -&gt; 40<br /><br />    <br />! -&gt; 17<br /><br />    <br />57<br /><br />    <br />! -&gt; 92<br /><br />    <br />! -&gt; 63<br /><br />    <br />155<br /><br />    <br />! -&gt; 70<br /><br />    <br />! -&gt; 13<br /><br />    <br />83<br /><br />    <br />! -&gt; 41<br /><br />    <br />! -&gt; 1<br /><br />    <br />42<br /><br />    <br />! -&gt; 64<br /><br />    <br />! -&gt; 76<br /><br />    <br />140<br /><br />    <br />! -&gt; 30<br /><br />    <br />! -&gt; 71<br /><br />    <br />101<br /><br />    <br />! -&gt; 1<br /><br />    <br />! -&gt; 81<br /><br />    <br />82<br /><br />    <br />! -&gt; 65<br /><br />    <br />! -&gt; 45<br /><br />    <br />110</p>
</blockquote>
<br /><p>If we look a bit further to the original query, we come to the conclusion we can’t apply any form of equational reasoning anymore: it seems that the common subexpression “xrs” is not “equal” (as in exposing the same results) in both use sites. The immediate reason in the case of LINQ is the delayed execution, which is a good thing as our Generate call produces an infinite sequence. More broadly, it’s the side-effect that lies at the heart of the problem as equational reasoning breaks down in such a setting. For that very reason, side-effect permitting languages have a much harder time carrying out optimizations to code and need to be very <em>strict</em> about specifying the order in which operations are performed (e.g. in C#, arguments to a method call – which is always “call-by-value” – are evaluated in a left-to-right order).</p><br /><br /><p>Moving Take(10) up doesn’t change the delayed characteristic either:</p><br /><br /><blockquote></blockquote>
<br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>xrs = <span style="color:#2b91af;">EnumerableEx</span>.Generate(<span style="color:blue;">new </span><span style="color:#2b91af;">Random</span>(), rnd =&gt; <span style="color:#2b91af;">EnumerableEx</span>.Return(rnd.Next(100)), <span style="color:green;">/* iterate */ </span>_ =&gt; _)<br /><strong><font color="#ff0000">    .Take(10)</font></strong><br />    .Do(xr =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;! -&gt; &quot; </span>+ xr));<br />xrs.Zip(xrs, (l, r) =&gt; l + r).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>What would help is forcing the common subexpression’s query to execute, persisting (= caching) its results in memory, before feeding them in to the expression using it multiple times:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>xrs = <span style="color:#2b91af;">EnumerableEx</span>.Generate(<span style="color:blue;">new </span><span style="color:#2b91af;">Random</span>(), rnd =&gt; <span style="color:#2b91af;">EnumerableEx</span>.Return(rnd.Next(100)), <span style="color:green;">/* iterate */ </span>_ =&gt; _)<br />    .Take(10)<font color="#00ff00">.ToArray()</font><br />    .Do(xr =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;! -&gt; &quot; </span>+ xr));<br />xrs.Zip(xrs, (l, r) =&gt; l + r).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Don’t forget the Take(10) call though, as calling ToArray (or ToList) on an infinite sequence is not quite advised on today’s machines with finite amounts of memory. It’s clear such hacking is quite brittle and it breaks the delayed execution nature of the query expression. In other words, you can’t really hand out the resulting expression to a caller for it to call when it needs results (if it ever does). We’re too eager about evaluating (part of) the query, just to be able to tame the side-effect:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>xrs = <span style="color:#2b91af;">EnumerableEx</span>.Generate(<span style="color:blue;">new </span><span style="color:#2b91af;">Random</span>(), rnd =&gt; <span style="color:#2b91af;">EnumerableEx</span>.Return(rnd.Next(100)), <span style="color:green;">/* iterate */ </span>_ =&gt; _)<br />    .Take(10)<font color="#ff0000">.ToArray()</font>;<br /><br /><span style="color:blue;">var </span>randomEvens = xrs.Zip(xrs, (l, r) =&gt; l + r);</pre><br /><br />  <pre class="code"><span style="color:green;">// What if the consumer of randomEvens <em>expects</em> different results on each enumeration... Hard cheese! </span><br />randomEvens.Run(<span style="color:#2b91af;">Console</span>.WriteLine);<br />randomEvens.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a><a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>It’s clear that we need some more tools in our toolbox to tame desired side-effects when needed. That’s exactly what this post focuses on.</p><br /><br /><p>&#160;</p><br />
<h1>Option 1: Do nothing with Let</h1><br /><br /><p>A first way to approach side-effects is to embrace them as-is. We just allow multiple enumerations of the same sequence to yield different results (or more generally, replicate side-effects). However, we can provide a bit more syntactical convenience in writing queries that reuse the same common subexpression in multiple places. In the above, we had to introduce an intermediate variable to store the common expression in, ready for reuse further on:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>xrs = <span style="color:#2b91af;">EnumerableEx</span>.Generate(<span style="color:blue;">new </span><span style="color:#2b91af;">Random</span>(), rnd =&gt; <span style="color:#2b91af;">EnumerableEx</span>.Return(rnd.Next(100)), <span style="color:green;">/* iterate */ </span>_ =&gt; _);<br />xrs.Zip(xrs, (l, r) =&gt; l + r).Take(10).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>Can’t we somehow write this more fluently? The answer is yes, using the Let operator which passes its left-hand side to a lambda expression that can potentially use it multiple times:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">EnumerableEx</span>.Generate(<span style="color:blue;">new </span><span style="color:#2b91af;">Random</span>(), rnd =&gt; <span style="color:#2b91af;">EnumerableEx</span>.Return(rnd.Next(100)), <span style="color:green;">/* iterate */ </span>_ =&gt; _)<br />    .Let(xrs =&gt; xrs.Zip(xrs, (l, r) =&gt; l + r)).Take(10).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>You can guess the signature of Let just by looking at the use above, but <em>let</em>’s include it for completeness:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt; Let&lt;TSource, TResult&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt;, <span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt;&gt; function);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Because of the call-by-value nature of the languages we’re talking about, the expression used for the source parameter will be fully evaluated (not the same as enumerated!) before Let gets called, so we can feed it (again in a call-by-value manner) to the function which then can refer to it multiple times by means of its lambda expression parameter (in the sample above this is “xrs”). Let comes from the world of functional languages where it takes the following form:</p><br /><br /><blockquote><br />  <p>let x = y in z</p>
</blockquote>
<br /><p>means (in C#-ish syntax)</p><br /><br /><blockquote><br />  <p>(x =&gt; z)(y)</p>
</blockquote>
<br /><p>In other words, there’s a hidden function x =&gt; z sitting in a let-expression and the “value” for x (which is y in the sample) gets passed to it, providing the result for the entire let-expression. In EnumerableEx.Let, the function is clear as the second parameter, and the role of “y” is fulfilled by the source parameter. One could create a Let-form for any object as follows (not recommended because of the unrestricted extension method):</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span>R Let&lt;T, R&gt;(<span style="color:blue;">this </span>T t, <span style="color:#2b91af;">Func</span>&lt;T, R&gt; f)<br />{<br />    <span style="color:blue;">return </span>f(t);<br />}</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>With this, you can write things like this:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#2b91af;">DateTime</span>.Now.Let(x =&gt; x - x).Ticks);</pre>
</blockquote>
<br /><p>This will print 0 ticks for sure, since the same DateTime.Now is used for x on both sides of the subtraction. If we were to expand this expression by substituting DateTime.Now for x, we’d get something different due to the duplicate evaluation of DateTime.Now, exposing the side-effect of reading from the system clock:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Console</span>.WriteLine((<span style="color:#2b91af;">DateTime</span>.Now - <span style="color:#2b91af;">DateTime</span>.Now).Ticks);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>(Pop quiz: What sign will the above Ticks result have? Is it possible for the above to return 0 sometimes?)</p><br /><br /><p>&#160;</p><br />
<h1>Option 2: Cache on demand a.k.a. MemoizeAll</h1><br /><br /><p>As we’ve seen before, on way to get rid of the side-effect replication is by forcing eager evaluation of the sequence through operators like ToArray or ToList. However, those are a bit too eager in various ways:</p><br />
<ul><br />  <li>They <em>persist </em>the whole sequence, which won’t work for infinite sequences.</li>
<br />  <li>They do so <em>on the spot</em>, i.e. the eagerness can’t be delayed till a later point (‘on demand”).</li>
</ul>
<br /><p>The last problem can be worked around using the Defer operator, but the first one is still a problem requiring another operator. Both those things are what MemoizeAll provides for, essentially persisting the sequence bit-by-bit upon consumption. This is achieved by exposing the enumerable while only maintaining a single enumerator to its source:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveFunctionalfunandtamingsid_9DCC/image_3.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveFunctionalfunandtamingsid_9DCC/image_thumb_3.png" width="640" height="456" /></a> </p>
</blockquote>
<br /><p>In the figure above, this is illustrated. Red indicates a fetch operation where the original source’s iterator makes progress as an element is requested that hasn’t been fetched before. Green indicates persisted (cached, memoized) objects. Gray indicates elements in the source that have been fetched and hence belong to the past from the (single) source-iterators point of view: MemoizeAll won’t ever request those again. Applying this operator to our running sample using Zip will produce results with the expected invariant:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>xrs = <span style="color:#2b91af;">EnumerableEx</span>.Generate(<span style="color:blue;">new </span><span style="color:#2b91af;">Random</span>(), rnd =&gt; <span style="color:#2b91af;">EnumerableEx</span>.Return(rnd.Next(100)), <span style="color:green;">/* iterate */ </span>_ =&gt; _)<br />    .Do(xr =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;! -&gt; &quot; </span>+ xr))<br />    .MemoizeAll();<br />xrs.Do(xr =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;L -&gt; &quot; </span>+ xr)).Zip(<br />    xrs.Do(xr =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;R -&gt; &quot; </span>+ xr)),<br />    (l, r) =&gt; l + r).Take(10).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a><a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Now we’ll see the xrs-triggered Do messages being printed only 10 times since the same element will be consumed by the two uses of xrs within Zip. The result looks as follows, showing how the right consumer of Zip never causes a fetch back to the random number generating source due to the internal caching by MemoizeAll:</p><br /><br /><blockquote><br />  <p>! -&gt; 71<br />    <br />L -&gt; 71<br /><br />    <br />R -&gt; 71<br /><br />    <br />142<br /><br />    <br />! -&gt; 18<br /><br />    <br />L -&gt; 18<br /><br />    <br />R -&gt; 18<br /><br />    <br />36<br /><br />    <br />! -&gt; 12<br /><br />    <br />L -&gt; 12<br /><br />    <br />R -&gt; 12<br /><br />    <br />24<br /><br />    <br />! -&gt; 96<br /><br />    <br />L -&gt; 96<br /><br />    <br />R -&gt; 96<br /><br />    <br />192<br /><br />    <br />! -&gt; 1<br /><br />    <br />L -&gt; 1<br /><br />    <br />R -&gt; 1<br /><br />    <br />2<br /><br />    <br />! -&gt; 54<br /><br />    <br />L -&gt; 54<br /><br />    <br />R -&gt; 54<br /><br />    <br />108<br /><br />    <br />! -&gt; 9<br /><br />    <br />L -&gt; 9<br /><br />    <br />R -&gt; 9<br /><br />    <br />18<br /><br />    <br />! -&gt; 87<br /><br />    <br />L -&gt; 87<br /><br />    <br />R -&gt; 87<br /><br />    <br />174<br /><br />    <br />! -&gt; 18<br /><br />    <br />L -&gt; 18<br /><br />    <br />R -&gt; 18<br /><br />    <br />36<br /><br />    <br />! -&gt; 12<br /><br />    <br />L -&gt; 12<br /><br />    <br />R -&gt; 12<br /><br />    <br />24</p>
</blockquote>
<br /><p>What about lifetime of the source’s single enumerator? As soon as one of the consumers reaches the end of the underlying sequence, we got all elements cached and are prepared to any possible inquiry for elements on the output side of the MemoizeAll operator, hence it’s possible to dispose of the original enumerator. It should also be noted that memoization operators use materialization internally to capture the behavior of the sequence to expose to all consumers. This means exceptions are captured as Notification&lt;T&gt; so they’re repeatable to all consumers:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>xes = <span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">Exception</span>()).StartWith(1).MemoizeAll();<br />xes.Catch((<span style="color:#2b91af;">Exception </span>_) =&gt; <span style="color:#2b91af;">EnumerableEx</span>.Return(42)).Run(<span style="color:#2b91af;">Console</span>.WriteLine);<br />xes.Catch((<span style="color:#2b91af;">Exception </span>_) =&gt; <span style="color:#2b91af;">EnumerableEx</span>.Return(42)).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>The above will therefore print 1, 42 twice. In other words, the source blowing up during fetching by MemoizeAll doesn’t terminate other consumers that haven’t reached the faulty state yet (but if they iterate long enough, they’ll eventually see it exactly as the original consumer did).</p><br /><br /><p>Finally, what’s All about MemoizeAll? In short: the cache used by the operator can grow infinitely large. The difference compared to ToArray and ToList has been explained before, but it’s worth repeating it: MemoizeAll doesn’t fetch its source’s results on the spot but only makes progress through the source’s enumerator when one of the consumers requests an element that hasn’t been retrieved yet. Call it a piecemeal ToList if you want.</p><br /><br /><p>&#160;</p><br />
<h1>Option 3: Memoize, but less “conservative”</h1><br /><br /><p>While MemoizeAll does the trick to avoid repetition of side-effects, it’s quite conservative in its caching as it never throws away elements it has retrieved. You never know whether someone – like a slow enumerator or a whole new enumerator over the memoized result – will request the data again, so a general-purpose Memoize can’t throw away a thing. However, if you know the behavior of the consumers of the memoized source, you can be more efficient about it and use Memoize specifying a buffer size. In our running sample of Zip we know that both uses of the source for the left and right inputs to Zip will be enumerated at the same pace, so it suffices to keep the last element in the cache in order for the right enumerator to be able to see the element the left enumerator just saw. Memoize with buffer size 1 does exactly that:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>xrs = <span style="color:#2b91af;">EnumerableEx</span>.Generate(<span style="color:blue;">new </span><span style="color:#2b91af;">Random</span>(), rnd =&gt; <span style="color:#2b91af;">EnumerableEx</span>.Return(rnd.Next(100)), <span style="color:green;">/* iterate */ </span>_ =&gt; _)<br />    .Do(xr =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;! -&gt; &quot; </span>+ xr))<br />    .Memoize(1);<br />xrs.Do(xr =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;L -&gt; &quot; </span>+ xr)).Zip(<br />    xrs.Do(xr =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;R -&gt; &quot; </span>+ xr)),<br />    (l, r) =&gt; l + r).Take(10).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>In pictures, this looks as follows:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveFunctionalfunandtamingsid_9DCC/image_4.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveFunctionalfunandtamingsid_9DCC/image_thumb_4.png" width="640" height="456" /></a> </p>
</blockquote>
<br /><p>Another valid buffer size – also the default – is zero. It’s left to the reader, as an exercise, to come up with a plausible theory for what that one’s behavior should be and to depict this case graphically.</p><br /><br /><p>(Question: Would it be possible to provide a “smart” memoization operator that knows exactly when it can abandon items in the front of its cache? Why (not)?)</p><br /><br /><p>&#160;</p><br />
<h1>Derived forms</h1><br /><br /><p>The difference between Let and the Memoize operators is that the former feeds in a view on an IEnumerable&lt;T&gt; source to a function, allowing that one to refer to the source multiple times in the act of producing a source in return. Let is, as we saw, nothing but fancy function application in a “fluent” left-to-right dataflowy way. Derived forms of Memoize exist that have the same form where a function is fed a memoized data source:</p><br />
<ul><br />  <li>Replay is Memoize on steroids</li>
<br />  <li>Publish is MemoizeAll on steroids</li>
</ul>
<br /><p>The following snippets show just what those operators do (modulo parameter checks):</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt; Publish&lt;TSource, TResult&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source,<br />                                                             Func&lt;<span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt;, <span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt;&gt; function)<br />{<br />    <span style="color:blue;">return </span>function(source.MemoizeAll());<br />}<br /><br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt; Publish&lt;TSource, TResult&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source,<br />                                                             Func&lt;<span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt;, <span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt;&gt; function,<br />                                                             TSource initialValue)<br />{<br />    <span style="color:blue;">return </span>function(source.MemoizeAll().StartWith(initialValue));<br />}<br /><br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt; Replay&lt;TSource, TResult&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source,<br />                                                            Func&lt;<span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt;, <span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt;&gt; function)<br />{<br />    <span style="color:blue;">return </span>function(source.Memoize());<br />}<br /><br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt; Replay&lt;TSource, TResult&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source,<br />                                                            Func&lt;<span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt;, <span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt;&gt; function,<br />                                                            <span style="color:blue;">int </span>bufferSize)<br />{<br />    <span style="color:blue;">return </span>function(source.Memoize(bufferSize));<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>So we could rewrite our Zip sample in a variety of ways, the following being the cleanest one-sized buffer variant:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">EnumerableEx</span>.Generate(<span style="color:blue;">new </span><span style="color:#2b91af;">Random</span>(), rnd =&gt; <span style="color:#2b91af;">EnumerableEx</span>.Return(rnd.Next(100)), <span style="color:green;">/* iterate */ </span>_ =&gt; _)<br />    .Do(xr =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;! -&gt; &quot; </span>+ xr))<br />    .Replay(<font color="#ff0000">xrs</font> =&gt; <font color="#ff0000">xrs</font>.Do(xr =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;L -&gt; &quot; </span>+ xr)).Zip(<br />                   <font color="#ff0000">xrs</font>.Do(xr =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;R -&gt; &quot; </span>+ xr)),<br />                   (l, r) =&gt; l + r),<br />            1)<br />    .Take(10).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>&#160;</p><br />
<h1>Option 4: Fair (?) sharing with Share and Prune</h1><br /><br /><p>The Share operator shares an IEnumerator&lt;T&gt; for any number of consumers of an IEnumerable&lt;T&gt;, hence avoiding duplication of side-effects. In addition, it also guarantees that no two consumers can see the same element, so in effect the Share operator has the potential of distributing elements across different consumers. Looking at it from another angle, one consumer can steal elements from the source, preventing another consumer from seeing it. Prune is derived from Share as follows:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt; Prune&lt;TSource, TResult&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source,<br />                                                           Func&lt;<span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt;, <span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt;&gt; function)<br />{<br />    <span style="color:blue;">return </span>function(source.Share());<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The naming for Prune follows from the effect consumers inside the function have on the sequence being shared: each one consuming data effectively prunes elements from the head of the sequence, so that others cannot see those anymore. An example is shown below, showing another way a Zip could go <em>wrong</em> (practical scenarios for this operator would involve sharing) since the left and right consumers both advance the cursor of the same shared enumerator under the hood:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">EnumerableEx</span>.Generate(<span style="color:blue;">new </span><span style="color:#2b91af;">Random</span>(), rnd =&gt; <span style="color:#2b91af;">EnumerableEx</span>.Return(rnd.Next(100)), <span style="color:green;">/* iterate */ </span>_ =&gt; _)<br />    .Do(xr =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;! -&gt; &quot; </span>+ xr))<br />    .Prune(xrs =&gt; xrs.Do(xr =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;L -&gt; &quot; </span>+ xr)).Zip(<br />                   xrs.Do(xr =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;R -&gt; &quot; </span>+ xr)),<br />                   (l, r) =&gt; l + r))<br />    .Take(10).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>The result of this is of interest since the logging will reveal the sharing characteristic. Looking at the first Do’s output we’ll see it gets triggered by any consumer on the inside of Prune:</p><br /><br /><blockquote><br />  <p>! -&gt; 37<br />    <br />L -&gt; 37<br /><br />    <br />! -&gt; 51<br /><br />    <br />R -&gt; 51<br /><br />    <br />88<br /><br />    <br />! -&gt; 98<br /><br />    <br />L -&gt; 98<br /><br />    <br />! -&gt; 89<br /><br />    <br />R -&gt; 89<br /><br />    <br />187<br /><br />    <br />! -&gt; 4<br /><br />    <br />L -&gt; 4<br /><br />    <br />! -&gt; 71<br /><br />    <br />R -&gt; 71<br /><br />    <br />75<br /><br />    <br />! -&gt; 43<br /><br />    <br />L -&gt; 43<br /><br />    <br />! -&gt; 30<br /><br />    <br />R -&gt; 30<br /><br />    <br />73<br /><br />    <br />! -&gt; 18<br /><br />    <br />L -&gt; 18<br /><br />    <br />! -&gt; 24<br /><br />    <br />R -&gt; 24<br /><br />    <br />42<br /><br />    <br />! -&gt; 17<br /><br />    <br />L -&gt; 17<br /><br />    <br />! -&gt; 41<br /><br />    <br />R -&gt; 41<br /><br />    <br />58<br /><br />    <br />! -&gt; 45<br /><br />    <br />L -&gt; 45<br /><br />    <br />! -&gt; 68<br /><br />    <br />R -&gt; 68<br /><br />    <br />113<br /><br />    <br />! -&gt; 83<br /><br />    <br />L -&gt; 83<br /><br />    <br />! -&gt; 53<br /><br />    <br />R -&gt; 53<br /><br />    <br />136<br /><br />    <br />! -&gt; 64<br /><br />    <br />L -&gt; 64<br /><br />    <br />! -&gt; 69<br /><br />    <br />R -&gt; 69<br /><br />    <br />133<br /><br />    <br />! -&gt; 0<br /><br />    <br />L -&gt; 0<br /><br />    <br />! -&gt; 22<br /><br />    <br />R -&gt; 22<br /><br />    <br />22</p>
</blockquote>
<br /><p>In pictures, this looks as follows:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveFunctionalfunandtamingsid_9DCC/image_5.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveFunctionalfunandtamingsid_9DCC/image_thumb_5.png" width="640" height="456" /></a> </p>
</blockquote>
<br /><p>Exercise: Can you guess how Memoize(0) differs from Share?</p><br /><br /><p>Quiz: What should be the behavior of the following fragment? (Tip: you got to know what two from clauses result in and how they execute)</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Enumerable</span>.Range(0, 10)<font color="#008000"><br /></font><span style="color:green;">    </span>.Prune(xs =&gt; <span style="color:blue;">from </span>x <span style="color:blue;">in </span>xs.Zip(xs, (l, r) =&gt; l + r)<br />                 <span style="color:blue;">from </span>y <span style="color:blue;">in </span>xs<br />                 <span style="color:blue;">select </span>x + y)<br />    .Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>&#160;</p><br />
<h1>Next on More LINQ</h1><br /><br /><p>A look at the Asynchronous and Remotable operators, dealing with some infrastructure-related concepts, wrapping up this series for now.</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=15025" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2010/01/03/top-9-posts-from-2009.aspx">Top 9 Posts from 2009</a></div><div class="moreinfo"><span class="date">Sunday, January 03, 2010</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><pre class="code"><span style="color:blue;">select top </span>9 [Subject] <span style="color:blue;">from </span>dbo<span style="color:gray;">.</span>cs_Posts<br /><span style="color:blue;">where </span>postlevel <span style="color:gray;">= </span>1 <span style="color:gray;">and </span>usertime <span style="color:gray;">&lt; </span><span style="color:red;">&#39;01/01/2010&#39; </span><span style="color:gray;">and </span>usertime <span style="color:gray;">&gt;= </span><span style="color:red;">&#39;01/01/2009&#39;<br /></span><span style="color:blue;">order by </span>TotalViews <span style="color:blue;">desc</span></pre><br /><a href="http://11011.net/software/vspaste"></a><br /><br /><p>Forgive me for the classic SQL, but here are the results with some short annotations inline:</p><br />
<ol><br />  <li><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/08/17/mis-using-c-4-0-dynamic-type-free-lambda-calculus-church-numerals-and-more.aspx">(Mis)using C# 4.0 Dynamic – Type-Free Lambda Calculus, Church Numerals, and more</a> <br /><br />    <br /><br /><br />    <br />Uses the new C# 4.0 dynamic feature to implement the type-free lambda calculus consisting of an abstraction and application operator. Besides talking about the fundamentals of lambda calculus, this post shows how to implement the SKI combinators and Church Booleans, Church numerals and even recursive functions. <br /><br />    <br />&#160; </li>
<br />  <li><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/08/17/linq-to-ducks-bringing-back-the-duck-typed-foreach-statement-to-linq.aspx">LINQ to Ducks – Bringing Back The Duck-Typed foreach Statement To LINQ</a> <br /><br />    <br /><br /><br />    <br />Since LINQ to Objects is layered on top of IEnumerable&lt;T&gt;, it doesn’t work against objects that just happen to implement the enumeration pattern consisting of GetEnumerator, MoveNext and Current. Since the foreach statement actually does work against such data sources, we bring back this duck typing to LINQ using AsDuckEnumerable&lt;T&gt;(). <br /><br />    <br />&#160; </li>
<br />  <li><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/08/30/type-free-lambda-calculus-in-c-pre-4-0-defining-the-lambda-language-runtime-llr.aspx">Type-Free Lambda Calculus in C#, Pre-4.0 – Defining the Lambda Language Runtime (LLR)</a> <br /><br />    <br /><br /><br />    <br />We repeat the exercise of the first blog post but now without C# 4.0 dynamic features., encoding application and abstraction operators using none less that exceptions. Those primitives define what I call the Lambda Language Runtime (LLR), which we use subsequently to implement a bunch of samples similar to the ones in the first post. <br /><br />    <br />&#160; </li>
<br />  <li><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/09/12/taming-your-sequence-s-side-effects-through-ienumerable-let.aspx">Taming Your Sequence’s Side-Effects Through IEnumerable.Let</a> <br /><br />    <br /><br /><br />    <br />Enumerable sequences can exhibit side-effects for various reasons ranging from side-effecting filter predicates to iterators with side-effecting imperative code interwoven in them. The Let operator introduced in this post helps you to keep those side-effects under control when multiple “stable” enumerations over the sequence are needed. <br /><br />    <br />&#160; </li>
<br />  <li><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/08/11/statement-trees-with-less-pain-follow-up-on-system-linq-expressions-v4-0.aspx">Statement Trees With Less Pain – Follow-Up on System.Linq.Expressions v4.0</a> <br /><br />    <br /><br /><br />    <br />The introduction of the DLR in the .NET 4 release brings us not only dynamic typing but also full-fledged statement trees as an upgrade to the existing LINQ expression trees. Here we realize a prime number generator using statement trees and runtime compilation, reusing expression trees emitted by the C# compiler where possible. <br /><br />    <br />&#160; </li>
<br />  <li><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/09/27/linq-to-z3-theorem-solving-on-steroids-part-1.aspx">LINQ to Z3 – Theorem Solving on Steroids – Part 1</a> <br /><br />    <br /><br /><br />    <br />LINQifying Microsoft Research’s Z3 theorem solver has been one of my long-running side-projects. This most recent write-up on the matter illustrates the concept of a LINQ-enabled Theorem&lt;T&gt; and the required visitor implementation to interop with the Z3 libraries. Finally, we show a Sudoku and Kakuro solver expressed in LINQ. <br /><br />    <br />&#160; </li>
<br />  <li><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/08/10/expression-trees-take-two-introducing-system-linq-expressions-v4-0.aspx">Expression Trees, Take Two – Introducing System.Linq.Expressions v4.0</a> <br /><br />    <br /><br /><br />    <br />Just like post 5, we have a look at the .NET 4 expression tree support, now including statement trees. Besides pointing out the new tree node types, we show dynamic compilation and inspect the generated IL code using the SOS debugger’s dumpil command. In post 5, we follow up by showing how to reuse C# 3.0 expression tree support. <br /><br />    <br />&#160; </li>
<br />  <li><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/04/27/unlambda-net-with-a-big-dose-of-c-3-0-lambdas.aspx">Unlambda .NET – With a Big Dose of C# 3.0 Lambdas</a> <br /><br />    <br /><br /><br />    <br />Esoteric programming languages are good topics for <a href="http://community.bartdesmet.net/blogs/bart/archive/tags/Crazy+Sundays/default.aspx">Crazy Sundays</a> posts. In this one we had a look at how to implement the Unlambda language – based on SKI combinators and with “little” complications like Call/CC – using C# 3.0 with lots of lambda expressions. To satisfy our curiosity, we run a Fibonacci sample program. <br /><br />    <br />&#160; </li>
<br />  <li><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/04/13/c-4-0-feature-focus-part-4-generic-co-and-contra-variance-for-delegate-and-interface-types.aspx">C# 4.0 Feature Focus – Part 4 – Co- and Contra-Variance for Generic Delegate and Interface Types</a> <br /><br />    <br /><br /><br />    <br />Generic co- and contra-variance is most likely the most obscure C# 4.0 feature, so I decided to give it a bit more attention using samples of the everyday world (like apples and tomatoes). We explain why arrays are unsafe for covariance and how generic variance gets things right, also increasing your expressiveness. </li>
</ol>
<br /><p>In conclusion, it seems esoteric and foundational posts are quite popular, but then again that’s what I write about most. For 2010, I hope to please my readers’ interests even further with the occasional “stunt coding”, “brain pain” and “mind bending” (based on Twitter quotes in 2009). If there are particular topics you’d like to see covered, feel free to let me know. So, thanks again for reading in 2009 (good for slightly over 1TB – no that’s not a typo – of data transfer from my hoster) and <strong>hope to see you back in 2010</strong>!</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=14996" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2010/01/02/linqsqo-v4-0-and-minlinq-v1-0-now-available-for-download.aspx">LINQSQO v4.0 and MinLINQ v1.0 Now Available for Download</a></div><div class="moreinfo"><span class="date">Saturday, January 02, 2010</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><p>Introduced in my previous blog post on <a href="http://blogs.bartdesmet.net/blogs/bart/archive/2010/01/01/the-essence-of-linq-minlinq.aspx">The Essence of LINQ – MinLINQ</a>, the first release of this project is now available for reference at the LINQSQO CodePlex website at <a title="http://linqsqo.codeplex.com/" href="http://linqsqo.codeplex.com">http://linqsqo.codeplex.com</a>. Compared to the write-up over here in my previous post, there are a few small differences and caveats:</p>  <ul>   <li>Only FEnumerable functionality is available currently; the FObservable dual may follow later.</li>    <li>Option&lt;T&gt; has been renamed to Maybe&lt;T&gt;, to be CLS compliant and avoid clashes with the VB keyword.</li>    <li>Some operators are not provided, in particular GroupBy, GroupJoin and Join. They’re left as an exercise.</li>    <li>A few operator implementations are categorized as “cheaters” since they roundtrip through System.Linq.</li>    <li>Don’t nag about performance. The MinLINQ code base is by no means optimal and so be it.</li>    <li>Very few System.Interactive operators are included since those often require extra foundations (such as concurrency).</li> </ul>  <p>A few highlights:</p>  <ul>   <li>FEnumerable.Essentials.cs is where the fun starts. Here the three primitives – Ana, Bind and Cata – form the ABC of LINQ.</li>    <li>There’s a Naturals() constructor function generating an infinite sequence of natural numbers, used in operators that use indexes.</li>    <li>OrderBy and ThenBy are supported through roundtripping to System.Linq with a handy trick to keep track of IOrderedEnumerable&lt;T&gt;.</li>    <li>As a sample, I’ve included <a href="http://blogs.msdn.com/lukeh/archive/2007/10/01/taking-linq-to-objects-to-extremes-a-fully-linqified-raytracer.aspx">Luke Hoban’s LINQified RayTracer</a> with AsFEnumerable and AsEnumerable roundtripping. It works just fine.</li>    <li>Creating an architectural diagram in Visual Studio 2010 yields the following result (not meant to zoomed in), where I’ve used the following colors:</li>    <ul>     <li>Green = Ana</li>      <li>Blue = Bind</li>      <li>Red = Cata</li>   </ul> </ul>  <p><a href="http://bartdesmet.net/images_wlw/LINQSQOv4.0andM.0NowAvailableforDownload_71CD/image.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/LINQSQOv4.0andM.0NowAvailableforDownload_71CD/image_thumb.png" width="1131" height="274" /></a> </p>  <p>Obviously, all sorts of warnings apply. People familiar to my blog adventures will know this already, but just in case:</p>  <blockquote>   <pre class="code"><span style="color:green;">//<br />// This project is meant as an illustration of how an academically satifying layering<br />// of a LINQ to Objects implementation can be realized using monadic concepts and only<br />// three primitives: anamorphism, bind and catamorphism.<br />//<br />// The code in this project is not meant to be used in production and no guarantees are<br />// made about its functionality. Use it for academic stimulation purposes only. To use<br />// LINQ for real, use System.Linq in .NET 3.5 or higher.<br />//<br />// All of the source code may be used in presentations of LINQ or for other educational<br />// purposes, but references to http://www.codeplex.com/LINQSQO and the blog post referred<br />// to above - &quot;The Essence of LINQ - MinLINQ&quot; - are required.<br />//</span></pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Either way, if you find LINQ interesting and can stand some “brain pain of the highest quality” (a Twitter quote by dahlbyk), this will likely be something for you.</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=14989" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2010/01/01/the-essence-of-linq-minlinq.aspx">The Essence of LINQ – MinLINQ</a></div><div class="moreinfo"><span class="date">Friday, January 01, 2010</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><h1>Introduction</h1>  <p>Before reaching the catharsis in the <a href="http://blogs.bartdesmet.net/blogs/bart/archive/tags/Rx/default.aspx">“More LINQ with System.Interactive” series</a> over here, I wanted to ensure a solid understanding of the essence of LINQ in my reader base. Often people forget the true essence of a technology due to the large number of auxiliary frameworks and extensions that are being provided. Or worse, sometimes a sense for the essence never materialized.</p>  <p>Searching for essence is nothing other than a “group by” operation, partitioning the world in fundamentals and derived portions. One succeeds in this mission if the former group is much smaller than the latter. In this post, we’ll try to reach that point for the IEnumerable&lt;T&gt; and IObservable&lt;T&gt; LINQ implementations, illustrating both are fundamentally similar (and dare I say, dual?). You can already guess much of the essence lies in the concept of <strong>monads</strong>. By the end of the post, we’ll have distilled the core of LINQ, which I refer to as MinLINQ since <a href="http://en.wikipedia.org/wiki/MinWin">small is beautiful</a>.</p>  <p>&#160;</p>  <h1>Interfaces are overrated?</h1>  <p>While loved by object-oriented practitioners, interfaces are essentially nothing but <em>records of functions</em>. And functions, as we all know, are the fundamental pillars of functional programming languages. This trivial observation is illustrated below. I’ll leave it to the reader to think about various implications of the use of a (covariant) IRecord representation for objects:</p>  <blockquote>   <pre class="code"><span style="color:blue;">class </span><span style="color:#2b91af;">Program<br /></span>{<br />    <span style="color:blue;">static void </span>Main()<br />    {<br />        <span style="color:blue;">for </span>(<span style="color:blue;">var </span>c = <span style="color:blue;">new </span><span style="color:#2b91af;">Counter</span>(); c.Get() &lt; <span style="color:brown;">10</span>; c.Inc(<span style="color:brown;">1</span>))<br />            <span style="color:#2b91af;">Console</span>.WriteLine(c.Get());<br />    }<br />}<br /><br /><span style="color:blue;">interface </span><span style="color:#2b91af;">IRecord</span>&lt;<span style="color:blue;">out </span>T1, <span style="color:blue;">out </span>T2&gt;<br />{<br />    T1 First { <span style="color:blue;">get</span>; }<br />    T2 Second { <span style="color:blue;">get</span>; }<br />}<br /><br /><span style="color:blue;">class </span><span style="color:#2b91af;">Counter </span>: <span style="color:#2b91af;">IRecord</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>&gt;, <span style="color:#2b91af;">Action</span>&lt;<span style="color:blue;">int</span>&gt;&gt;<br />{<br />    <span style="color:green;">// Data<br />    </span><span style="color:blue;">private int </span>_value;<br /><br />    <span style="color:green;">// Code - explicit implementation to hide First, Second<br />    </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>&gt; <span style="color:#2b91af;">IRecord</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>&gt;, <span style="color:#2b91af;">Action</span>&lt;<span style="color:blue;">int</span>&gt;&gt;.First { <span style="color:blue;">get </span>{ <span style="color:blue;">return </span>() =&gt; _value; } }<br />    <span style="color:#2b91af;">Action</span>&lt;<span style="color:blue;">int</span>&gt; <span style="color:#2b91af;">IRecord</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>&gt;, <span style="color:#2b91af;">Action</span>&lt;<span style="color:blue;">int</span>&gt;&gt;.Second { <span style="color:blue;">get </span>{ <span style="color:blue;">return </span>i =&gt; _value += i; } }<br /><br />    <span style="color:green;">// Code - friendly &quot;interface&quot;<br />    </span><span style="color:blue;">public </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>&gt; Get { <span style="color:blue;">get </span>{ <span style="color:blue;">return </span>((<span style="color:#2b91af;">IRecord</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>&gt;, <span style="color:#2b91af;">Action</span>&lt;<span style="color:blue;">int</span>&gt;&gt;)<span style="color:blue;">this</span>).First; } }<br />    <span style="color:blue;">public </span><span style="color:#2b91af;">Action</span>&lt;<span style="color:blue;">int</span>&gt; Inc { <span style="color:blue;">get </span>{ <span style="color:blue;">return </span>((<span style="color:#2b91af;">IRecord</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>&gt;, <span style="color:#2b91af;">Action</span>&lt;<span style="color:blue;">int</span>&gt;&gt;)<span style="color:blue;">this</span>).Second; } }<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Why do we care? Well, it turns out that IEnumerable&lt;T&gt; and IObservable&lt;T&gt; tend to obscure the true meaning of the objects a bit by having many different methods to facilitate the task of enumeration and observation, respectively. The source of this apparent bloating is irrelevant (and in fact follows design guidelines of an object-oriented inspired framework); what matters more is to see how the two mentioned interfaces can be boiled down to their essence.</p><br /><br /><p>Minimalistic as we are, we’re going to drop the notion of error cases that manifest themselves through MoveNext throwing an exception and OnError getting called, respectively on IEnumerator&lt;T&gt; and IObserver&lt;T&gt;. For similar reasons of simplification, we’ll also not concern ourselves with the disposal of enumerators or subscriptions. The resulting picture looks as follows:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image.png"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_thumb.png" width="640" height="343" /></a> </p>
</blockquote>
<br /><p>To consolidate things a bit further, we’ll collapse MoveNext/Current on the left, and OnNext/OnCompleted on the right. How so? Well, either getting or receiving the next element can provide a value or a termination signal. This is nothing but a pair of an optional value and a Boolean. Turns out we have such a thing in the framework, called Nullable&lt;T&gt; but since one can’t nest those guys or use them on reference types, it doesn’t help much. Instead, we’ll represent the presence or absence of a value using an Option&lt;T&gt; type:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public abstract class </span><span style="color:#2b91af;">Option</span>&lt;T&gt;<br />{<br />    <span style="color:blue;">public abstract bool </span>HasValue { <span style="color:blue;">get</span>; }<br />    <span style="color:blue;">public abstract </span>T Value { <span style="color:blue;">get</span>; }<br /><br />    <span style="color:blue;">public sealed class </span><span style="color:#2b91af;">None </span>: <span style="color:#2b91af;">Option</span>&lt;T&gt;<br />    {<br />        <span style="color:blue;">public override bool </span>HasValue<br />        {<br />            <span style="color:blue;">get </span>{ <span style="color:blue;">return false</span>; }<br />        }<br /><br />        <span style="color:blue;">public override </span>T Value<br />        {<br />            <span style="color:blue;">get </span>{ <span style="color:blue;">throw new </span><span style="color:#2b91af;">InvalidOperationException</span>(); }<br />        }<br /><br />        <span style="color:blue;">public override string </span>ToString()<br />        {<br />            <span style="color:blue;">return </span><span style="color:#a31515;">&quot;None&lt;&quot; </span>+ <span style="color:blue;">typeof</span>(T).Name + <span style="color:#a31515;">&quot;&gt;()&quot;</span>;<br />        }<br />    }<br /><br />    <span style="color:blue;">public sealed class </span><span style="color:#2b91af;">Some </span>: <span style="color:#2b91af;">Option</span>&lt;T&gt;<br />    {<br />        <span style="color:blue;">private </span>T _value;<br /><br />        <span style="color:blue;">public </span>Some(T value)<br />        {<br />            _value = value;<br />        }<br /><br />        <span style="color:blue;">public override bool </span>HasValue<br />        {<br />            <span style="color:blue;">get </span>{ <span style="color:blue;">return true</span>; }<br />        }<br /><br />        <span style="color:blue;">public override </span>T Value<br />        {<br />            <span style="color:blue;">get </span>{ <span style="color:blue;">return </span>_value; }<br />        }<br /><br />        <span style="color:blue;">public override string </span>ToString()<br />        {<br />            <span style="color:blue;">return </span><span style="color:#a31515;">&quot;Some&lt;&quot; </span>+ <span style="color:blue;">typeof</span>(T).Name + <span style="color:#a31515;">&quot;&gt;(&quot; </span>+ (_value == <span style="color:blue;">null </span>? <span style="color:#a31515;">&quot;null&quot; </span>: _value.ToString()) + <span style="color:#a31515;">&quot;)&quot;</span>;<br />        }<br />    }<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The subtypes None and Some are optional though convenient, hence I’ll leave them in. With this, IEnumerator&lt;T&gt; would boil down to an interface with a single method retrieving an Option&lt;T&gt;. When it returns a Some object, there was a next element and we got it; when it returns None, we’ve reached the end of the enumeration. Similar for IObserver&lt;T&gt;, OnNext and OnCompleted are merged into a single method receiving an Option&lt;T&gt;. Interfaces with a single method have a name: they’re delegates. So both those types can be abbreviated to:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">IObserver</span>&lt;T&gt;&#160; –&gt;  <span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;<br /><span style="color:#2b91af;">IEnumerator</span>&lt;T&gt;&#160; –&gt;  <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>A quick recap: an observer is something you can give a value or tell it has reached the end of the observable object, hence it takes in an Option&lt;T&gt;; an enumerator is something you can get a value from but it can also signal the end of the enumerable object, hence it produces an Option&lt;T&gt;. In a more functional notation, one could write:</p><br /><br /><blockquote><br />  <p>Option&lt;T&gt; –&gt; () <br />    <br />() –&gt; Option&lt;T&gt;</p>
</blockquote>
<br /><p>Here the arrow indicates “goes to”, just as in lambda expressions, with the argument on the left and the return type on the right. All that has happened is reverting the arrows to go from an observer to an enumerator and vice versa. That’s the essence of <strong>dualization</strong>.</p><br /><br /><p>But we’re not done yet. Look one level up at the IEnumerable&lt;T&gt; and IObserver&lt;T&gt; interfaces. Those are single-method ones too, hence we can play the same trick as we did before. The IEnumerable&lt;T&gt; interface’s single method returns an IEnumerator&lt;T&gt;, which we already collapsed into a simple function above. And in a dual manner, IObservable&lt;T&gt;’s single method takes in an IObserver&lt;T&gt;, which we also collapsed above. The yields the following result:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">IObservable</span>&lt;T&gt;  –&gt;  <span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt;<br /><span style="color:#2b91af;">IEnumerable</span>&lt;T&gt;  –&gt;  <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt;</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>If that isn’t a simplification, I don’t know what would be. An observable is nothing other than an action taking in an action taking in an observed value, while an enumerable is nothing other than a function returning a function returning a yielded value. Or, in concise functional notation:</p><br /><br /><blockquote><br />  <p>(Option&lt;T&gt; –&gt; ()) –&gt; () <br />    <br />() –&gt; (() –&gt; Option&lt;T&gt;)</p>
</blockquote>
<br /><p>Again, to go from one world to the other, it suffices to reverse the arrows to reach the dual form. In summary, have a look at the following figure:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_3.png"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_thumb_3.png" width="660" height="500" /></a></p>
</blockquote>
<br /><p>&#160;</p><br />
<h1>Flat functions – FEnumerable and FObservable</h1><br /><br /><p>Since we’ve flattened <em>imperative </em>interfaces into <em>flat </em>functions we’re going to provide several operators over those, we need to have a name for the type to stick those items in. Though we’re not going to make things purely functional on the inside (as we’ll rely on side-effects to implement various operators), I still like to call it function-style enumerable and observable, hence the names FEnumerable and FObservable (not meant to be pronounceable), where F stands for Function as opposed to I for Interface. In addition, Ex additions will materialize to realize some layering as discussed below. The result, including FEnumerableEx2 that’s left as an exercise, is shown below:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_4.png"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_thumb_4.png" width="438" height="480" /></a> </p>
</blockquote>
<br /><p>&#160;</p><br />
<h1>Five essential operators, or maybe even less</h1><br /><br /><p>To continue on our merry way towards the essence of LINQ, we’ll be providing five essential operators as the building blocks to construct most other operators out of. Needless to say so, those operators will use the above flat function “interfaces” to do their work on. Let’s start with a couple of easy ones: Empty and Return.</p><br /><br /><p>&#160;</p><br />
<h2>Empty</h2><br /><br /><p>The Empty operator is very straightforward and never deals with Option&lt;T&gt;.Some values, just signaling an Option&lt;T&gt;.None immediately to signal completion. Hence the produced collection is empty. How do we realize this operator in the enumerable and observable case? Not surprisingly, the implementation is straightforward in both cases:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static class </span><span style="color:#2b91af;">FEnumerable<br /></span>{<br />    <span style="color:blue;">public static </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; Empty&lt;T&gt;()<br />    {<br />        <span style="color:blue;">return </span>() =&gt; () =&gt; <span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">None</span>();<br />    }</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>First, the FEnumerable one. All it does is simply returning a function that returns an end-of-sequence None signal in return to getting called. Notice the two levels of nesting needed to be conform with the signature. The outer function is the one retrieving the enumerator, while the inner is the equivalent to MoveNext and Current. For absolute clarity:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_5.png"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_thumb_5.png" width="597" height="291" /></a> </p>
</blockquote>
<br /><p>One the FObservable side of things, we find a similar implementation shuffled around a little bit, as shown below:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static class </span><span style="color:#2b91af;">FObservable<br /></span>{<br />    <span style="color:blue;">public static </span><span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; Empty&lt;T&gt;()<br />    {<br />        <span style="color:blue;">return </span>o =&gt; o(<span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">None</span>());<br />    }</pre>
</blockquote>
<br /><p>What used to be output now becomes input: the None constructor call no long appears in an output position but has moved to an input position. Similar for the observer, indicated with o, which has moved to an input position. Upon giving the observable object (the whole thing) an observer (o), the latter gets simply called with a None object indicating the end of the sequence. The inner call is equivalent to OnCompleted, while the whole lambda expression is equivalent to Subscribe.</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_6.png"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_thumb_6.png" width="660" height="295" /></a> </p>
</blockquote>
<br /><p>The careful reader may spot an apparent difference in the multiplicity of the involved operations. Where one enumerable can be used to get multiple enumerators, it seems that one observable cannot be used with multiple observers. This is only how it looks, as duality comes to the rescue to explain this again. The statement for enumerables goes as follows: “<em>multiple calls </em>to GetEnumerator each <em><strong>return</strong> one </em>IEnumerator”. The dual of that becomes “a <em>single call </em>to Subscribe can <em><strong>take in </strong>multiple</em> IObservers”. While that’s not exactly the case in the real IObserver land, where you either wrap all of your observers in a single IObserver to achieve this effect, or make multiple calls to Subscribe (assuming – and that’s where the MinLinq approach differs slightly – a call to subscribe doesn’t block), it’s incredibly true in FObservable. How so? Well, one can combine delegates using the + operator to achieve the effect of subscribing multiple observers at the same time:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;<span style="color:blue;">int</span>&gt;&gt; observer1 = x =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;1 &lt;- &quot; </span>+ x);<br /><span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;<span style="color:blue;">int</span>&gt;&gt; observer2 = x =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;2 &lt;- &quot; </span>+ x);<br /><br /><span style="color:blue;">var </span>xs = <span style="color:#2b91af;">FObservable</span>.Return(1);<br />xs(observer1 + observer2);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>The above will print Some(1) and None() twice, since both observers are getting it (in invocation order, coinciding with lexical order).</p><br /><br /><p>&#160;</p><br />
<h2>Return</h2><br /><br /><p>The previous sample brings us seamlessly to the next operator: Return, which realizes a singleton enumerable or observable collection. Though this one seems easy as well, it’s getting a bit more complex in the enumerable case as we need to maintain state across calls to “MoveNext”. Moreover, we need to do so on a per-enumerator basis as they all need to have their own view on the sequence. In our observable case, for the reasons mentioned above, things are slightly simpler as we can just “fire and forget” all data upon receiving a call to Subscribe. (Exercise: how would you make Subscribe asynchronous with respect to the sequence producing its values? When is this useful and when is it harmful?)</p><br /><br /><p>Let’s first look at the Return operator realization in FEnumerable:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; Return&lt;T&gt;(T value)<br />{<br />    <span style="color:blue;">return </span>() =&gt;<br />    {<br />        <span style="color:blue;">int </span>i = 0;<br />        <span style="color:blue;">return </span>() =&gt;<br />            i++ == 0<br />            ? (<span style="color:#2b91af;">Option</span>&lt;T&gt;)<span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">Some</span>(value)<br />            : (<span style="color:#2b91af;">Option</span>&lt;T&gt;)<span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">None</span>();<br />    };<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The state local to the “enumerator block” contains a counter that keeps track of the number of MoveNext calls that have been made. The first time, we return a Some(value) object, and the second (and subsequent) time(s) we answer with None. Notice this has the implicit contract of considering a None value as a <em>terminal</em> in the grammar. If you want to enforce this policy, an exception could be raised if i reaches 2.</p><br /><br /><p>In the FObservable world, things are quite easy. Upon a subscription call, we signal a Some and None message on the OnNext function, like this:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; Return&lt;T&gt;(T value)<br />{<br />    <span style="color:blue;">return </span>o =&gt;<br />    {<br />        o(<span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">Some</span>(value));<br />        o(<span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">None</span>());<br />    };<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>&#160;</p><br />
<h2><strong>Bind</strong></h2><br /><br /><p>Why says Return and knows about <a href="http://en.wikipedia.org/wiki/Monads_in_functional_programming">monads</a> immediately thinks about Bind (&gt;&gt;= in Haskell). The Bind operator, known as SelectMany in LINQ, provides an essential combinator allowing to compose objects in the monad. In our case, those monads are IEnumerable&lt;T&gt; and IObservable&lt;T&gt;. In a previous episode of my More LINQ series, I’ve explained the basic idea of monadic composition a bit further, as summarized in the figure below:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_7.png"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_thumb_7.png" width="640" height="236" /></a> </p>
</blockquote>
<br /><p>In the above, M&lt;.&gt; has to be substituted for either Func&lt;Func&lt;.&gt;&gt; or Action&lt;Action&lt;.&gt;&gt; to yield the signature for both FEnumerable’s and FObservable’s Bind operators. The implementation of the operator in the latter case is the more straightforward one of both:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;R&gt;&gt;&gt; Bind&lt;T, R&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; source, <span style="color:#2b91af;">Func</span>&lt;T, <span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;R&gt;&gt;&gt;&gt; selector)<br />{<br />    <span style="color:blue;">return </span>o =&gt; source(x =&gt;<br />    {<br />        <span style="color:blue;">if </span>(x <span style="color:blue;">is </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">None</span>)<br />        {<br />            o(<span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;R&gt;.<span style="color:#2b91af;">None</span>());<br />        }<br />        <span style="color:blue;">else<br />        </span>{<br />            selector(x.Value)(y =&gt;<br />            {<br />                <span style="color:blue;">if </span>(y <span style="color:blue;">is </span><span style="color:#2b91af;">Option</span>&lt;R&gt;.<span style="color:#2b91af;">Some</span>)<br />                    o(y);<br />            });<br />        }<br />    });<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Here, upon subscribing to an observable using observer “o”, the operator itself subscribes to the source observable that was fed in to the function. It does so by providing an observer that takes in the received element as “x”. Inside the observer’s body, which gets called for every element raised by the source, “x” is analyzed to see whether or not the source has terminated. If not, Bind does its <em>combining</em> work by calling the selector function for the received element, getting back a new observable source “f(x.Value)”. The goal of Bind is to surface the values raised on this source to the surface of the operator call. Hence, we subscribe to this computed source “f(x.Value)” by providing an observer that takes in the received value as “y” and raises that to the surface by calling “o” (the external observer). Again we assume None is terminating the sequence, which could be enforced by keeping a bit of state (left as an exercise). We’ll see examples of operator usage later on.</p><br /><br /><p>(Exercise: What if we want the Subscribe method to return immediately, running the Bind in the background. How would you do so?)</p><br /><br /><p>In the FEnumerable case, things get more complex as we need to keep track of where we are in the source and projected sequences across different calls to “MoveNext”. While we could realize this using a state machine (just like iterators would do), I’ve taken on the challenge to write a state-keeping set of loops by hand. It may well be optimized or tweaked but it seems to do its job. Important situations to keep in mind include encountering empty inner sequences (signaled by None), requiring us to loop till we eventually find an object to <em>yield</em>. It’s also important to properly return a Option&lt;R&gt;.None object when we reach the end of the outer source. One of the most essential parts of the code below is the storage of state outside the inner lambda, hence keeping per-enumerator state. Besides cursors into the outer and current inner sequences, we also keep the inner enumerator (recall the signature corresponding to IEnumerator&lt;T&gt;) in “innerE”.</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;R&gt;&gt;&gt; Bind&lt;T, R&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; source, <span style="color:#2b91af;">Func</span>&lt;T, <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;R&gt;&gt;&gt;&gt; f)<br />{<br />    <span style="color:blue;">return </span>() =&gt;<br />    {<br />        <span style="color:blue;">var </span>e = source();<br /><br />        <span style="color:#2b91af;">Option</span>&lt;T&gt; lastOuter = <span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">None</span>();<br />        <span style="color:#2b91af;">Option</span>&lt;R&gt; lastInner = <span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;R&gt;.<span style="color:#2b91af;">None</span>();<br />        <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;R&gt;&gt; innerE = <span style="color:blue;">null</span>;<br /><br />        <span style="color:blue;">return </span>() =&gt;<br />        {<br />            <span style="color:blue;">do<br />            </span>{<br />                <span style="color:blue;">while </span>(lastInner <span style="color:blue;">is </span><span style="color:#2b91af;">Option</span>&lt;R&gt;.<span style="color:#2b91af;">None</span>)<br />                {<br />                    lastOuter = e();<br /><br />                    <span style="color:blue;">if </span>(lastOuter <span style="color:blue;">is </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">None</span>)<br />                    {<br />                        <span style="color:blue;">return new </span><span style="color:#2b91af;">Option</span>&lt;R&gt;.<span style="color:#2b91af;">None</span>();<br />                    }<br />                    <span style="color:blue;">else<br />                    </span>{<br />                        innerE = f(lastOuter.Value)();<br />                    }<br /><br />                    lastInner = innerE();<br />                    <span style="color:blue;">if </span>(lastInner <span style="color:blue;">is </span><span style="color:#2b91af;">Option</span>&lt;R&gt;.<span style="color:#2b91af;">Some</span>)<br />                    {<br />                        <span style="color:blue;">return </span>lastInner;<br />                    }<br />                }<br /><br />                lastInner = innerE();<br />            } <span style="color:blue;">while </span>(lastInner <span style="color:blue;">is </span><span style="color:#2b91af;">Option</span>&lt;R&gt;.<span style="color:#2b91af;">None</span>);<br /><br />            <span style="color:blue;">return </span>lastInner;<br />        };<br />    };<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The reader is invited to make sense of the above at his or her own pace, keeping in mind the regular LINQ to Objects implementation is the following much more comprehensible code:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;R&gt; SelectMany&lt;T, R&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;T&gt; source, <span style="color:#2b91af;">Func</span>&lt;T, <span style="color:#2b91af;">IEnumerable</span>&lt;R&gt;&gt; f)<br />{<br />    <span style="color:blue;">foreach </span>(<span style="color:blue;">var </span>item <span style="color:blue;">in </span>source)<br />        <span style="color:blue;">foreach </span>(<span style="color:blue;">var </span>result <span style="color:blue;">in </span>f(item))<br />            <span style="color:blue;">yield return </span>result;<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The interesting thing about the SelectMany implementation is that the types in the signature exactly tell you what to do: the main operation on an IEnumerable is to enumerate using foreach. The only parameter you can do that on is source, but you can’t yield those elements as the output expects elements of type R and we got elements of type T. However, the function “f” accepts a T and produces an IEnumerable&lt;R&gt;, so if we call that one an enumerate the results, we got what we can yield. Simple.</p><br /><br /><p>This operator is essential to LINQ (and monads) in that it allows many other operators to be written in terms of it. Where and Select and two that pop to mind immediately, and we’ll come to those when we talk about FEnumerableEx (and FObservable) later.</p><br /><br /><p>&#160;</p><br />
<h2>Ana</h2><br /><br /><p>An anamorphism is the fancy word for an operator that produces an M&lt;T&gt; out of something outside M&lt;.&gt;, by use of unfolding. Given some seed value and an iterator function, one can produce a potentially infinite sequence of elements. Implementation of this operator is straightforward in both cases, again with the enumerable case requiring some state:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; Ana&lt;T&gt;(T seed, <span style="color:#2b91af;">Func</span>&lt;T, <span style="color:blue;">bool</span>&gt; condition, <span style="color:#2b91af;">Func</span>&lt;T, T&gt; next)<br />{<br />    <span style="color:blue;">return </span>() =&gt;<br />    {<br />        <span style="color:#2b91af;">Option</span>&lt;T&gt; value = <span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">None</span>();<br />        <span style="color:blue;">return </span>() =&gt;<br />            condition((value = <span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">Some</span>(<br />                value <span style="color:blue;">is </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">None<br />                </span>? seed<br />                : next(value.Value))).Value)<br />            ? (<span style="color:#2b91af;">Option</span>&lt;T&gt;)<span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">Some</span>(value.Value)<br />            : (<span style="color:#2b91af;">Option</span>&lt;T&gt;)<span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">None</span>();<br />    };<br />}</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>For fun and giggles I wrote this one using conditional operator expressions only, with an assignment side-effect nicely interwoven. It’s left to the reader to write it in a more imperative style. Again, we’re assuming the enumerator function is not called after a None object has been received. The basic principle of the operator is clear and implementation would look like this in regular C# with iterators:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;T&gt; Ana&lt;T&gt;(T seed, <span style="color:#2b91af;">Func</span>&lt;T, <span style="color:blue;">bool</span>&gt; condition, <span style="color:#2b91af;">Func</span>&lt;T, T&gt; next)<br />{<br />    <span style="color:blue;">for </span>(T t = seed; condition(t); t = next(t))<br />        <span style="color:blue;">yield return </span>t;<br />}</pre>
</blockquote>
<br /><p>On the FObservable side, things are simpler again (the main reason being that FEnumerable is hard because of its lazy nature and because we can’t use iterators):</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; Ana&lt;T&gt;(T seed, <span style="color:#2b91af;">Func</span>&lt;T, <span style="color:blue;">bool</span>&gt; condition, <span style="color:#2b91af;">Func</span>&lt;T, T&gt; next)<br />{<br />    <span style="color:blue;">return </span>o =&gt;<br />    {<br />        <span style="color:blue;">for </span>(T t = seed; condition(t); t = next(t))<br />            o(<span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">Some</span>(t));<br />        o(<span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">None</span>());<br />    };<br />}</pre>
</blockquote>
<br /><p>Again, the reader is invited to think about what I’d take to have this sequence getting generated on the background, as opposed to blocking the caller.</p><br /><br /><p>As an additional exercise, can you rewrite Return and Empty in terms of Ana, therefore making those two operators no longer primitives? Doing so will bring down the total of essentials to three: Ana, Cata and Bind:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_8.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_thumb_8.png" width="640" height="339" /></a> </p>
</blockquote>
<br /><p>&#160;</p><br />
<h2>Cata</h2><br /><br /><p>The opposite of an anamorphism is a catamorphism, also known as Aggregate in LINQ. Its goal is to fold a M&lt;T&gt; into something outside M&lt;.&gt;, e.g. computing the sum of a sequence of numbers. Since this is a greedy operation, we can do it on the spot for both the FEnumerable and FObservable cases as shown below:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span>R Cata&lt;T, R&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; source, R seed, <span style="color:#2b91af;">Func</span>&lt;R, T, R&gt; f)<br />{<br />    <span style="color:blue;">var </span>e = source();<br /><br />    <span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">Some </span>value;<br />    R result = seed;<br />    <span style="color:blue;">while </span>((value = e() <span style="color:blue;">as </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">Some</span>) != <span style="color:blue;">null</span>)<br />    {<br />        result = f(result, value.Value);<br />    }<br /><br />    <span style="color:blue;">return </span>result;<br />}</pre>
</blockquote>
<br /><p>First for the enumerable case, we simply run till we get a None object, continuously calling the aggregation function, starting with the seed value. In the observable case, things are equally simple:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span>R Cata&lt;T, R&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; source, R seed, <span style="color:#2b91af;">Func</span>&lt;R, T, R&gt; f)<br />{<br />    R result = seed;<br /><br />    <span style="color:blue;">bool </span>end = <span style="color:blue;">false</span>;<br />    source(x =&gt;<br />    {<br />        <span style="color:blue;">if </span>(x <span style="color:blue;">is </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">Some </span>&amp;&amp; !end)<br />            result = f(result, x.Value);<br />        <span style="color:blue;">else<br />            </span>end = <span style="color:blue;">true</span>; <span style="color:green;">// or break using exception<br />    </span>});<br /><br />    <span style="color:blue;">return </span>result;<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>This time we have to hook up an observer with the source and analyze what we got back. Notice the code above shows one approach to break out of or immunize an observer after a None message has been received. Notice though that if all constructor functions can be trusted (which is not the case with an Action of Func), such protections wouldn’t be required as we’re defining a closed world of constructors and combinators. If the former group never emits sequences that don’t follow the described protocol and the latter never combines existing sequences into an invalid one (i.e. preserving the protocol properties), it shouldn’t be possible to fall off a cliff.</p><br /><br /><p>&#160;</p><br />
<h1>Bridging the brave new world with the old-school one</h1><br /><br /><p>Before getting into more operators layered on top of the essential ones provided above, we should spend a few minutes looking at ways to convert back and forth between the new functionally inspired “flat” world and the familiar interface-centric “bombastic” world of LINQ. In particular, can we establish the following conversions?</p><br />
<ul><br />  <li>IEnumerable&lt;T&gt; to Func&lt;Func&lt;Option&lt;T&gt;&gt;&gt;</li>
<br />  <li>Func&lt;Func&lt;Option&lt;T&gt;&gt;&gt; to IEnumerable&lt;T&gt;</li>
<br />  <li>IObservable&lt;T&gt; to Action&lt;Action&lt;Option&lt;T&gt;&gt;&gt;</li>
<br />  <li>Action&lt;Action&lt;Option&lt;T&gt;&gt;&gt; to IObservable&lt;T&gt;</li>
</ul>
<br /><p>Obviously the answer is we can. Let’s focus on the first two as a starter. It’s clear that in order to go from an IEnumerable&lt;T&gt; to our new world of FEnumerable we should iterate the specified sequence. We should do so in a lazy manner such that upon every call to FEnumerable’s inner function (playing the enumerator’s role) we fetch an element out of the source IEnumerator&lt;T&gt;, but no earlier. In other words, we have to keep the iteration state which is represented by an IEnumerator&lt;T&gt; as the local state to the enumerator function:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; AsFEnumerable&lt;T&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;T&gt; source)<br />{<br />    <span style="color:blue;">return </span>() =&gt;<br />    {<br />        <span style="color:blue;">var </span>e = source.GetEnumerator();<br />        <span style="color:blue;">return </span>() =&gt; e.MoveNext()<br />            ? (<span style="color:#2b91af;">Option</span>&lt;T&gt;)<span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">Some</span>(e.Current)<br />            : (<span style="color:#2b91af;">Option</span>&lt;T&gt;)<span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">None</span>();<br />    };<br />}</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>This should be fairly straightforward code to grasp, ensuring we properly terminate a (finite) sequence with a None object to signal completion. The opposite operation is easy as well, now calling a FEnumerable’s enumerator function, providing results to the caller in a lazy fashion by means of a typical C# iterator:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;T&gt; AsEnumerable&lt;T&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; source)<br />{<br />    <span style="color:blue;">var </span>e = source();<br />    <span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">Some </span>value;<br />    <span style="color:blue;">while </span>((value = e() <span style="color:blue;">as </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">Some</span>) != <span style="color:blue;">null</span>)<br />    {<br />        <span style="color:blue;">yield return </span>value.Value;<br />    }<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>As soon as we encounter a None object, we’ll break out of the loop causing the consuming enumerator to terminate. Using the operators above, we can readily verify the back and forth conversions easily:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:green;">// IEnumerable -&gt; FEnumerable<br /></span><span style="color:blue;">var </span>xs = <span style="color:#2b91af;">Enumerable</span>.Range(0, 10).AsFEnumerable();<br />{<br />    <span style="color:blue;">var </span>xse = xs();<br />    <span style="color:#2b91af;">Option</span>&lt;<span style="color:blue;">int</span>&gt; x;<br />    <span style="color:blue;">while </span>((x = xse() <span style="color:blue;">as </span><span style="color:#2b91af;">Option</span>&lt;<span style="color:blue;">int</span>&gt;.<span style="color:#2b91af;">Some</span>) != <span style="color:blue;">null</span>)<br />        <span style="color:#2b91af;">Console</span>.WriteLine(x.Value);<br />}<br /><br /><span style="color:green;">// FEnumerable -&gt; IEnumerable<br /></span><span style="color:blue;">var </span>ys = xs.AsEnumerable();<br />{<br />    <span style="color:blue;">foreach </span>(<span style="color:blue;">var </span>y <span style="color:blue;">in </span>ys)<br />        <span style="color:#2b91af;">Console</span>.WriteLine(y);<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>This is very convenient as we’ll be able to treat arrays and other enumerable collections as FEnumerable functions in a blink of the eye. Now we can start to mix and match typical LINQ to Objects operators with our own academic playground.</p><br /><br /><p>On to the dual world, we can also provide conversions for IObservable&lt;T&gt; to FObservable&lt;T&gt; back and forth. Both are relatively easy to realize as well but lets starts with old to new:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IObservable</span>&lt;T&gt; AsObservable&lt;T&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; source)<br />{<br />    <span style="color:blue;">return </span><span style="color:#2b91af;">Observable</span>.Create&lt;T&gt;(o =&gt;<br />    {<br />        source(x =&gt;<br />        {<br />            <span style="color:blue;">if </span>(x <span style="color:blue;">is </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">Some</span>)<br />                o.OnNext(x.Value);<br />            <span style="color:blue;">else<br />                </span>o.OnCompleted();<br />        });<br />        <span style="color:blue;">return </span>() =&gt; { };<br />    });<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Here I’m using Rx’s Observable.Create operator to simplify the creation of an IObservable&lt;T&gt;, passing in an observer’s code body. Lambda parameter “o” is an IObserver&lt;T&gt;, so all we got to do is subscribe to our source (by means of just calling it, passing in a FObserver function) and forward received objects “x” to the external observer. As we don’t have a notion to run asynchronous in our little world, we simply return the no-op action delegate from the observer function. Since all execution happens synchronously upon a Subscribe call to the produced IObservable&lt;T&gt;, there’s little for us to do in a reaction to an unsubscribe invocation.</p><br /><br /><p>In the other direction, things are even simpler. We simply use an Rx extension method for IObservable&lt;T&gt; to subscribe given an OnNext and OnCompleted delegate:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; AsFObservable&lt;T&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IObservable</span>&lt;T&gt; source)<br />{<br />    <span style="color:blue;">return </span>o =&gt;<br />    {<br />        source.Subscribe(x =&gt; o(<span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">Some</span>(x)), () =&gt; o(<span style="color:blue;">new </span><span style="color:#2b91af;">Option</span>&lt;T&gt;.<span style="color:#2b91af;">None</span>()));<br />    };<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Again we can test this easily, this time using Observable.Range. Since that one runs asynchronously, we have to do a bit of synchronization to see the results printed nicely:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:green;">// IObservable -&gt; FObservable<br /></span><span style="color:blue;">var </span>evt = <span style="color:blue;">new </span><span style="color:#2b91af;">ManualResetEvent</span>(<span style="color:blue;">false</span>);<br /><span style="color:blue;">var </span>xs = <span style="color:#2b91af;">Observable</span>.Range(0, 10).AsFObservable();<br />{<br />    xs(x =&gt;<br />    {<br />        <span style="color:blue;">if </span>(x <span style="color:blue;">is </span><span style="color:#2b91af;">Option</span>&lt;<span style="color:blue;">int</span>&gt;.<span style="color:#2b91af;">Some</span>)<br />            <span style="color:#2b91af;">Console</span>.WriteLine(x.Value);<br />        <span style="color:blue;">else<br />            </span>evt.Set();<br />    });<br />}<br />evt.WaitOne();<br /><br /><span style="color:green;">// FObservable -&gt; IObservable<br /></span><span style="color:blue;">var </span>ys = xs.AsObservable();<br />{<br />    <span style="color:green;">// We got this one synchronous inside.<br />    </span>ys.Subscribe(<span style="color:#2b91af;">Console</span>.WriteLine);<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The result of all this plumbing is summarized in the following diagram. The direct conversion between a FEnumerable and FObservable (and vice versa) is left to the reader as an interesting exercise:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_9.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_thumb_9.png" width="640" height="285" /></a>&#160;</p><br /><br />  <p>&#160;</p>
</blockquote>

<h1>Where and Select for monadic dummies</h1><br /><br /><p>While we leave the implementation of operators like Snoc (Cons in reverse, to construct sequences out of a single element and a sequence) and Concat (concatenating arbitrary sequences to one another) to the reader, we should focus on a few operators that can be realized using the essential building blocks provided before. In particular, we’ll implement Where and Select in terms of Bind, Empty and Return.</p><br /><br /><p>Recall what Bind does: it combines a sequence with sequences generated from a function call, collecting the elements all sequences that result from those function calls. In a concrete sample: given a list of products and a way to get all the suppliers for each product we can return a sequence of all suppliers across all products. Or with function arrows: IE&lt;Product&gt; –&gt; (Product –&gt; IE&lt;Supplier&gt;) –&gt; IE&lt;Supplier&gt;. This is exactly the signature of Bind or SelectMany.</p><br /><br /><p>How can we use this to create a filter like Where? The answer is pretty simple, by controlling the “selector” function passed to Bind and make it analyze each element that’s passed in, deciding whether or not to return it to Bind. The “whether or not” part can be realized using a conditional either returning Return(element) or Empty(). And there we got our filtering logic:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; Where&lt;T&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; source, <span style="color:#2b91af;">Func</span>&lt;T, <span style="color:blue;">bool</span>&gt; filter)<br />{<br />    <span style="color:blue;">return </span>source.Bind(t =&gt; filter(t) ? <span style="color:#2b91af;">FEnumerable</span>.Return(t) : <span style="color:#2b91af;">FEnumerable</span>.Empty&lt;T&gt;());<br />}</pre>
</blockquote>
<br /><p>A picture is worth a thousand words, so let’s have a look at the Where operator realization in terms of Bind:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_10.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_thumb_10.png" width="640" height="343" /></a> </p>
</blockquote>
<br /><p>And guess what, the FObservable implementation can be derived by mechanical translation from the one for FEnumerable:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; Where&lt;T&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; source, <span style="color:#2b91af;">Func</span>&lt;T, <span style="color:blue;">bool</span>&gt; filter)<br />{<br />    <span style="color:blue;">return </span>source.Bind(t =&gt; filter(t) ? <span style="color:#2b91af;">FObservable</span>.Return(t) : <span style="color:#2b91af;">FObservable</span>.Empty&lt;T&gt;());<br />}</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>In fact, the code is exactly the same with FEnumerable replaced by FObservable. If we’d have typedefs for the function signatures or static extension methods on a delegate type, we’d actually see both pieces of code being the same of the following “template”:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">M</span>&lt;T&gt; Where&lt;T&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">M</span>&lt;T&gt; source, <span style="color:#2b91af;">Func</span>&lt;T, <span style="color:blue;">bool</span>&gt; filter)<br />{<br />    <span style="color:blue;">return </span>source.Bind(t =&gt; filter(t) ? <span style="color:#2b91af;">M</span>&lt;T&gt;.Return(t) : <span style="color:#2b91af;">M</span>&lt;T&gt;.Empty());<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Such an M&lt;T&gt; abstraction would be realized as a <em>type constructor</em> in Haskell and the packaging of both Return and Bind on M&lt;T&gt; would be realized by means of a <em>type class</em> that looks as follows:</p><br /><br /><blockquote><br />  <p><font face="Courier New">class Monad m where<br />      <br />&#160;&#160;&#160; return :: a –&gt; m a<br /><br />      <br />&#160;&#160;&#160; (&gt;&gt;=)&#160; :: m a –&gt; (a –&gt; m b) –&gt; m b</font></p>
</blockquote>
<br /><p>The second function is Haskell’s infix operator for bind. More information ca be found at the following locations:</p><br />
<ul><br />  <li><a title="http://www.haskell.org/haskellwiki/Monad" href="http://www.haskell.org/haskellwiki/Monad">http://www.haskell.org/haskellwiki/Monad</a></li>
<br />  <li><a title="http://www.haskell.org/tutorial/monads.html" href="http://www.haskell.org/tutorial/monads.html">http://www.haskell.org/tutorial/monads.html</a></li>
<br />  <li><a title="http://en.wikibooks.org/wiki/Haskell/Understanding_monads" href="http://en.wikibooks.org/wiki/Haskell/Understanding_monads">http://en.wikibooks.org/wiki/Haskell/Understanding_monads</a></li>
</ul>
<br /><p>How can we realize Select using Bind and Return as well? The answer is again very straightforward: this time we simply apply the projection function to the object passed to the bind selector function and wrap the result using Return. Here’s the code for both worlds, again ready to be abstracted to M&lt;T&gt;:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;R&gt;&gt;&gt; Select&lt;T, R&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; source, <span style="color:#2b91af;">Func</span>&lt;T, R&gt; selector)<br />{<br />    <span style="color:blue;">return </span>source.Bind(t =&gt; <span style="color:#2b91af;">FEnumerable</span>.Return(selector(t)));<br />}</pre><br /><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;R&gt;&gt;&gt; Select&lt;T, R&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; source, <span style="color:#2b91af;">Func</span>&lt;T, R&gt; selector)<br />{<br />    <span style="color:blue;">return </span>source.Bind(t =&gt; <span style="color:#2b91af;">FObservable</span>.Return(selector(t)));<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Again a picture will make the above more clear:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_11.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_thumb_11.png" width="506" height="349" /></a> </p>
</blockquote>
<br /><p>With those extension methods in place, we can actually start writing LINQ expressions against FEnumerable and FObservable (function!) objects. That’s right: now you got a delegate you can dot into, thanks to the magic of extension methods. But using convenient LINQ syntax, we don’t even have to see any of that:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>res = (<span style="color:blue;">from </span>x <span style="color:blue;">in </span><span style="color:#2b91af;">Enumerable</span>.Range(0, 10).AsFEnumerable()<br />           <span style="color:blue;">where </span>x % 2 == 0<br />           <span style="color:blue;">select </span>x + 1).AsEnumerable();<br /><br /><span style="color:blue;">foreach </span>(<span style="color:blue;">var </span>x <span style="color:blue;">in </span>res)<br />    <span style="color:#2b91af;">Console</span>.WriteLine(x);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Notice how we go back and forth between classic IEnumerable&lt;T&gt; and our FEnumerable implementation? But the key to see here is that our Where and Select operators are getting called. The result obviously prints 1, 3, 5, 7, 9 and to convince ourselves or calls happening to our methods, we’ll have a look in the debugger:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_12.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/TheEssenceofLINQMinLINQ_13EBD/image_thumb_12.png" width="992" height="364" /></a> </p>
</blockquote>
<br /><p>I hope this suffices to convince the reader we got query expression syntax working around our MinLINQ implementation. It’s left to the reader to decipher the exact call stack we’re observing above. The same exercise can be repeated for the FObservable case, using the following equivalent code:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>res = (<span style="color:blue;">from </span>x <span style="color:blue;">in </span><span style="color:#2b91af;">Observable</span>.Range(0, 10).AsFObservable()<br />           <span style="color:blue;">where </span>x % 2 == 0<br />           <span style="color:blue;">select </span>x + 1).AsObservable();<br /><br />res.Subscribe(<span style="color:#2b91af;">Console</span>.WriteLine);<br /><span style="color:#2b91af;">Console</span>.ReadLine(); <span style="color:green;">// Stuff happening on the background; don&#39;t exit yet</span></pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Since Bind is none other than SelectMany in disguise, we could rename it as such to enable it for use in LINQ as well, triggered by query expressions having multiple from clauses. In fact, to fully enable query expressions of that form, you’ll need a slight tweak to the SelectMany signature, as follows (same for the observable case of course):</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;R&gt;&gt;&gt; SelectMany&lt;T, C, R&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;T&gt;&gt;&gt; source, <span style="color:#2b91af;">Func</span>&lt;T, <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;C&gt;&gt;&gt;&gt; selector, <span style="color:#2b91af;">Func</span>&lt;T, C, R&gt; result)<br />{<br />    <span style="color:green;">// Left as an exercise.<br /></span>}</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>If you implement this one correctly, you will be able to run a query of the following shape:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>res = (<span style="color:blue;">from </span>x <span style="color:blue;">in </span><span style="color:#2b91af;">Enumerable</span>.Range(1, 5).AsFEnumerable()<br />           <span style="color:blue;">from </span>y <span style="color:blue;">in </span><span style="color:#2b91af;">Enumerable</span>.Range(1, x).AsFEnumerable()<br />           <span style="color:blue;">select new string</span>((<span style="color:blue;">char</span>)(<span style="color:#a31515;">&#39;a&#39; </span>+ x - 1), y)).AsEnumerable();<br /><br /><span style="color:blue;">foreach </span>(<span style="color:blue;">var </span>item <span style="color:blue;">in </span>res)<br />    <span style="color:#2b91af;">Console</span>.WriteLine(item);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>This will print the following output:</p><br /><br /><blockquote><br />  <p>a<br />    <br />b<br /><br />    <br />bb<br /><br />    <br />c<br /><br />    <br />cc<br /><br />    <br />ccc<br /><br />    <br />d<br /><br />    <br />dd<br /><br />    <br />ddd<br /><br />    <br />dddd<br /><br />    <br />e<br /><br />    <br />ee<br /><br />    <br />eee<br /><br />    <br />eeee<br /><br />    <br />eeeee</p>
</blockquote>
<br /><p>Finally, just to go nuts with some back-and-forth transitioning between all worlds (as shown in our diagram before), an all-inclusive sample mixing all sorts of execution:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>res = (<span style="color:blue;">from </span>y <span style="color:blue;">in<br />               </span>(<span style="color:blue;">from </span>x <span style="color:blue;">in </span><span style="color:#2b91af;">Enumerable</span>.Range(0, 20).AsFEnumerable()<br />                <span style="color:blue;">where </span>x % 2 == 0<br />                <span style="color:blue;">select </span>x + 1).AsEnumerable()<br />               .ToObservable() <span style="color:green;">// Rx<br />               </span>.AsFObservable()<br />           <span style="color:blue;">where </span>y % 3 == 0<br />           <span style="color:blue;">select </span>y * 2)<br />          .AsObservable()<br />          .ToEnumerable(); <span style="color:green;">// Rx<br /><br /></span><span style="color:blue;">foreach </span>(<span style="color:blue;">var </span>item <span style="color:blue;">in </span>res)<br />    <span style="color:#2b91af;">Console</span>.WriteLine(item);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The interested reader is invited to create short-circuiting operators to provide a direct path for .AsEnumerable().ToObservable().AsFObservable() and .AsObservable().ToEnumerable().AsFEnumerable(). Refer back to the diagram to see where those operators’ corresponding arrows occur.</p><br /><br /><p>&#160;</p><br />
<h1>Fueling Range and Sum with Ana and Cata</h1><br /><br /><p>To conclude this post, let’s also have a look at how to derive constructor and aggregator operators from our Ana and Cata primitives. As a sequence constructor we’ll consider Range and for the aggregator we’ll consider Sum. Let’s start with Range in terms if Ana:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;<span style="color:blue;">int</span>&gt;&gt;&gt; Range(<span style="color:blue;">int </span>from, <span style="color:blue;">int </span>length)<br />{<br />    <span style="color:blue;">return </span><span style="color:#2b91af;">FEnumerable</span>.Ana&lt;<span style="color:blue;">int</span>&gt;(from, x =&gt; x &lt; from + length, x =&gt; x + 1);<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>and (again exactly the same code thanks to the shared primitives)</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;<span style="color:blue;">int</span>&gt;&gt;&gt; Range(<span style="color:blue;">int </span>from, <span style="color:blue;">int </span>length)<br />{<br />    <span style="color:blue;">return </span><span style="color:#2b91af;">FObservable</span>.Ana&lt;<span style="color:blue;">int</span>&gt;(from, x =&gt; x &lt; from + length, x =&gt; x + 1);<br />}</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>Now we can get rid of the AsFEnumerable() use in our samples when creating a range and construct our range sequence immediately in our world (similar example for FObservable of course):</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>res = (<span style="color:blue;">from </span>x <span style="color:blue;">in </span><span style="color:#2b91af;">FEnumerableEx</span>.Range(0, 10)<br />           <span style="color:blue;">where </span>x % 2 == 0<br />           <span style="color:blue;">select </span>x + 1).AsEnumerable();<br /><br /><span style="color:blue;">foreach </span>(<span style="color:blue;">var </span>x <span style="color:blue;">in </span>res)<br />    <span style="color:#2b91af;">Console</span>.WriteLine(x);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>As an exercise, also abstract the AsEnumerable call followed by foreach into a <a href="http://blogs.bartdesmet.net/blogs/bart/archive/2009/12/26/more-linq-with-system-interactive-the-ultimate-imperative.aspx">Run method</a>, as seen in System.Interactive, so that you can write the code below. Implement this operator in terms of Cata (!):</p><br /><br /><blockquote><br />  <pre class="code">(<span style="color:blue;">from </span>x <span style="color:blue;">in </span><span style="color:#2b91af;">FEnumerableEx</span>.Range(0, 10)<br /> <span style="color:blue;">where </span>x % 2 == 0<br /> <span style="color:blue;">select </span>x + 1).Run(<br />     <span style="color:#2b91af;">Console</span>.WriteLine<br />);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>(Question: could you benefit from such an operator in FObservable as well?)</p><br /><br /><p>For the Sum realization we can use Cata:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static int </span>Sum(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;<span style="color:blue;">int</span>&gt;&gt;&gt; source)<br />{<br />    <span style="color:blue;">return </span>source.Cata(0, (sum, x) =&gt; sum + x);<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>and</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static int </span>Sum(<span style="color:blue;">this </span><span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Action</span>&lt;<span style="color:#2b91af;">Option</span>&lt;<span style="color:blue;">int</span>&gt;&gt;&gt; source)<br />{<br />    <span style="color:blue;">return </span>source.Cata(0, (sum, x) =&gt; sum + x);<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The following example illustrates how to sum 1 to 10 using Range and Sum:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#2b91af;">FEnumerableEx</span>.Range(1, 10).Sum());<br /><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#2b91af;">FObservableEx</span>.Range(1, 10).Sum());</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>Both print 55 just fine.</p><br /><br /><p>Implement more aggregation operators as found in the Standard Query Operators. Also think about how to implement those over nullable value types (e.g. Sum with int?). Could you reuse Option&lt;T&gt; as an alternative to nullables? Could you reuse monadic computation to carry out nullable arithmetic (tip: the <a href="http://www.haskell.org/all_about_monads/html/maybemonad.html">Maybe monad</a>)? A few aggregates that some people don’t see as aggregates include All, Any, First, Last, ElementAt, and more. Don’t forget to implement those either (most of them should be a one-liner making a single call to Cata). As an additional caveat, the following implementation of Average is inadequate (why?):</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static double </span>Average(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Option</span>&lt;<span style="color:blue;">int</span>&gt;&gt;&gt; source)<br />{<br />    <span style="color:blue;">return </span>(<span style="color:blue;">double</span>)source.Sum() / source.Count();<br />}</pre>
</blockquote>
<br /><p>&#160;</p><br />
<h1>Conclusion</h1><br /><br /><p>Boiling down LINQ to its core essence can be fun and a great eye-opener to many users of the technology. While optimizations often mandate a lower degree of layering, it’s good to have an idea of the conceptual layering of various operators to see which ones are essential and which ones are not so much. If kids can build castles out of Lego blocks, sure every self-respecting developer should be able to exploit the expressive power a few primitive building blocks to create great libraries and applications. Choosing the right set of primitives can get you a long way in such a design, as illustrated in this post. Readers who can’t get enough of essential primitives and the composition thereof are cordially invited to have a go at another <a href="http://blogs.bartdesmet.net/blogs/bart/archive/tags/Crazy+Sundays/default.aspx">Crazy Sunday</a> post titled <a href="http://blogs.bartdesmet.net/blogs/bart/archive/2009/04/27/unlambda-net-with-a-big-dose-of-c-3-0-lambdas.aspx">Unlambda .NET – With a Big Dose of C# 3.0 Lambdas</a> (and many others in that category).</p><br /><br /><p>In the continuation of my <a href="http://blogs.bartdesmet.net/blogs/bart/archive/tags/Rx/default.aspx">“More LINQ with System.Interactive” series</a> we’ll get back to less academic stuff with System.Interactive. And before I forget: a happy 2010!</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=14981" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/12/30/more-linq-with-system-interactive-more-combinators-for-your-swiss-army-knife.aspx">More LINQ with System.Interactive – More combinators for your Swiss Army Knife</a></div><div class="moreinfo"><span class="date">Wednesday, December 30, 2009</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><p>With the recent release of the <a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx">Reactive Extensions for .NET (Rx)</a> on <a href="http://msdn.microsoft.com/en-us/devlabs/default.aspx">DevLabs</a>, you’ll hear quite a bit about reactive programming, based on the IObservable&lt;T&gt; and IObserver&lt;T&gt; interfaces. A great amount of resources is available <a href="http://channel9.msdn.com/tags/Rx/">on Channel 9</a>. In this series, I’ll focus on the <a href="http://channel9.msdn.com/shows/Going+Deep/Expert-to-Expert-Brian-Beckman-and-Erik-Meijer-Inside-the-NET-Reactive-Framework-Rx/">dual</a> of the System.Reactive assembly, which is System.Interactive, providing a bunch of extensions to the <a href="http://www.codeplex.com/LINQSQO">LINQ Standard Query Operators</a> for IEnumerable&lt;T&gt;. In today’s installment we’ll talk about new combinator operators provided by EnumerableEx:</p>  <p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveMorecombinatorsforyourSwi_1178/image.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveMorecombinatorsforyourSwi_1178/image_thumb.png" width="526" height="480" /></a> </p>  <p>&#160;</p>  <h1>Combine and conquer?</h1>  <p>Combinators are at the heart of LINQ’s expressive power, allowing sequences to be combined into new ones. In earlier posts, I’ve shown the essence of monadic computation through the following illustration:</p>  <blockquote>   <p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveMorecombinatorsforyourSwi_1178/image_3.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveMorecombinatorsforyourSwi_1178/image_thumb_3.png" width="640" height="236" /></a> </p> </blockquote>  <p>It’s fair to say that SelectMany (or Bind) is the mother of all combinators, as many others can be derived from it (Exercise: implement Where and Select using SelectMany and a limited number of auxiliary operators like Return). In today’s post we’ll look at various new combinators added to the IEnumerable&lt;T&gt; set of operators.</p>  <p>So, what’s a combinator? In one world view (the one we’re using), it’s an operator that combines one or more instances of a given entity into a new such entity. For example, in functional programming we got S, K and I combinators that act on functions:</p>  <blockquote>   <p>S x y z = (x z) y z     <br />K x y = x      <br />I x = x</p> </blockquote>  <p>A more precise definition can be found on <a title="http://en.wikipedia.org/wiki/Combinator" href="http://en.wikipedia.org/wiki/Combinator">http://en.wikipedia.org/wiki/Combinator</a>, for those interested in more foundational stuff. In our case, we’ll combine one or more IEnumerable&lt;T&gt; instances into a new IEnumerable&lt;R&gt; (where R <em>can</em> be different from T).</p>  <p>&#160;</p>  <h1>Concat, now with more arguments</h1>  <p>LINQ to Objects has always had a Concat operator, with the following signature:</p>  <blockquote>   <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Concat&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; first, <span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; second);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>However, this is merely a special case of a more general version of Concat, introduced in EnumerableEx:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Concat&lt;TSource&gt;(<span style="color:blue;">params </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt;[] sources);<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Concat&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt;&gt; sources);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The second one is the core operator we’re talking about here, with the first overload providing convenience due to the lack of a “params enumerable” feature in the language. The Concat operator is simple to understand, simply yielding all TSource objects from all sequences in the sources parameter. If an error occurs during enumeration any of the sequences, the resulting concatenated sequence is also terminated for yielding. In fact, this operator is very similar to OnErrorResumeNext where the error condition is ignored.</p><br /><br /><p>Below is a sample illustrating the main scenarios:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">new</span>[] {<br />    <span style="color:blue;">new</span>[] { 1, 2 },<br />    <span style="color:blue;">new</span>[] { 3, 4 },<br />    <span style="color:blue;">new</span>[] { 5, 6 }<br />}<br />.Concat()<br />.Materialize(<span style="color:green;">/* for pretty printing */</span>)<br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);<br /><br /><span style="color:blue;">new</span>[] {<br />    <span style="color:blue;">new</span>[] { 1, 2 },<br />    <span style="color:blue;">new</span>[] { 3, 4 }.Concat(<span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">Exception</span>())),<br />    <span style="color:blue;">new</span>[] { 5, 6 }<br />}<br />.Concat()<br />.Materialize(<span style="color:green;">/* for pretty printing */</span>)<br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>The first sample will print numbers 1 through 6, while the second one will print 1 through 4 and an error notification.</p><br /><br /><p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveMorecombinatorsforyourSwi_1178/image_4.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveMorecombinatorsforyourSwi_1178/image_thumb_4.png" width="500" height="380" /></a> </p><br /><br /><p>&#160;</p><br /><br /><p></p><br />
<h1>Merge, a parallel Concat</h1><br /><br /><p>Where Concat will proceed through the sources collection sequentially, guaranteeing in-order retrieval of data, one could get all the data from the sources in a parallel manner as well. To do so, Merge spawns workers that drain all of the sources in parallel, flattening or “sinking” all the results to the caller:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Merge&lt;TSource&gt;(<span style="color:blue;">params </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt;[] sources);<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Merge&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt;&gt; sources);<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Merge&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; leftSource, <span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; rightSource);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The three overloads share the same signatures as the Concat equivalents, with the second one being the most general overload again. The same sample as for Concat can be used to illustrate the working:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">new</span>[] {<br />    <span style="color:blue;">new</span>[] { 1, 2 },<br />    <span style="color:blue;">new</span>[] { 3, 4 },<br />    <span style="color:blue;">new</span>[] { 5, 6 }<br />}<br />.Merge()<br />.Materialize(<span style="color:green;">/* for pretty printing */</span>)<br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);<br /><br /><span style="color:blue;">new</span>[] {<br />    <span style="color:blue;">new</span>[] { 1, 2 },<br />    <span style="color:blue;">new</span>[] { 3, 4 }.Concat(<span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">Exception</span>())),<br />    <span style="color:blue;">new</span>[] { 5, 6 }<br />}<br />.Merge()<br />.Materialize(<span style="color:green;">/* for pretty printing */</span>)<br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>What the results are will depend on the mood of your task scheduler. Either way, for the first sample you should get to see all of the numbers from 1 through 6 getting printed, in any order (though 1 will come before 2, 3 before 4 and 5 before 6). On my machine I got 1, 3, 5, 4, 2, 6 in my first run. For the second sample, it’s entirely possible to see 5 and 6 getting printed before the exception for the second source is reached. But then that’s what you expect from parallel computation, don’t you?</p><br /><br /><p>Merge can speed up your data retrieval operations significantly, if you don’t care about the order in which results are returned. For example, you could cause two LINQ to SQL queries that provide stock quotes to run in parallel by using Merge, followed by a client-side duplicate entry elimination technique:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>stocks =<br />    <span style="color:blue;">from </span>quote <span style="color:blue;">in<br />        </span><span style="color:#2b91af;">EnumerableEx</span>.Merge(<br />            (<span style="color:blue;">from </span>quote <span style="color:blue;">in </span>t1 <span style="color:blue;">select </span>quote).Do(q =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;t1: &quot; </span>+ q)),<br />            (<span style="color:blue;">from </span>quote <span style="color:blue;">in </span>t2 <span style="color:blue;">select </span>quote).Do(q =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;t2: &quot; </span>+ q))<br />        )<br />    <span style="color:blue;">group </span>quote <span style="color:blue;">by </span>quote.Symbol <span style="color:blue;">into </span>g<br />    <span style="color:blue;">select new </span>{ g.Key, Price = g.Average(p =&gt; p.Price) };<br /><br />stocks.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Results could look as follows, with the main idea being the parallel retrieval of both query results:</p><br /><br /><blockquote><br />  <p>Query: SELECT Symbol, Price FROM Trader1<br />    <br />Query: SELECT Symbol, Price FROM Trader2<br /><br />    <br />t2: { Symbol = MSFT, Price = 30.94 }<br /><br />    <br />t1: { Symbol = MSFT, Price = 30.99 }<br /><br />    <br />t1: { Symbol = ORCL, Price = 24.92 }<br /><br />    <br />t1: { Symbol = GOOG, Price = 618.35 }<br /><br />    <br />t1: { Symbol = AAPL, Price = 209.10 }<br /><br />    <br />t2: { Symbol = ORCL, Price = 25.06 }<br /><br />    <br />t2: { Symbol = GOOG, Price = 610.25 }<br /><br />    <br />t2: { Symbol = AAPL, Price = 204.99 }<br /><br />    <br />{ Key = MSFT, Price = 30.965 }<br /><br />    <br />{ Key = ORCL, Price = 24.99 }<br /><br />    <br />{ Key = GOOG, Price = 614.30 }<br /><br />    <br />{ Key = AAPL, Price = 207.045 }</p>
</blockquote>
<br /><p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveMorecombinatorsforyourSwi_1178/image_5.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveMorecombinatorsforyourSwi_1178/image_thumb_5.png" width="500" height="380" /></a> </p><br /><br /><p>(Note: behavior in face of an exception will depend on timing and is not included in the diagram.)</p><br /><br /><p>&#160;</p><br />
<h1>Amb, a racing game</h1><br /><br /><p>Amb is the <em>ambiguous</em> operator as <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.55.8479">introduced by McCarthy in 1963</a>. Because of its nostalgic background, it’s been chosen to preserve the name as-is instead of expanding it. What’s so ambiguous about this operator? Well, the idea is that Amb allows two sequences to race to provide the first result causing the winning sequence to be elected as the one providing the resulting sequence from the operator call. The operator’s signatures make this clear:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Amb&lt;TSource&gt;(<span style="color:blue;">params </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt;[] sources);<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Amb&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt;&gt; sources);<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Amb&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; leftSource, <span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; rightSource);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Again, the overloads are threesome, just like Concat and Merge. To provide a sample of the operator’s behavior, use the following simple implementation of a Delay operator:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Delay&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color:blue;">int </span>delay)<br />{<br />    <span style="color:blue;">return </span><span style="color:#2b91af;">EnumerableEx</span>.Defer(() =&gt; { <span style="color:#2b91af;">Thread</span>.Sleep(delay); <span style="color:blue;">return </span>source; });<br />}</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>Now we can write the following two test cases:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>src1 = <span style="color:blue;">new</span>[] { 1, 2 }.Delay(300);<br /><span style="color:blue;">var </span>src2 = <span style="color:blue;">new</span>[] { 3, 4 }.Delay(400);<br />src1.Amb(src2).Run(<span style="color:#2b91af;">Console</span>.WriteLine);<br /><br /><span style="color:blue;">var </span>src3 = <span style="color:blue;">new</span>[] { 5, 6 }.Delay(400);<br /><span style="color:blue;">var </span>src4 = <span style="color:blue;">new</span>[] { 7, 8 }.Delay(300);<br />src3.Amb(src4).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>The expected result will be that src1 and src4 win their Amb battles against src2 and src3, respectively. One practical use for this operator is to have two or more redundant data sources, all containing the same data, fight to provide the quickest answer to a query. Here’s a sample illustrating this:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>stocks =<br /><span style="color:#2b91af;">    EnumerableEx</span>.Amb(<br />        (<span style="color:blue;">from </span>quote <span style="color:blue;">in </span>t1 <span style="color:blue;">select </span>quote).Do(q =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;t1: &quot; </span>+ q)),<br />        (<span style="color:blue;">from </span>quote <span style="color:blue;">in </span>t2 <span style="color:blue;">select </span>quote).Do(q =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;t2: &quot; </span>+ q))<br />    );<br /><br />stocks.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Results could look as follows, assuming t2 was the quickest to provide an answer:</p><br /><br /><blockquote><br />  <p>Query: SELECT Symbol, Price FROM Trader1<br />    <br />Query: SELECT Symbol, Price FROM Trader2<br /><br />    <br />t2: { Symbol = MSFT, Price = 30.94 }<br /><br />    <br />t2: { Symbol = ORCL, Price = 25.06 }<br /><br />    <br />t2: { Symbol = GOOG, Price = 610.25 }<br /><br />    <br />t2: { Symbol = AAPL, Price = 204.99 }<br /><br />    <br />{ Key = MSFT, Price = 30.94 }<br /><br />    <br />{ Key = ORCL, Price = 25.06 }<br /><br />    <br />{ Key = GOOG, Price = 610.25 }<br /><br />    <br />{ Key = AAPL, Price = 204.99 }</p>
</blockquote>
<br /><p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveMorecombinatorsforyourSwi_1178/image_6.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveMorecombinatorsforyourSwi_1178/image_thumb_6.png" width="500" height="380" /></a> </p><br /><br /><p></p><br /><br /><p></p><br /><br /><p>&#160;</p><br />
<h1>Repeat, again and (maybe) again</h1><br /><br /><p>The purpose of Repeat is self-explanatory and could be seen as a constructor function as well. Two categories of overloads exists: one that takes a single element and an optional repeat count (unspecified = infinite) and another that takes a sequence and an optional repeat count. While the former is more of a constructor, the latter is more of a combinator over a single input sequence:</p><br /><br /><pre class="code"><span style="color:green;">        </span><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Repeat&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source);<br /><span style="color:green;">        </span><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Repeat&lt;TSource&gt;(TSource value);<br /><span style="color:green;">        </span><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Repeat&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color:blue;">int </span>repeatCount);<br /><span style="color:green;">        </span><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Repeat&lt;TSource&gt;(TSource value, <span style="color:blue;">int </span>repeatCount);</pre><br /><a href="http://11011.net/software/vspaste"></a><br /><br /><p>Samples don’t need much further explanation either:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">EnumerableEx</span>.Repeat(1).Take(5).Run(<span style="color:#2b91af;">Console</span>.WriteLine);<br /><span style="color:#2b91af;">EnumerableEx</span>.Repeat(2, 5).Run(<span style="color:#2b91af;">Console</span>.WriteLine);<br /><br /><span style="color:blue;">new</span>[] { 3, 4 }.Repeat().Take(4).Run(<span style="color:#2b91af;">Console</span>.WriteLine);<br /><span style="color:blue;">new</span>[] { 5, 6 }.Repeat(2).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p>It goes almost without saying that an input sequence causing an exception will also terminate the enumeration of a repeated form of the same sequence:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">new</span>[] { 5, 6 }.Concat(<span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">Exception</span>())).Repeat(2).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveMorecombinatorsforyourSwi_1178/image_7.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveMorecombinatorsforyourSwi_1178/image_thumb_7.png" width="500" height="380" /></a> </p><br /><br /><p>&#160;</p><br />
<h1>Zip ‘em together</h1><br /><br /><p>Introduced in .NET 4.0, I’ve covered the new Zip operator already in my earlier post on <a href="http://community.bartdesmet.net/blogs/bart/archive/2008/11/03/c-4-0-feature-focus-part-3-intermezzo-linq-s-new-zip-operator.aspx">C# 4.0 Feature Focus - Part 3 - Intermezzo: LINQ&#39;s new Zip operator</a>. Rx ports back this operator to the .NET 3.5 System.Interactive library for consistency. In summary, Zip walks two sequences hand-in-hand, combing their respective yielded elements using a given function to produce a result. The signature is as follows:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TFirst&gt; first, <span style="color:#2b91af;">IEnumerable</span>&lt;TSecond&gt; second, <span style="color:#2b91af;">Func</span>&lt;TFirst, TSecond, TResult&gt; resultSelector);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>A simple example is shown below:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Enumerable</span>.Range(1, 26).Zip(<br />    <span style="color:#a31515;">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>,<br />    (i, c) =&gt; <span style="color:#a31515;">&quot;alpha[&quot; </span>+ i + <span style="color:#a31515;">&quot;] = &quot; </span>+ c<br />).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>In here, the first sequence is an IEnumerable&lt;int&gt; and the second one is a string, hence an IEnumerable&lt;char&gt;. The result is a table of mappings between numbers and letters. As an exercise, implement the following overload of Select using Zip and Generate, in terms of the more commonly used overload of Select that doesn’t take a position in the selector function:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt; Select&lt;TSource, TResult&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color:#2b91af;">Func</span>&lt;TSource, <span style="color:blue;">int</span>, TResult&gt; selector);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>One thing that’s interesting about the interactive version of Zip is its left-to-right characteristic with regards to enumeration of first and second. Internally, it does something along the following lines:</p><br /><br /><blockquote><br />  <p><font face="Courier New"><font color="#0000ff">while</font> (first.MoveNext() &amp;&amp; second.MoveNext())<br /><br />      <br />&#160;&#160;&#160; …</font></p>
</blockquote>
<br /><p>In other words, “first” is dominant in that it can prevent a MoveNext call on second from happening, e.g. because of an exception getting thrown, non-termination (stuck forever) and termination (returning false). The following matrix shows the implications of this:</p><br /><br /><p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveMorecombinatorsforyourSwi_1178/image_8.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveMorecombinatorsforyourSwi_1178/image_thumb_8.png" width="500" height="380" /></a> </p><br /><br /><p>It’s left as an exercise to the reader to implement the right-hand side behavior (notice the transposition symmetry!) for fun, where a Zip could fetch results from both sources simultaneously, combining their results or exceptions into produced results. What are advantages and disadvantages of such an approach? As an additional question, think about ways to detect and report an asymmetric zip, where one of both sides still has an element while the other side has signaled termination.</p><br /><br /><p>Finally, the diagram illustrating some of the regular operations of Zip. Other combinations of behavior can be read from the matrix above.</p><br /><br /><p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveMorecombinatorsforyourSwi_1178/image_9.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveMorecombinatorsforyourSwi_1178/image_thumb_9.png" width="500" height="380" /></a> </p><br /><br /><p>&#160;</p><br />
<h1>Scan, a running aggregation operator</h1><br /><br /><p>Readers familiar with the LINQ to Objects APIs will know about the Aggregate operator, which we also mentioned before when talking about the new Generate operator (as the opposite of Aggregate). Aggregate “folds” or reduces a sequence of elements into a single value, eating the elements one by one using some specified function. However, sometimes you may not want to loose the intermediate results, e.g. if you want to compute a running sum or so. Scan allows you to do so:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Scan&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color:#2b91af;">Func</span>&lt;TSource, TSource, TSource&gt; accumulator);<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TAccumulate&gt; Scan&lt;TSource, TAccumulate&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source, TAccumulate seed, <span style="color:#2b91af;">Func</span>&lt;TAccumulate, TSource, TAccumulate&gt; accumulator);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>You’ll see big similarities with the existing Aggregate operator when looking at the signatures above, and use of the operator is straightforward as well:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Enumerable</span>.Range(1, 10)<br />.Scan((sum, i) =&gt; sum + i)<br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);<br /><br /><span style="color:#2b91af;">Enumerable</span>.Range(2, 9).Reverse()<br />.Scan(3628800, (prod, i) =&gt; prod / i)<br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The first sample will simply print 1, 1+2 = 3, 3+3 = 6, 6+4 = 10, … In the second sample, a seed value is used to illustrate an inverse factorial computation, dividing a given value by subsequent descending values (from 10 to 2).</p><br /><br /><p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveMorecombinatorsforyourSwi_1178/image_10.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveMorecombinatorsforyourSwi_1178/image_thumb_10.png" width="500" height="380" /></a> </p><br /><br /><p>&#160;</p><br />
<h1>SelectMany</h1><br /><br /><p></p><br /><br /><p></p><br /><br /><p></p><br /><br /><p></p><br /><br /><p>Finally, as a honor to the monadic bind operator, a new overload was added for SelectMany :-). Its signature is shown below, and it’s left to the reader to figure out what it does (simple):</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TOther&gt; SelectMany&lt;TSource, TOther&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color:#2b91af;">IEnumerable</span>&lt;TOther&gt; other);</pre>
</blockquote>
<br /><p>&#160;</p><br />
<h1>Next on More LINQ</h1><br /><br /><p>Functionally inspired constructs allowing to share enumerables and tame their side-effects.</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=14945" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/12/29/more-linq-with-system-interactive-exploiting-the-code-data-relationship.aspx">More LINQ with System.Interactive – Exploiting the code = data relationship</a></div><div class="moreinfo"><span class="date">Tuesday, December 29, 2009</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><p>With the recent release of the <a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx">Reactive Extensions for .NET (Rx)</a> on <a href="http://msdn.microsoft.com/en-us/devlabs/default.aspx">DevLabs</a>, you’ll hear quite a bit about reactive programming, based on the IObservable&lt;T&gt; and IObserver&lt;T&gt; interfaces. A great amount of resources is available <a href="http://channel9.msdn.com/tags/Rx/">on Channel 9</a>. In this series, I’ll focus on the <a href="http://channel9.msdn.com/shows/Going+Deep/Expert-to-Expert-Brian-Beckman-and-Erik-Meijer-Inside-the-NET-Reactive-Framework-Rx/">dual</a> of the System.Reactive assembly, which is System.Interactive, providing a bunch of extensions to the <a href="http://www.codeplex.com/LINQSQO">LINQ Standard Query Operators</a> for IEnumerable&lt;T&gt;. In today’s installment we’ll talk about the materialization and dematerialization operators provided by EnumerableEx:</p>  <p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveExploitingthecodedatarela_13ACD/image.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveExploitingthecodedatarela_13ACD/image_thumb.png" width="526" height="480" /></a> </p>  <p>&#160;</p>  <h1>von Neumann was right</h1>  <p>Code and data are very similar animals, much more similar than you may expect them to be. We can approach this observation from two different angles, one being a machine-centric view. Today’s computers are realizations of von Neumann machines where instructions and data are treated on the same footage from a memory storage point of view. While this is very useful, it’s also the source of various security-related headaches such as script or SQL injection and data execution through e.g. stack overruns (Data Execution Prevention is one mitigation).</p>  <p>Another point of view goes back to the foundational nature of programming, in particular the essentials of functional programming, where functions are used to represent data. An example are <a href="http://community.bartdesmet.net/blogs/bart/archive/2009/08/17/mis-using-c-4-0-dynamic-type-free-lambda-calculus-church-numerals-and-more.aspx">Church numerals</a>, which are functions that are behaviorally equivalent to natural numbers (realized by repeated application of a function, equal in number to the natural number being represented). This illustrates how something that seems exclusively code-driven can be used to represent or mimic data.</p>  <p>If the above samples seem far-fetched or esoteric, there are a variety of more familiar grounds where the “code as data” paradigm is used or exploited. One such sample is LISP where code and data representation share the same syntactical form and where the technique of quotation can be used to represent a code snippet as data for runtime inspection and/or manipulation. This is nothing other than meta-programming in its earliest form. Today we find exactly the same principle back in C#, and other languages, through expression trees. The core property here is so-called <em>homo-iconicity</em>, where code can be represented as data without having to resort to a different syntax (homo = same; iconic = appearance):</p>  <blockquote>   <p><font face="Courier New">Func&lt;int, int&gt; twiceD = x =&gt; x * 2;       <br />Expression&lt;Func&lt;int, int&gt;&gt; twiceE = x =&gt; x * 2;</font></p> </blockquote>  <p>What what does all of this have to do with enumerable sequences? Spot on! The matter is that sequences seem to be a very data-intensive concept, and sure they are. However, the behavior and realization of such sequences, e.g. through iterators, can be very code-intensive as well, to such an extent that we introduced means to deal with exceptions (Catch for instance) and termination (Repeat, restarting after completing). This reveals that it’s useful to deal with all possible <em>states</em> a sequence can go through. Guess what, state is data.</p>  <p>&#160;</p>  <h1>The holy trinity of IEnumerator&lt;T&gt; and IObserver&lt;T&gt; states</h1>  <p>In all the marble diagrams I’ve shown before, there was a legend consisting of three potential states an enumerable sequence can go through as a result of iteration. Those three states reflect possible responses to a call to MoveNext caused by the consumer of the sequence:</p>  <blockquote>   <p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveExploitingthecodedatarela_13ACD/image_3.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveExploitingthecodedatarela_13ACD/image_thumb_3.png" width="240" height="151" /></a> </p> </blockquote>  <p>In the world of IObserver&lt;T&gt;, the dual to IEnumerator&lt;T&gt; as we saw in earlier episodes, those three states are reflected in the interface definition directly, with three methods:</p>  <blockquote>   <pre class="code"><span style="color:green;">// Summary:<br />//     Supports push-style iteration over an observable sequence.<br /></span><span style="color:blue;">public interface </span><span style="color:#2b91af;">IObserver</span>&lt;T&gt;<br />{<br />    <span style="color:green;">// Summary:<br />    //     Notifies the observer of the end of the sequence.<br />    </span><span style="color:blue;">void </span>OnCompleted();<br />    <span style="color:green;">//<br />    // Summary:<br />    //     Notifies the observer that an exception has occurred.<br />    </span><span style="color:blue;">void </span>OnError(<span style="color:#2b91af;">Exception </span>exception);<br />    <span style="color:green;">//<br />    // Summary:<br />    //     Notifies the observer of a new value in the sequence.<br />    </span><span style="color:blue;">void </span>OnNext(T value);<br />}</pre>
</blockquote>
<br /><p>Instead of having an observer getting called on any of those three methods, we could equally well <em>record</em> the states “raised” by the observable, which turns calls (code) into object instances (data) of type Notification&lt;T&gt;. This operation is called <em>materialization</em>. Thanks to dualization, the use of Notification&lt;T&gt; can be extended to the world of enumerables as well.</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveExploitingthecodedatarela_13ACD/image_4.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveExploitingthecodedatarela_13ACD/image_thumb_4.png" width="235" height="501" /></a> </p>
</blockquote>
<br /><p>Notification&lt;T&gt; is a discriminated union with three notification kinds, reflecting the three states we talked about earlier:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public enum </span><span style="color:#2b91af;">NotificationKind<br /></span>{<br />    OnNext = 0,<br />    OnError = 1,<br />    OnCompleted = 2,<br />}</pre>
</blockquote>
<br /><p>&#160;</p><br />
<h1>It’s a material dual world</h1><br /><br /><p>Materialization is the act of taking a plain enumerable and turning it into a data-centric view based on Notification&lt;T&gt;. Dematerialization reverses this operation, going back to the code-centric world. Thanks to this back-and-forth ability between the two worlds of code and data, we get the ability to use LINQ over notification sequences and put the result back into the regular familiar IEnumerable&lt;T&gt; world. A figure makes this clear:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveExploitingthecodedatarela_13ACD/image_5.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveExploitingthecodedatarela_13ACD/image_thumb_5.png" width="640" height="446" /></a> </p>
</blockquote>
<br /><p>The power of this lies in the ability to use whatever domain is more convenient to perform operations over a sequence. Maybe you want to do thorough analysis of error conditions, corresponding to the Error notification kind, or maybe it’s more convenient to create a stream of notification objects before turning them into a “regular” sequence of objects that could exhibit certain additional behavior (like error conditions). This is exactly the same as the tricks played in various other fields, like mathematics where one can do <a href="http://en.wikibooks.org/wiki/Signals_and_Systems">Fourier analysis</a> either in the time of frequency domain. Sometimes one is more convenient than the other; all that counts is to know there are reliable ways to go back and forth.</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveExploitingthecodedatarela_13ACD/image_6.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveExploitingthecodedatarela_13ACD/image_thumb_6.png" width="654" height="500" /></a> </p><br /><br />  <p>(Note: For the Queryable sample, you may want to end up in the bottom-right corner, so the AsQueryable call is often omitted.)</p>
</blockquote>
<br /><p>&#160;</p><br />
<h1>Materialize and Dematerialize</h1><br /><br /><p>What remains to be said in this post are the signatures of the operators and a few samples. First, the signatures:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">Notification</span>&lt;TSource&gt;&gt; Materialize&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source);<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Dematerialize&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">Notification</span>&lt;TSource&gt;&gt; source);</pre>
</blockquote>
<br /><p>An example of materialization is shown below, where we take a simple range generator to materialize. We expect to see OnNext notifications for all the numeric values emitted, terminated by a single OnCompleted call:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Enumerable</span>.Range(1, 10)<br />.Materialize()<br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>This prints:</p><br /><br /><blockquote><br />  <p>OnNext(1)<br />    <br />OnNext(2)<br /><br />    <br />OnNext(3)<br /><br />    <br />OnNext(4)<br /><br />    <br />OnNext(5)<br /><br />    <br />OnNext(6)<br /><br />    <br />OnNext(7)<br /><br />    <br />OnNext(8)<br /><br />    <br />OnNext(9)<br /><br />    <br />OnNext(10)<br /><br />    <br />OnCompleted()</p>
</blockquote>
<br /><p>A sample where an exception is triggered by the enumerator is shown below. Notice the code won’t blow up when enumerating over the materialized sequence: the exception is materialized as a passive exception object instance in an error notification.</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Enumerable</span>.Range(1, 10).Concat(<span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">Exception</span>()))<br />.Materialize()<br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The result is as follows:</p><br /><br /><blockquote><br />  <p>OnNext(1)<br />    <br />OnNext(2)<br /><br />    <br />OnNext(3)<br /><br />    <br />OnNext(4)<br /><br />    <br />OnNext(5)<br /><br />    <br />OnNext(6)<br /><br />    <br />OnNext(7)<br /><br />    <br />OnNext(8)<br /><br />    <br />OnNext(9)<br /><br />    <br />OnNext(10)<br /><br />    <br />OnError(System.Exception)</p>
</blockquote>
<br /><p>Starting from a plain IEnumerable&lt;T&gt; the grammar of notifications to be expected is as follows:</p><br /><br /><blockquote><br />  <p>OnNext* ( OnCompleted | OnError )?</p>
</blockquote>
<br /><p>In the other direction, starting from the world of IEnumerable&lt;Notification&lt;T&gt;&gt; one can write a different richer set of sequence defined by the following grammar:</p><br /><br /><blockquote><br />  <p>( OnNext | OnCompleted | OnError )*</p>
</blockquote>
<br /><p>For example:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>ns = <span style="color:blue;">new </span><span style="color:#2b91af;">Notification</span>&lt;<span style="color:blue;">int</span>&gt;[] {<br />    <span style="color:blue;">new </span><span style="color:#2b91af;">Notification</span>&lt;<span style="color:blue;">int</span>&gt;.<span style="color:#2b91af;">OnNext</span>(1),<br />    <span style="color:blue;">new </span><span style="color:#2b91af;">Notification</span>&lt;<span style="color:blue;">int</span>&gt;.<span style="color:#2b91af;">OnNext</span>(2),<br />    <span style="color:blue;">new </span><span style="color:#2b91af;">Notification</span>&lt;<span style="color:blue;">int</span>&gt;.<span style="color:#2b91af;">OnCompleted</span>(),<br />    <span style="color:blue;">new </span><span style="color:#2b91af;">Notification</span>&lt;<span style="color:blue;">int</span>&gt;.<span style="color:#2b91af;">OnNext</span>(3),<br />    <span style="color:blue;">new </span><span style="color:#2b91af;">Notification</span>&lt;<span style="color:blue;">int</span>&gt;.<span style="color:#2b91af;">OnNext</span>(4),<br />    <span style="color:blue;">new </span><span style="color:#2b91af;">Notification</span>&lt;<span style="color:blue;">int</span>&gt;.<span style="color:#2b91af;">OnError</span>(<span style="color:blue;">new </span><span style="color:#2b91af;">Exception</span>()),<br />    <span style="color:blue;">new </span><span style="color:#2b91af;">Notification</span>&lt;<span style="color:blue;">int</span>&gt;.<span style="color:#2b91af;">OnNext</span>(5),<br />};</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Dematerializing this sequence of notifications will produce an enumerable sequence that will run no further than the first OnCompleted or OnError:</p><br /><br /><blockquote><br />  <pre class="code">ns<br />.Dematerialize()<br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>This prints 1 and 2 and then terminates. The reason this can still be useful is to create a stream of notifications that will be pre-filtered before doing any dematerialization operation on it. For example, a series of batches could be represented in the following grammar:</p><br /><br /><blockquote><br />  <p>( OnNext* OnCompleted )*</p>
</blockquote>
<br /><p>If the user requests to run n batches, the first n – 1 OnCompleted notifications can be filtered out using some LINQ query expression, before doing dematerialization.</p><br /><br /><p>Finally, a sample of some error-filtering code going back and forth between IEnumerable&lt;T&gt; and IEnumerable&lt;Notification&lt;T&gt;&gt; showing practical use for those operators when doing sophisticated error handling:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>xs1 = <span style="color:blue;">new</span>[] { 1, 2 }.Concat(<span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">InvalidOperationException</span>()));<br /><span style="color:blue;">var </span>xs2 = <span style="color:blue;">new</span>[] { 3, 4 }.Concat(<span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">ArgumentException</span>()));<br /><span style="color:blue;">var </span>xs3 = <span style="color:blue;">new</span>[] { 5, 6 }.Concat(<span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">OutOfMemoryException</span>()));<br /><span style="color:blue;">var </span>xs4 = <span style="color:blue;">new</span>[] { 7, 8 }.Concat(<span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">ArgumentException</span>()));<br /><br /><span style="color:blue;">var </span>xss = <span style="color:blue;">new</span>[] { xs1, xs2, xs3, xs4 };<br /><span style="color:blue;">var </span>xns = xss.Select(xs =&gt; xs<strong>.Materialize()</strong>).Concat();<br /><br /><span style="color:blue;">var </span>res = <span style="color:blue;">from </span>xn <span style="color:blue;">in </span>xns<br />          <span style="color:blue;">let </span>isError = xn.Kind == <span style="color:#2b91af;">NotificationKind</span>.OnError<br />          <span style="color:blue;">let </span>exception = isError ? ((<span style="color:#2b91af;">Notification</span>&lt;<span style="color:blue;">int</span>&gt;.<span style="color:#2b91af;">OnError</span>)xn).Exception : <span style="color:blue;">null<br />          where </span>!isError || exception <span style="color:blue;">is </span><span style="color:#2b91af;">OutOfMemoryException<br />          </span><span style="color:blue;">select </span>xn;<br /><br />res<strong>.Dematerialize()</strong>.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p>Given some input sequences, we materialize and concatenate all of them into sequence xns. Now we write a LINQ query over the notifications to filter out exceptions, unless the exception is a critical OOM one (you could add others to this list). The result is we see 1 through 6 being printed to the screen. (Question: What’s the relationship to OnErrorResumeNext that we saw in the previous post? What’s similar, what’s different?)</p><br /><br /><p>&#160;</p><br />
<h1>Exercises</h1><br /><br /><p>As an exercise, try to implement <a href="http://community.bartdesmet.net/blogs/bart/archive/2009/12/27/more-linq-with-system-interactive-exceptional-exception-handling.aspx">the following operators</a> in a notification-oriented manner:</p><br />
<ol><br />  <li>Catch<br />    <br />(tip: use SelectMany and lots of conditional BLOCKED EXPRESSION</li>
<br />  <li>Finally<br />    <br />(tip: use SelectMany and Defer)</li>
<br />  <li>OnErrorResumeNext – overload taking two IEnumerable&lt;TSource&gt; sequences<br />    <br />(tip: use TakeWhile)</li>
<br />  <li>Retry – overload with a retry count<br />    <br />(tip: recursion, ignore stack overflow conditions)</li>
</ol>
<br /><p>The skeleton code for those operators is shown below:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">return<br />    </span>source<br />    .Materialize()<br /><span style="color:green;">    // Your stuff here</span><br />    .Dematerialize();</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>All-inclusive unit test:</p><br /><br /><blockquote><br />  <pre class="code">    <span style="color:blue;">new</span>[] { 1, 2 }<br />        .Finally(() =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Finally inner&quot;</span>))<br />    .Concat(<span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">InvalidOperationException</span>()))<br />.Catch((<span style="color:#2b91af;">InvalidOperationException </span>_) =&gt; <span style="color:blue;">new</span>[] { 3, 4 }.Concat(<span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">Exception</span>())))<br />.Finally(() =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Finally outer&quot;</span>))<br />.OnErrorResumeNext(<span style="color:blue;">new</span>[] { 5, 6 })<br />.Concat(<span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">ArgumentException</span>()))<br />.Retry(2)<br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a><a href="http://11011.net/software/vspaste"></a><a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>This should produce the same results with the built-in operators and with your implementation of those operators. More specifically, the result has to be:</p><br /><br /><blockquote><br />  <p>1<br />    <br />2<br /><br />    <br />Finally inner<br /><br />    <br />3<br /><br />    <br />4<br /><br />    <br />Finally outer<br /><br />    <br />5<br /><br />    <br />6<br /><br />    <br />1<br /><br />    <br />2<br /><br />    <br />Finally inner<br /><br />    <br />3<br /><br />    <br />4<br /><br />    <br />Finally outer<br /><br />    <br />5<br /><br />    <br />6</p>
</blockquote>
<br /><p>with no exception leaking to the surface in the call site (behavior of Retry after the retry count has been exceeded).</p><br /><br /><p>&#160;</p><br />
<h1>Next on More LINQ</h1><br /><br /><p>Various combinators to combine or transform existing observable sources into others.</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=14934" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/12/28/more-linq-with-system-interactive-sequences-under-construction.aspx">More LINQ with System.Interactive – Sequences under construction</a></div><div class="moreinfo"><span class="date">Monday, December 28, 2009</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><p>With the recent release of the <a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx">Reactive Extensions for .NET (Rx)</a> on <a href="http://msdn.microsoft.com/en-us/devlabs/default.aspx">DevLabs</a>, you’ll hear quite a bit about reactive programming, based on the IObservable&lt;T&gt; and IObserver&lt;T&gt; interfaces. A great amount of resources is available <a href="http://channel9.msdn.com/tags/Rx/">on Channel 9</a>. In this series, I’ll focus on the <a href="http://channel9.msdn.com/shows/Going+Deep/Expert-to-Expert-Brian-Beckman-and-Erik-Meijer-Inside-the-NET-Reactive-Framework-Rx/">dual</a> of the System.Reactive assembly, which is System.Interactive, providing a bunch of extensions to the <a href="http://www.codeplex.com/LINQSQO">LINQ Standard Query Operators</a> for IEnumerable&lt;T&gt;. In today’s installment we’ll talk about constructor operators provided by EnumerableEx:</p>  <p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveSequencesunderconstructio_11DD/image.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveSequencesunderconstructio_11DD/image_thumb.png" width="526" height="480" /></a> </p>  <p>&#160;</p>  <h1>Constructing sequences</h1>  <p>In order to perform operations over sequences using various combinators and operators, it’s obviously a prerequisite to have such sequences available. While collection types in the .NET Framework implement IEnumerable&lt;T&gt; (or the non-generic counterpart, bridgeable to LINQ using the Cast&lt;T&gt; Standard Query Operator), one often wants to construct sequences on the spot. Moreover, sequences often should have a lazy nature as their persistence in memory may be problematic or infeasible (infinite sequences). For all those reasons, constructor operators come in handy.</p>  <p>LINQ to Objects already has a constructor function called Enumerable.Range to produce a sequence with a integral numbers starting from a certain value, returning the asked amount of numbers lazily:</p>  <blockquote>   <pre class="code"><span style="color:green;">// Imperative<br /></span><span style="color:blue;">for </span>(<span style="color:blue;">int </span>i = 0; i &lt; 10; i++)<br />{<br />    <span style="color:#2b91af;">Console</span>.WriteLine(i);<br />}<br /><br /><span style="color:green;">// LINQish<br /></span><span style="color:#2b91af;">Enumerable</span>.Range(start: 0, count: 10).Run<br />(<br />    <span style="color:#2b91af;">Console</span>.WriteLine<br />);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>The lazy nature should not be underestimated, as one could create infinite sequences representing the <em>potential</em> to <em>produce</em> a certain (ordered) set of objects. When combined with other restriction operators it becomes possible to use composition to limit the produced results in a manner very close to the domain we’re talking about. For example, positive natural numbers are integer numbers larger or equal to zero. Numbers starting with 5 are the numbers, capped by means of a Skip operation or something similar. Taking a number of elements can be done using Take. Without deviating too much from our today’s blogging mission, here’s what I’m alluding to:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">static </span><span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">int</span>&gt; Integer()<br />{<br />    <span style="color:blue;">for </span>(<span style="color:blue;">int </span>i = <span style="color:blue;">int</span>.MinValue; i &lt; <span style="color:blue;">int</span>.MaxValue; i++)<br />        <span style="color:blue;">yield return </span>i;<br /><br />    <span style="color:blue;">yield return int</span>.MaxValue;<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>ints = Integer();<br /><span style="color:blue;">var </span>nats = <span style="color:blue;">from </span>i <span style="color:blue;">in </span>ints <span style="color:blue;">where </span>i &gt;= 0 <span style="color:blue;">select </span>i;<br /><span style="color:blue;">var </span>some = nats.Skip(5).Take(5); <span style="color:green;">// Good luck :-)<br /></span>some.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<a href="http://11011.net/software/vspaste"></a><br /><br /><p>I’ll leave it to the reader as a challenge to come up with ways to optimize this in a variety of ways whilst preserving the declarative nature on the use site (i.e. make the sarcastic “Good luck” go away).</p><br /><br /><p>Back to Rx: in today’s installment we’ll look at various constructor functions in EnumerableEx.</p><br /><br /><p>&#160;</p><br />
<h1>Return and the cruel return of the monad</h1><br /><br /><p>The simplest constructor function is Return, simply yielding the single value specified on demand. It’s similar to a one-element array and that’s about it from a practical point of view:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Return&lt;TSource&gt;(TSource value);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>You should be able to guess the implementation of the operator for yourself. Use is straightforward as shown below:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">EnumerableEx</span>.Return(42).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>One interesting thing about this constructor function is its signature, going from TSource to IEnumerable&lt;TSource&gt;. This is nothing but the return function (sometimes referred to as <em>unit</em>) used on a <em>monad</em>, with a more general signature of T to M&lt;T&gt;, the little brother to the bind function which has signature M&lt;T&gt; –&gt; (T –&gt; M&lt;R&gt;) –&gt; M&lt;R&gt;, also known as SelectMany in LINQ. The triplet (known as a Kleisli triple) of the type constructor M (in LINQ the particular cases of IEnumerable&lt;T&gt; and IQueryable&lt;T&gt; are used, i.e. not a general type constructor), the unit and bind function form a monad.</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveSequencesunderconstructio_11DD/image_3.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveSequencesunderconstructio_11DD/image_thumb_3.png" width="640" height="236" /></a> </p>
</blockquote>
<br /><p>For a great overview of Language Integrated Monads, have a look at <a href="http://blogs.msdn.com/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx">Wes Dyer’s The Marvels of Monads post</a>. For a more foundational paper (with lots of applications though), have a look at <a href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">Philip Wadler’s Monads for Functional Programming</a>&#160;<a href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">paper</a>.</p><br /><br /><p>&#160;</p><br />
<h1>Throw me an exception please</h1><br /><br /><p>Another singleton constructor is the Throw function that we’ve seen repeatedly in the previous post on exception handling over sequences. Its role is to provide an enumerable that will throw an exception upon the first MoveNext call during enumeration:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Throw&lt;TSource&gt;(<span style="color:#2b91af;">Exception </span>exception);</pre>
</blockquote>
<br /><p>In fact, this is a lazily thrown exception constructor. Use is simple again:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">Exception</span>()).Run();</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>Notice you got to specify the element type for the returned (never-yielding) sequence as we’re constructing an IEnumerable&lt;T&gt; and there’s no information to infer T from. Obviously, the resulting sequence can be combined with other sequences of the same type in various places, e.g. using Concat. Below is a sample of how to use the Throw constructor with SelectMany to forcefully reject even numbers in a sequence (rather than filtering them out):</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>src = <span style="color:#2b91af;">Enumerable</span>.Range(1, 10);<span style="color:green;">//.Where(i =&gt; i % 2 != 0);<br /></span><span style="color:blue;">var </span>res = src.SelectMany(i =&gt;<br />    i % 2 == 0<br />    ? <span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">Exception</span>(<span style="color:#a31515;">&quot;No evens please!&quot;</span>))<br />    : <span style="color:#2b91af;">EnumerableEx</span>.Return(i)<br />);<br />res.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p>Here we use the conditional operator to decide between an exception throwing sequence or a singleton element sequence (in this case, “Many” in “SelectMany” has “Single” semantics).</p><br /><br /><p>&#160;</p><br />
<h1>Empty missing from the triad</h1><br /><br /><p>For completeness, we could have provided an Empty constructor as well, with the following signature and implementation:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Empty&lt;TSource&gt;()<br />{<br />    <span style="color:blue;">yield break</span>;<br />}</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>There seems little use for this though I challenge the reader to use this one to build the Where operator using SelectMany. In fact, the reason I say “for completeness” is illustrated below:</p><br /><br /><p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveSequencesunderconstructio_11DD/image_4.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveSequencesunderconstructio_11DD/image_thumb_4.png" width="500" height="380" /></a> </p><br /><br /><p>&#160;</p><br />
<h1>StartWith = Snoc (or Cons in disguise)</h1><br /><br /><p>People familiar with LISP, ML, Scala, and many other functional languages, will know the concept of cons by heart. Cons is nothing but the abbreviation for “construct” used to create a bigger list (in LISP lingo) out of an existing list and an element to be prepended:</p><br /><br /><blockquote><br />  <p>(cons 1 (cons 2 nil))</p>
</blockquote>
<br /><p>The above creates a list with 1 as the head and (cons 2 nil) as the tail, which by itself expands into a cell containing 2 and a tail with the nil (null) value. The underlying pair of the head value and tail “reference” to the tail list is known as a cons cell. Decomposition operators exist, known as car and cdr (from old IBM machine terminology where cons cells were realized in machine words consisting of a so called “address” and “decrement” register, explaining the a and d in car and cdr – c and r stand for content and register respectively):</p><br /><br /><blockquote><br />  <p>(car (cons 1 2)) == 1<br />    <br />(cdr (cons 1 2)) == 2</p>
</blockquote>
<br /><p>The StartWith operator is none other than Cons in reverse (sometimes jokingly referred to as “Snoc” by functional programmers):</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; StartWith&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color:blue;">params </span>TSource[] first);<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; StartWith&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source, TSource first);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Focus on the second one first. See how the “first” parameter is taken in as the second argument to StartWith. The reason is it’d be very invasive to put the extension method this parameter on the “first” parameter, as it would pollute all types in the framework with a “Cons” method:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Cons&lt;TSource&gt;(<span style="color:blue;">this </span>TSource head, <span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; tail);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>So, StartWith has to be read in reverse as illustrated below:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">EnumerableEx</span>.StartWith(<br />    <span style="color:#2b91af;">EnumerableEx</span>.StartWith(<br />        <span style="color:#2b91af;">EnumerableEx</span>.Return(3),<br />        2<br />    ),<br />    1<br />).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>This prints 1, 2, 3 since 2 is put in front of 3 and 1 in front of that { 2, 3 } result. An overload exists to start a sequence with multiple elements in front of it:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">EnumerableEx</span>.StartWith(<br />    <span style="color:#2b91af;">EnumerableEx</span>.Return(3),<br />    1, 2<br />).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveSequencesunderconstructio_11DD/image_5.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveSequencesunderconstructio_11DD/image_thumb_5.png" width="500" height="380" /></a> </p><br /><br /><p>&#160;</p><br />
<h1>Generate is your new anamorphism</h1><br /><br /><p>Generate is the most general constructor function for sequences you can imagine. It’s the dual of Aggregate in various ways. Where Aggregate folds a sequence into a single object by combining elements in the input sequence onto a final value in a step-by-step way, the Generate function unfolds a sequence out of a generator function also in a step-by-step way. To set the scene, let’s show the power of Aggregate by refreshing its signature and showing how to implement a bunch of other LINQ combinators in terms of it:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span>TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source, TAccumulate seed, <span style="color:#2b91af;">Func</span>&lt;TAccumulate, TSource, TAccumulate&gt; func, <span style="color:#2b91af;">Func</span>&lt;TAccumulate, TResult&gt; resultSelector);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Given a seed value and a function to combine an element of the input sequence with the current accumulator value into a new accumulator value, the Aggregate function can produce a result that’s the result of (left-)folding all elements in the sequence one-by-one. For example, a sum is nothing but a left-fold thanks to left associativity of the numerical addition operation:</p><br /><br /><blockquote><br />  <p>1 + 2 + 3 + 4 + 5 = ((((1 + 2) + 3) + 4) + 5)</p>
</blockquote>
<br /><p>The accumulated value is the running sum of everything to the left of the current element. Seeing the elements of a sequence being eaten one-by-one is quite a shocking catastrophic event for the sequence, hence the name <a href="http://en.wikipedia.org/wiki/Catamorphism">catamorphism</a>. Below are implementations of Sum, Product, Min, Max, FirstOrDefault, LastOrDefault, Any and All:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>src = <span style="color:#2b91af;">Enumerable</span>.Range(1, 10);<br /><br /><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Sum = &quot; </span>+ src.Aggregate(0, (sum, i) =&gt; sum + i));<br /><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Prd = &quot; </span>+ src.Aggregate(1, (prd, i) =&gt; prd * i));<br /><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Min = &quot; </span>+ src.Aggregate(<span style="color:blue;">int</span>.MaxValue, (min, i) =&gt; i &lt; min ? i : min));<br /><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Max = &quot; </span>+ src.Aggregate(<span style="color:blue;">int</span>.MinValue, (max, i) =&gt; i &gt; max ? i : max));<br /><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Fst = &quot; </span>+ src.Aggregate((<span style="color:blue;">int</span>?)<span style="color:blue;">null</span>, (fst, i) =&gt; fst == <span style="color:blue;">null </span>? i : fst));<br /><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Lst = &quot; </span>+ src.Aggregate((<span style="color:blue;">int</span>?)<span style="color:blue;">null</span>, (lst, i) =&gt; i));<br /><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;AlE = &quot; </span>+ src.Aggregate(<span style="color:blue;">true</span>, (all, i) =&gt; all &amp;&amp; i % 2 == 0));<br /><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;AnE = &quot; </span>+ src.Aggregate(<span style="color:blue;">false</span>, (any, i) =&gt; any || i % 2 == 0));</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>As the dual to catamorphisms we find <a href="http://en.wikipedia.org/wiki/Anamorphism">anamorphisms</a>, where one starts from an initial state and generates elements for the resulting sequence. I leave it to the reader to draw parallels with others words starting with ana- (from the Greek “up”). The most elaborate signature of Generate is shown below:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt; Generate&lt;TState, TResult&gt;(TState initial, <span style="color:#2b91af;">Func</span>&lt;TState, <span style="color:blue;">bool</span>&gt; condition, <span style="color:#2b91af;">Func</span>&lt;TState, <span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt;&gt; resultSelector, <span style="color:#2b91af;">Func</span>&lt;TState, TState&gt; iterate);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>To see this is the dual to Aggregate, you got to use a bit of fantasy, but you can see the parallels. Where Aggregate takes in an IEnumerable&lt;TSource&gt; and produces a TResult, the Generate function produces an IEnumerable&lt;TResult&gt; from a given TState (and a bunch of other things). On both sides, there’s room for an initial state and a way to make progress (“func” versus “iterate”) both staying in their respective domains for the accumulation type (TAccumulate and TState). To select the result (that will end up in the output sequence), the overload above allows to produce multiple TResult values to be returned per TState. And finally, there’s a stop condition which is implicit in the case of a catamorphism as the “remaining tail of sequence is empty” condition can be used for it (i.e. MoveNext returns false).</p><br /><br /><p>Another way to look at Generate is to draw the parallel with a for loop’s three parts: initialization, termination condition, update. In fact, Generate is implemented as some for-loops. More signatures exist:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TValue&gt; Generate&lt;TValue&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Notification</span>&lt;TValue&gt;&gt; function);<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt; Generate&lt;TState, TResult&gt;(TState initial, <span style="color:#2b91af;">Func</span>&lt;TState, <span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt;&gt; resultSelector, <span style="color:#2b91af;">Func</span>&lt;TState, TState&gt; iterate);<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt; Generate&lt;TState, TResult&gt;(TState initial, <span style="color:#2b91af;">Func</span>&lt;TState, <span style="color:#2b91af;">Notification</span>&lt;TResult&gt;&gt; resultSelector, <span style="color:#2b91af;">Func</span>&lt;TState, TState&gt; iterate);<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt; Generate&lt;TState, TResult&gt;(TState initial, <span style="color:#2b91af;">Func</span>&lt;TState, <span style="color:blue;">bool</span>&gt; condition, <span style="color:#2b91af;">Func</span>&lt;TState, <span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt;&gt; resultSelector, <span style="color:#2b91af;">Func</span>&lt;TState, TState&gt; iterate);<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TResult&gt; Generate&lt;TState, TResult&gt;(TState initial, <span style="color:#2b91af;">Func</span>&lt;TState, <span style="color:blue;">bool</span>&gt; condition, <span style="color:#2b91af;">Func</span>&lt;TState, TResult&gt; resultSelector, <span style="color:#2b91af;">Func</span>&lt;TState, TState&gt; iterate);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>We’ll discuss the ones with Notification&lt;T&gt; types in the next episode titled “Code = Data”, but the remaining three others are all straightforward to understand. Some lack a terminating condition while others lack the ability to yield multiple results per intermediate state. Below is a sample of Generate to produce the same results as Enumerable.Range:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>, <span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">int</span>&gt;&gt; range = (start, count) =&gt; <span style="color:#2b91af;">EnumerableEx</span>.Generate(0, i =&gt; i &lt; count, i =&gt; i + start, i =&gt; i + 1);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The other constructors we’ve seen can be written in terms of Generate as well:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">int</span>&gt;&gt; empty = () =&gt; <span style="color:#2b91af;">EnumerableEx</span>.Generate&lt;<span style="color:blue;">object</span>, <span style="color:blue;">int</span>&gt;(<span style="color:blue;">null</span>, o =&gt; <span style="color:blue;">false</span>, o =&gt; <span style="color:blue;">null</span>, o =&gt; o);<br /><span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>, <span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">int</span>&gt;&gt; @return = i =&gt; <span style="color:#2b91af;">EnumerableEx</span>.Generate&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>&gt;(0, n =&gt; n &lt; 1, o =&gt; <span style="color:blue;">new </span>[] { i }, n =&gt; n + 1);<br /><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">Exception</span>, <span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">int</span>&gt;&gt; @throw = ex =&gt; <span style="color:#2b91af;">EnumerableEx</span>.Generate&lt;<span style="color:blue;">object</span>, <span style="color:blue;">int</span>&gt;(<span style="color:blue;">null</span>, o =&gt; <span style="color:blue;">true</span>, o =&gt; { <span style="color:blue;">throw </span>ex; <span style="color:blue;">return null</span>; }, o =&gt; o);<br /><span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>, <span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">int</span>&gt;, <span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">int</span>&gt;&gt; cons = (a, d) =&gt; <span style="color:#2b91af;">EnumerableEx</span>.Generate&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>&gt;(0, n =&gt; n &lt; 2, o =&gt; o == 0 ? <span style="color:blue;">new </span>[] { a } : d, n =&gt; n + 1);<br /><br />@return(1).Run(<span style="color:#2b91af;">Console</span>.WriteLine);<br />@throw(<span style="color:blue;">new </span><span style="color:#2b91af;">Exception</span>()).Catch((<span style="color:#2b91af;">Exception </span>ex) =&gt; @return(22)).Run(<span style="color:#2b91af;">Console</span>.WriteLine);<br />cons(1, cons(2, cons(3, empty()))).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p>&#160;</p><br />
<h1>Defer what you can do now till later</h1><br /><br /><p>The intrinsic lazy nature of sequences with regards to enumeration allows us to push more delayed effects into the sequence’s iteration code. In particular, the construction of a sequence can be hidden behind a sequence of the same type. Let’s show a signature to make this more clear:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Defer&lt;TSource&gt;(<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt;&gt; enumerableFactory);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>In here, an IEnumerable&lt;TSource&gt; is created out of a factory function. What’s handed back from the call to Defer is a stub IEnumerable&lt;TSource&gt; that will only call its factory function (getting the real intended result sequence) upon a triggered enumeration. An example is shown below:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>xs = <span style="color:#2b91af;">EnumerableEx</span>.Defer(() =&gt;<br />{<br />    <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Factory!&quot;</span>);<br />    <span style="color:blue;">return </span><span style="color:#2b91af;">EnumerableEx</span>.Return(1);<br />});<br /><br /><span style="color:#2b91af;">Console</span>.ReadLine();<br /><br />xs.Run(<span style="color:#2b91af;">Console</span>.WriteLine);<br />xs.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>In here, the Factory message won’t be printed till something starts enumerating the xs sequence. Both calls to Run do so, meaning the factory will be called twice (and could in fact return a different sequence each time).</p><br /><br /><p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveSequencesunderconstructio_11DD/image_6.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveSequencesunderconstructio_11DD/image_thumb_6.png" width="500" height="380" /></a> </p><br /><br /><p>&#160;</p><br />
<h1>Next on More LINQ</h1><br /><br /><p>More duality, this time between “code and data” views on sequences, introducing Notification&lt;T&gt;.</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=14928" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/12/27/more-linq-with-system-interactive-exceptional-exception-handling.aspx">More LINQ with System.Interactive – Exceptional Exception Handling</a></div><div class="moreinfo"><span class="date">Sunday, December 27, 2009</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><p>With the recent release of the <a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx">Reactive Extensions for .NET (Rx)</a> on <a href="http://msdn.microsoft.com/en-us/devlabs/default.aspx">DevLabs</a>, you’ll hear quite a bit about reactive programming, based on the IObservable&lt;T&gt; and IObserver&lt;T&gt; interfaces. A great amount of resources is available <a href="http://channel9.msdn.com/tags/Rx/">on Channel 9</a>. In this series, I’ll focus on the <a href="http://channel9.msdn.com/shows/Going+Deep/Expert-to-Expert-Brian-Beckman-and-Erik-Meijer-Inside-the-NET-Reactive-Framework-Rx/">dual</a> of the System.Reactive assembly, which is System.Interactive, providing a bunch of extensions to the <a href="http://www.codeplex.com/LINQSQO">LINQ Standard Query Operators</a> for IEnumerable&lt;T&gt;. In today’s installment we’ll talk about exception handling operators provided by EnumerableEx:</p>  <p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveExceptionalExceptionHandl_158C/image.png"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveExceptionalExceptionHandl_158C/image_thumb.png" width="526" height="480" /></a> </p>  <p>&#160;</p>  <h1>Iterating with and without exceptions</h1>  <p>Under regular circumstances, one expects sequences to produce data in response to iteration. However, it’s perfectly possibly for an iterator (or any enumerable object) to throw an exception in response to a MoveNext call. For example:</p>  <blockquote>   <pre class="code"><span style="color:#2b91af;">Enumerable</span>.Range(0, 10)<br />    .Reverse()<br />    .Select(x =&gt; 100 / x)<br />    .Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p>This piece of code produces the following output:</p><br /><br /><blockquote><br />  <p><font face="Courier New">11 <br />      <br />12 <br /><br />      <br />14 <br /><br />      <br />16 <br /><br />      <br />20 <br /><br />      <br />25 <br /><br />      <br />33 <br /><br />      <br />50 <br /><br />      <br />100 </font></p><br /><br />  <p><font face="Courier New">Unhandled Exception: System.DivideByZeroException: Attempted to divide by zero. <br />      <br />&#160;&#160; at Demo.Program.&lt;Main&gt;b__0(Int32 x) in Program.cs:line 15 <br /><br />      <br />&#160;&#160; at System.Linq.Enumerable.&lt;&gt;c__DisplayClass12`3.&lt;CombineSelectors&gt;b__11(TSource x) <br /><br />      <br />&#160;&#160; at System.Linq.Enumerable.WhereSelectEnumerableIterator`2.MoveNext() <br /><br />      <br />&#160;&#160; at System.Linq.EnumerableEx.Run[TSource](IEnumerable`1 source) <br /><br />      <br />&#160;&#160; at Demo.Program.Main(String[] args) in Program.cs:line 13</font></p>
</blockquote>
<br /><p>Only when the Select operator’s iterator hits 0 for its input, its projection function will throw a DivideByZeroException, causing the iterator to come to an abrupt stop as seen above. In the connected world, where iterators may reach out to external services that can signal error conditions, the ability to handle such sequences in a better and composable way becomes increasingly important.</p><br /><br /><p>In this post, we’ll have a look at the exception handling primitives for enumerable sequences provided by Rx in System.Interactive.EnumerableEx. A related constructor operator, Throw, will be discussed later but is simply enough to reveal in this context because of its relevance:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>oops = <span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">Exception</span>(<span style="color:#a31515;">&quot;Oops&quot;</span>));<br />oops.Run();</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The Throw operator simply creates an iterator that throws the specified exception upon the first MoveNext call on its enumerator. It’s the counterpart to the Return operator creating a single-element iterator. Logically both correspond to the OnNext and OnError methods of IObserver&lt;T&gt; in the reactive world. In addition, we’ll see the relation between those operators and Notification&lt;T&gt; later on, when covering “Code = Data” discussing the Materialize and Dematerialize operators.</p><br /><br /><p>&#160;</p><br />
<h1>Catch it and move on</h1><br /><br /><p>First on is the Catch operator which is available with the following signatures:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Catch&lt;TSource&gt;(<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt;&gt; sources);<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Catch&lt;TSource, TException&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color:#2b91af;">Func</span>&lt;TException, <span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt;&gt; handler) <span style="color:blue;">where </span>TException : <span style="color:#2b91af;">Exception</span>;</pre><br />  <a href="http://11011.net/software/vspaste"></a><a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The second overload is the one used directly for exception handling as you’re used to it in your favorite imperative language. While you normally associate a handler code block with a “protected code block”, here a handler consists of a function producing a sequence in response to an exceptional iteration over the corresponding “protected sequence”. A sample will make things clearer. Consider the following iterator:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">static </span><span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">int</span>&gt; CouldThrow()<br />{<br />    <span style="color:blue;">yield return </span>1;<br />    <span style="color:blue;">yield return </span>2;<br />    <span style="color:blue;">throw new </span><span style="color:#2b91af;">InvalidOperationException</span>(<span style="color:#a31515;">&quot;Oops!&quot;</span>);<br />}</pre>
</blockquote>
<br /><p>Assume you can’t handle the exceptional condition from the inside and you got the iterator from somewhere else, so the following is impossible to achieve:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">static </span><span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">int</span>&gt; CouldThrow()<br />{<br />    <span style="color:blue;">try<br />    </span>{<br />        <span style="color:blue;">yield return </span>1;<br />        <span style="color:blue;">yield return </span>2;<br />        <span style="color:blue;">throw new </span><span style="color:#2b91af;">InvalidOperationException</span>(<span style="color:#a31515;">&quot;Oops!&quot;</span>);<br />    }<br />    <span style="color:blue;">catch </span>(<span style="color:#2b91af;">InvalidOperationException</span>)<br />    {<br />        <span style="color:blue;">yield return </span>3;<br />        <span style="color:blue;">yield return </span>4;<br />        <span style="color:blue;">yield return </span>5;<br />    }<br />}</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>In fact, the above is invalid C# since you can’t yield from a try-block that’s associated with a catch clause, and neither can you yield from a catch clause. Either way, this illustrates basically what we want to achieve from a conceptual point of view, but on the consuming side of the iterator. This is what Catch allows us to do, as follows:</p><br /><br /><blockquote><br />  <pre class="code">CouldThrow()<br />    .Catch((<span style="color:#2b91af;">InvalidOperationException </span>ex) =&gt; <span style="color:blue;">new</span>[] { 3, 4, 5 })<br />    .Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>This simply prints the numbers 1 through 5 on the screen, where the last three values originate from the exception handler. Obviously one could inspect the exception object in the handler. Just like with regular block-based exception handling constructs, one can have multiple “nested” catch clauses associated with the same source sequence. This is achieved by simply chaining Catch operator calls:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">new </span>[] {<br />    <span style="color:green;">/* yield return */ </span>1,<br />    <span style="color:green;">/* yield return */ </span>2 }.Concat(<br />    <span style="color:green;">/* throw */        </span><span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">InvalidOperationException</span>(<span style="color:#a31515;">&quot;Oops!&quot;</span>)))<br />.Catch((<span style="color:#2b91af;">InvalidOperationException </span>ex) =&gt; <span style="color:blue;">new </span>[] {<br />    <span style="color:green;">/* yield return */ </span>3,<br />    <span style="color:green;">/* yield return */ </span>4 }.Concat(<br />    <span style="color:green;">/* throw */        </span><span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">FormatException</span>(<span style="color:#a31515;">&quot;Aargh!&quot;</span>))))<br />.Catch((<span style="color:#2b91af;">FormatException </span>ex) =&gt; <span style="color:blue;">new </span>[] {<br />    <span style="color:green;">/* yield return */ </span>5 })<br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Here, the first catch clause throws an exception by itself, being caught by the next catch clause. This is completely similar to regular exception handling. In summary, the Catch operator allows iteration of a sequence to continue with another one when an exception occurs during the first’s iteration. The handler function provided to Catch isn’t evaluated till an exception occurs, so if the resulting sequence isn’t iterated far enough for an exception to be triggered, the handler obviously won’t execute.</p><br /><br /><p>The second overload of Catch allows specifying a sequence of sequences (IEnumerable&lt;IEnumerable&lt;T&gt;&gt;), continuing a sequence that has terminated by an exception with the sequence following it. For example:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>ex = <span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">Exception</span>());<br /><span style="color:#2b91af;">EnumerableEx</span>.Catch(<span style="color:blue;">new</span>[]<br />    {<br />        <span style="color:blue;">new </span>[] { 1, 2 }.Concat(ex),<br />        <span style="color:blue;">new </span>[] { 3, 4 }.Concat(ex),<br />        <span style="color:blue;">new </span>[] { 5 },<br />        <span style="color:blue;">new </span>[] { 6 },<br />    }).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<a href="http://11011.net/software/vspaste"></a><br /><br /><p>This again will print the numbers 1 through 5, but not 6. Reason is that the first sequence blew up after yielding 1 and 2, causing the next sequence yielding 3 and 4 to be looped in, again causing an exception followed by a hand-over to the third sequence yielding 5. This third sequence finishes regularly (as opposed to exceptionally), so the story ends. I leave it to the reader to write down the corresponding block-structured nested try-catch statements this corresponds to from a conceptual angle.</p><br /><br /><p><u>Exercise:</u> how would you implement a rethrow operation?</p><br /><br /><p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveExceptionalExceptionHandl_158C/image_3.png"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveExceptionalExceptionHandl_158C/image_thumb_3.png" width="500" height="380" /></a> </p><br /><br /><p>&#160;</p><br />
<h1>Finally, too</h1><br /><br /><p>Now we’ve seen the Catch operator, Finally should come as no surprise. From the signature alone, we can see what it does:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Finally&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color:#2b91af;">Action </span>finallyAction);</pre>
</blockquote>
<a href="http://11011.net/software/vspaste"></a><br /><br /><p>Under whatever terminating circumstance when enumerating over the source, the finallyAction will be executed. Obviously this can be illustrated using two cases, one for the regular case and one for the exceptional case. For the latter, we use EnumerableEx.Throw again. First, the regular case:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:green;">/* try { */ </span><span style="color:blue;">new </span>[] {<br />    <span style="color:green;">/* yield return */ </span>1,<br />    <span style="color:green;">/* yield return */ </span>2 }<br />.Finally(() =&gt;<br />    <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Finally&quot;</span>))<br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>This will print 1 and 2, followed by the Finally message. In case of an exception, let’s show the similarity to the lexical nesting of exception handler blocks in C#:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:green;">/* try { */<br />    /* try { */ </span><span style="color:blue;">new</span>[] {<br />        <span style="color:green;">/* yield return */ </span>1,<br />        <span style="color:green;">/* yield return */ </span>2 }.Concat(<br />        <span style="color:green;">/* throw */        </span><span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">Exception</span>()))<br />    .Finally(() =&gt;<br />        <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Finally&quot;</span>))<br />.Catch((<span style="color:#2b91af;">Exception </span>ex) =&gt; <span style="color:blue;">new</span>[] {<br />    <span style="color:green;">/* yield return */ </span>3,<br />    <span style="color:green;">/* yield return */ </span>4,<br />    <span style="color:green;">/* yield return */ </span>5 })<br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>Here the innermost enumerable yields 1 and 2, followed by the throwing of an exception. The Finally operator ensures the printing action is executed no matter how this sequence terminates. In this case, the exception will be caught downstream by the Catch operator, so the end result on the screen will be 1, 2, Finally, 3, 4, 5. As a simple exercise, think about what the following code will and should print:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:green;">/* try { */<br />    /* try { */ </span><span style="color:blue;">new</span>[] {<br />        <span style="color:green;">/* yield return */ </span>1,<br />        <span style="color:green;">/* yield return */ </span>2 }.Concat(<br />        <span style="color:green;">/* throw */        </span><span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">Exception</span>()))<br />    .Finally(() =&gt;<br />        <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Finally&quot;</span>))<br />.Catch((<span style="color:#2b91af;">Exception </span>ex) =&gt; <span style="color:blue;">new</span>[] {<br />    <span style="color:green;">/* yield return */ </span>3,<br />    <span style="color:green;">/* yield return */ </span>4,<br />    <span style="color:green;">/* yield return */ </span>5 })<br /><strong>.Take(2)</strong><br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveExceptionalExceptionHandl_158C/image_4.png"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveExceptionalExceptionHandl_158C/image_thumb_4.png" width="500" height="380" /></a>&#160;</p><br /><br /><p>(Note: break happens when a consumer stops iterating over the resulting sequence.)</p><br /><br /><p>&#160;</p><br />
<h1>OnErrorResumeNext as in VB</h1><br /><br /><p>Visual Basic fans will recognize this operator without doubt. Its operation is fairly straightforward: given a sequence of sequences, those are enumerated one by one, yielding their result to the caller. This is pretty much the same as the Concat operator we’ll see when talking about combinators, with the main difference being that an exceptional termination of any of the sequences does not bubble up. Instead, the OnErrorResumeNext operator simply moves on to the next sequence it can “yield foreach”. A sample will make this clear, but first the signatures:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; OnErrorResumeNext&lt;TSource&gt;(<span style="color:blue;">params </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt;[] sources);<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; OnErrorResumeNext&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt;&gt; sources);<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; OnErrorResumeNext&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; next);</pre><br />  <a href="http://11011.net/software/vspaste"></a><a href="http://11011.net/software/vspaste"></a><a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The following sample prints numbers 1 through 9, with no exception surfacing, even though the third sequence did terminate exceptionally. Replacing the OnErrorResumeNext call with the use of the Concat operator would surface that exception, terminating the resulting sequence after 1 through 7 have been yielded:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">EnumerableEx</span>.OnErrorResumeNext(<br />    <span style="color:blue;">new </span>[] { 1, 2 },<br />    <span style="color:blue;">new </span>[] { 3, 4, 5 },<br />    <span style="color:blue;">new </span>[] { 6, 7 }.Concat(<span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">Exception</span>())),<br />    <span style="color:blue;">new </span>[] { 8, 9 }<br />).Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Use of this operator can be useful for batch processing of records where an exceptional return is tolerable.</p><br /><br /><p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveExceptionalExceptionHandl_158C/image_5.png"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveExceptionalExceptionHandl_158C/image_thumb_5.png" width="500" height="380" /></a> </p><br /><br /><p></p><br /><br /><p>&#160;</p><br />
<h1>Using resources</h1><br /><br /><p>Just like C#’s and VB’s using statements are related to exceptions due to their “finally”-alike guarantees for cleanup, System.Interactive’s Using operator is used for proper resource cleanup, this time in the face of delayed execution of a sequence. The signature for Using is as follows:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Using&lt;TSource&gt;(<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">IDisposable</span>&gt; resourceSelector, <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">IDisposable</span>, <span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt;&gt; resourceUsage);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The idea is to create a sequence that acquires a resource when its iteration is started (by running resourceSelector), which is subsequently used to provide a data sequence “using the resource” (obtained through resourceUsage). It’s only when the resulting sequence terminates (exceptionally or regularly) that the resource is disposed by calling its Dispose method. To illustrate this, let’s cook up our own Action-based disposable:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">class </span><span style="color:#2b91af;">ActionDisposable </span>: <span style="color:#2b91af;">IDisposable<br /></span>{<br />    <span style="color:blue;">private </span><span style="color:#2b91af;">Action </span>_a;<br /><br />    <span style="color:blue;">public </span>ActionDisposable(<span style="color:#2b91af;">Action </span>a)<br />    {<br />        _a = a;<br />    }<br /><br />    <span style="color:blue;">public void </span>Dispose()<br />    {<br />        _a();<br />    }<br />}</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>Now we can write the following two samples:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">EnumerableEx</span>.Using&lt;<span style="color:blue;">int</span>&gt;(() =&gt; <span style="color:blue;">new </span><span style="color:#2b91af;">ActionDisposable</span>(() =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Gone&quot;</span>)), a =&gt;<br />{<br />    <span style="color:green;">// Now we could be using a to get data back...<br />    </span><span style="color:#2b91af;">Console</span>.WriteLine(a <span style="color:blue;">is </span><span style="color:#2b91af;">ActionDisposable</span>);<br />    <span style="color:green;">// ... but let&#39;s just return some stock data.<br />    </span><span style="color:blue;">return new</span>[] { 1, 2, 3 };<br />})<br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);<br /><br /><span style="color:#2b91af;">EnumerableEx</span>.Using&lt;<span style="color:blue;">int</span>&gt;(() =&gt; <span style="color:blue;">new </span><span style="color:#2b91af;">ActionDisposable</span>(() =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Gone&quot;</span>)), a =&gt;<br />{<br />    <span style="color:green;">// Now we could be using a to get data back...<br />    </span><span style="color:#2b91af;">Console</span>.WriteLine(a <span style="color:blue;">is </span><span style="color:#2b91af;">ActionDisposable</span>);<br />    <span style="color:green;">// ... which may result in an exception.<br />    </span><span style="color:blue;">return </span><span style="color:blue;">new</span>[] { 1, 2 }.Concat(<span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">Exception</span>()));<br />})<br />.Catch((<span style="color:#2b91af;">Exception </span>ex) =&gt; <span style="color:blue;">new </span>[] { 4, 5, 6 })<br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>The first one will nicely obtain the Gone-printing resource when enumeration is triggered by Run, returning values 1, 2 and 3, before Using calls dispose on the resource, causing it to print “Gone”. In the second example, the results produced under the acquired resource scope trigger an exception, so upon leaving Using the resource will be disposed again (printing “Gone”), putting us in the Catch operator’s body as we saw before. Now the output will be 1, 2, Gone, 4, 5, 6. Again, as an exercise, think about the following one (easy, just stressing the point…):</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">EnumerableEx</span>.Using&lt;<span style="color:blue;">int</span>&gt;(() =&gt; <span style="color:blue;">new </span><span style="color:#2b91af;">ActionDisposable</span>(() =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Gone&quot;</span>)), a =&gt;<br />{<br />    <span style="color:green;">// Now we could be using a to get data back...<br />    </span><span style="color:#2b91af;">Console</span>.WriteLine(a <span style="color:blue;">is </span><span style="color:#2b91af;">ActionDisposable</span>);<br />    <span style="color:green;">// ... but let&#39;s just return some stock data.<br />    </span><span style="color:blue;">return new</span>[] { 1, 2, 3 };<br />})<br /><strong>.Take(2)<br /></strong>.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p><a href="http://bartdesmet.net/images_wlw/Mor.InteractiveExceptionalExceptionHandl_158C/image_6.png"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/Mor.InteractiveExceptionalExceptionHandl_158C/image_thumb_6.png" width="500" height="380" /></a> </p><br /><br /><p></p><br /><br /><p></p><br /><br /><p>(Note: break is caused by the consumer’s termination of iteration over the resulting sequence.)</p><br /><br /><p>&#160;</p><br />
<h1>Retry till you succeed</h1><br /><br /><p>A final operator in the exception handling operators category we’re discussing in this post, is Retry. The idea of Retry is to retry enumerating and yielding a sequence till it terminates successfully:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TValue&gt; Retry&lt;TValue&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TValue&gt; source);<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TValue&gt; Retry&lt;TValue&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TValue&gt; source, <span style="color:blue;">int </span>retryCount);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Obviously, Retry has no effect if the source sequence iterates without an exception being triggered:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:green;">// A no-op.<br /></span><span style="color:blue;">new </span>[] { 1, 2, 3 }<br />.Retry()<br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>On the other hand, if an exception occurs, a new enumerator over the source sequence is obtained (using GetEnumerator) and iteration is retried. If the exception condition is persistent, this may cause infinite retry:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:green;">// Will go forever...<br /></span><span style="color:blue;">new </span>[] { 1, 2, 3 }.Concat(<span style="color:#2b91af;">EnumerableEx</span>.Throw&lt;<span style="color:blue;">int</span>&gt;(<span style="color:blue;">new </span><span style="color:#2b91af;">Exception</span>()))<br />.Retry()<br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre>
</blockquote>
<br /><p>The overload taking a retryCount can be used to cap the number of retries. If the exception condition is dependent on dynamic factors (e.g. network connectivity to a stream of data), use of Retry will eventually make the iteration succeed:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">static int </span>s_count = 0;</pre><br />  <a href="http://11011.net/software/vspaste"></a><br /><br />  <pre class="code"><span style="color:blue;">static </span><span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">int</span>&gt; MayGetNumbers()<br />{<br />    <span style="color:blue;">try<br />    </span>{<br />        <span style="color:blue;">yield return </span>4;<br />        <span style="color:blue;">if </span>(s_count == 0)<br />            <span style="color:blue;">throw new </span><span style="color:#2b91af;">Exception</span>();<br />        <span style="color:blue;">yield return </span>5;<br />        <span style="color:blue;">if </span>(s_count == 1)<br />            <span style="color:blue;">throw new </span><span style="color:#2b91af;">Exception</span>();<br />        <span style="color:blue;">yield return </span>6;<br />    }<br />    <span style="color:blue;">finally<br />    </span>{<br />        s_count++;<br />    }<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The iterator above will make a bit more progress every time it’s called, the first time getting stuck after yielding 4, the second time after yielding 4 and 5, and finally succeed to yield 4, 5 and 6. Using Retry on this one will produce the following result:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:green;">// 4, (!), 4, 5, (!), 4, 5, 6<br /></span>MayGetNumbers()<br />.Retry()<br />.Run(<span style="color:#2b91af;">Console</span>.WriteLine);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>I’ll leave it as an exercise to the reader to come up with a diagram for this operator, introducing a distinction between IEnumerable and IEnumerator, the latter being potentially different for every time the GetEnumerator method is called. It’s because of the potential different enumeration results that Retry has a chance to be effective.</p><br /><br /><p>&#160;</p><br />
<h1>Next on More LINQ</h1><br /><br /><p>Constructor operators, producing (sometimes trivial) sequences.</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=14926" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/12/26/more-linq-with-system-interactive-the-ultimate-imperative.aspx">More LINQ with System.Interactive – The Ultimate Imperative</a></div><div class="moreinfo"><span class="date">Saturday, December 26, 2009</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><p>With the recent release of the <a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx">Reactive Extensions for .NET (Rx)</a> on <a href="http://msdn.microsoft.com/en-us/devlabs/default.aspx">DevLabs</a>, you’ll hear quite a bit about reactive programming, based on the IObservable&lt;T&gt; and IObserver&lt;T&gt; interfaces. A great amount of resources is available <a href="http://channel9.msdn.com/tags/Rx/">on Channel 9</a>. In this series, I’ll focus on the <a href="http://channel9.msdn.com/shows/Going+Deep/Expert-to-Expert-Brian-Beckman-and-Erik-Meijer-Inside-the-NET-Reactive-Framework-Rx/">dual</a> of the System.Reactive assembly, which is System.Interactive, providing a bunch of extensions to the <a href="http://www.codeplex.com/LINQSQO">LINQ Standard Query Operators</a> for IEnumerable&lt;T&gt;. In today’s installment we’ll talk about the imperative style operators provided on EnumerableEx:</p>  <p><a href="http://bartdesmet.net/images_wlw/MoreLIN.InteractiveTheUltimateImperative_737/image.png"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/MoreLIN.InteractiveTheUltimateImperative_737/image_thumb.png" width="526" height="480" /></a> </p>  <p>&#160;</p>  <h1>Laziness and side-effecting iterators</h1>  <p>LINQ can be quite deceptive on a first encounter due to the lazy island it provides in an otherwise eagerly evaluated language like C# and Visual Basic. Simply writing down a query doesn’t cause it to be executed, assuming no eager operators like ToArray, ToList or ToDictionary are used. In fact, the composition of sequences lies at the heart of this since sequences can evaluate lazily, on demand when calling MoveNext on an enumerator. Iterators are a simple means to provide such a sequence, potentially capturing a sea of side-effects interleaved with the act of producing (or “yielding”) values.</p>  <p>Let’s start with a quite subtle kind of side-effect, reading from a random number generator:</p>  <blockquote>   <pre class="code"><span style="color:blue;">static </span><span style="color:#2b91af;">Random </span>s_random = <span style="color:blue;">new </span><span style="color:#2b91af;">Random</span>();<br /><br /><span style="color:blue;">static </span><span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">int</span>&gt; GetRandomNumbers(<span style="color:blue;">int </span>maxValue)<br />{<br />    <span style="color:blue;">while </span>(<span style="color:blue;">true</span>)<br />    {<br />        <span style="color:blue;">yield return </span>s_random.Next(maxValue);<br />    }<br />}</pre>
</blockquote>
<a href="http://11011.net/software/vspaste"></a><br /><br /><p>Every time you execute this, you’ll get to see different numbers. What’s more important in this context though is the fact every yield return point in the code is a place where the iterator suspends till the next call to MoveNext occurs, causing it to run till the next yield return is encountered. In other words, the whole loop is immunized till a consumer comes along. To visualize this a bit more, let’s add some Console.WriteLine output calls as an additional side-effect:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">static </span><span style="color:#2b91af;">Random </span>s_random = <span style="color:blue;">new </span><span style="color:#2b91af;">Random</span>();<br /><br /><span style="color:blue;">static </span><span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">int</span>&gt; GetRandomNumbers(<span style="color:blue;">int </span>maxValue)<br />{<br />    <span style="color:blue;">while </span>(<span style="color:blue;">true</span>)<br />    {<br />        <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Next&quot;</span>);<br />        <span style="color:blue;">yield return </span>s_random.Next(maxValue);<br />    }<br />}</pre>
</blockquote>
<br /><p>The following code fragment illustrates the point in time where the sequence executes:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>res = GetRandomNumbers(100).Take(10);<br /><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Before iteration&quot;</span>);<br /><span style="color:blue;">foreach </span>(<span style="color:blue;">var </span>x <span style="color:blue;">in </span>res)<br />    <span style="color:#2b91af;">Console</span>.WriteLine(x);</pre>
</blockquote>
<a href="http://11011.net/software/vspaste"></a><a href="http://11011.net/software/vspaste"></a><br /><br /><p>The result is the following:</p><br /><br /><blockquote><br />  <p><font face="Courier New">Before iteration <br />      <br />Next <br /><br />      <br />16 <br /><br />      <br />Next <br /><br />      <br />56 <br /><br />      <br />Next <br /><br />      <br />46 <br /><br />      <br />Next <br /><br />      <br />58 <br /><br />      <br />Next <br /><br />      <br />22 <br /><br />      <br />Next <br /><br />      <br />91 <br /><br />      <br />Next <br /><br />      <br />77 <br /><br />      <br />Next <br /><br />      <br />20 <br /><br />      <br />Next <br /><br />      <br />91 <br /><br />      <br />Next <br /><br />      <br />92</font></p>
</blockquote>
<br /><p>&#160;</p><br />
<h1>Run, run, run</h1><br /><br /><p>System.Interactive’s Run operator in EnumerableEx allows execution of the sequence on the spot, in a fashion equivalent to having a foreach-loop. Two overloads exist, one discarding the element consumed from the sequence and another one feeding it in to an Action&lt;T&gt;:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static void </span>Run&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source);<br /><span style="color:blue;">public static void </span>Run&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color:#2b91af;">Action</span>&lt;TSource&gt; action);</pre>
</blockquote>
<a href="http://11011.net/software/vspaste"></a><br /><br /><p>Rewriting the code above using the second overload will produce similar results:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>res = GetRandomNumbers(100).Take(10);<br /><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Before iteration&quot;</span>);<br />res.Run(x =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(x)); <span style="color:green;">// equivalent to res.Run(Console.WriteLine);</span></pre><br />  <a href="http://11011.net/software/vspaste"></a><a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Since Run returns a void, it’s only used for its side-effects, which can be useful from time to time. Previously, a similar affect could be achieved by calling ToArray or ToList, at the cost of burning memory for no good reason. In the above, it wouldn’t even be a viable option in case you simply want to print random numbers ad infinitum, as an infinite sequence would cause the system to run out of memory in a ToArray or ToList context.</p><br /><br /><p>Let’s assume for the continuation of this post that GetRandomNumbers doesn’t exhibit a printing side-effect in and of itself:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">static </span><span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">int</span>&gt; GetRandomNumbers(<span style="color:blue;">int </span>maxValue)<br />{<br />    <span style="color:blue;">while </span>(<span style="color:blue;">true</span>)<br />    {<br />        <span style="color:blue;">yield return </span>s_random.Next(maxValue);<br />    }<br />}</pre>
</blockquote>
<br /><p>In this setting, our Run call above effectively adds the side-effect of printing to the screen “from the outside”, at the (consuming) end of the “query”. Using the Do operator, one can inject a side-effect in a lazily evaluated sequence composed of different combinators.</p><br /><br /><p><a href="http://bartdesmet.net/images_wlw/MoreLIN.InteractiveTheUltimateImperative_737/image_3.png"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/MoreLIN.InteractiveTheUltimateImperative_737/image_thumb_3.png" width="500" height="380" /></a> </p><br /><br /><p>&#160;</p><br />
<h1>Adding side-effects using Do</h1><br /><br /><p>The Do method has the following signature:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; Do&lt;TSource&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;TSource&gt; source, <span style="color:#2b91af;">Action</span>&lt;TSource&gt; action);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Taking in an IEnumerable&lt;T&gt; and producing one, it simply iterates over the source, executing the specified action before yielding the result to the consumer. Other than producing the side-effect during iteration, it doesn’t touch the sequence at all. You can write this operator in a straightforward manner yourself:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">static </span><span style="color:#2b91af;">IEnumerable</span>&lt;T&gt; Do&lt;T&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;T&gt; source, <span style="color:#2b91af;">Action</span>&lt;T&gt; action)<br />{<br />    <span style="color:blue;">foreach </span>(<span style="color:blue;">var </span>item <span style="color:blue;">in </span>source)<br />    {<br />        action(item);<br />        <span style="color:blue;">yield return </span>item;<br />    }<br />}</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>Or you could build it out of other combinator primitives, in particular Select:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">static </span><span style="color:#2b91af;">IEnumerable</span>&lt;T&gt; Do&lt;T&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;T&gt; source, <span style="color:#2b91af;">Action</span>&lt;T&gt; action)<br />{<br />    <span style="color:blue;">return </span>source.Select(item =&gt;<br />    {<br />        action(item);<br />        <span style="color:blue;">return </span>item;<br />    });<br />}</pre>
</blockquote>
<br /><p>This is useful primarily for debugging purposes, where you want to “probe” different points of execution in a query. For example, consider the following query expression:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>res = <span style="color:blue;">from </span>x <span style="color:blue;">in </span>GetRandomNumbers(100).Take(10)<br />          <span style="color:blue;">where </span>x % 2 == 0<br />          <span style="color:blue;">orderby </span>x<br />          <span style="color:blue;">select </span>x + 1;<br />res.Run(x =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(x));</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Don’t know why it produces the results you’re seeing? Using Do, you can inject “checkpoints”. First, realize the above query desugars into:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>res = GetRandomNumbers(100).Take(10)<br />          .Where(x =&gt; x % 2 == 0)<br />          .OrderBy(x =&gt; x)<br />          .Select(x =&gt; x + 1);</pre>
</blockquote>
<br /><p><a href="http://11011.net/software/vspaste"></a>Now we can put Do calls “on the dots” to see the values flowing through the pipeline during consumption of the query result.</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>res = GetRandomNumbers(100).Take(10)<br />          .Do(x =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Source  -&gt; {0}&quot;</span>, x))<br />          .Where(x =&gt; x % 2 == 0)<br />          .Do(x =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Where   -&gt; {0}&quot;</span>, x))<br />          .OrderBy(x =&gt; x)<br />          .Do(x =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;OrderBy -&gt; {0}&quot;</span>, x))<br />          .Select(x =&gt; x + 1)<br />          .Do(x =&gt; <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Select  -&gt; {0}&quot;</span>, x));</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The below shows what’s triggered by the call to Run:</p><br /><br /><blockquote><br />  <p><font face="Courier New">Source&#160; -&gt; 96 <br />      <br />Where&#160;&#160; -&gt; 96 <br /><br />      <br />Source&#160; -&gt; 25 <br /><br />      <br />Source&#160; -&gt; 8 <br /><br />      <br />Where&#160;&#160; -&gt; 8 <br /><br />      <br />Source&#160; -&gt; 79 <br /><br />      <br />Source&#160; -&gt; 25 <br /><br />      <br />Source&#160; -&gt; 3 <br /><br />      <br />Source&#160; -&gt; 36 <br /><br />      <br />Where&#160;&#160; -&gt; 36 <br /><br />      <br />Source&#160; -&gt; 51 <br /><br />      <br />Source&#160; -&gt; 53 <br /><br />      <br />Source&#160; -&gt; 81 <br /><br />      <br />OrderBy -&gt; 8 <br /><br />      <br />Select&#160; -&gt; 9 <br /><br />      <br />9 <br /><br />      <br />OrderBy -&gt; 36 <br /><br />      <br />Select&#160; -&gt; 37 <br /><br />      <br />37 <br /><br />      <br />OrderBy -&gt; 96 <br /><br />      <br />Select&#160; -&gt; 97 <br /><br />      <br />97</font></p>
</blockquote>
<br /><p>For example, 25 produced by the source didn’t survive the Where operator filtering. From the output one can also see that all Where and Source consumption calls precede any OrderBy calls, since the ordering operator eagerly drains its source before carrying out the ordering and passing the results to its consumer.</p><br /><br /><p>Looking at the output before the first result, 9, is printed, you can observe the effect of the first MoveNext call on the resulting sequence: the whole source is consulted and fed through the Where operator in order for OrderBy to produce the first (smallest) result. A conceptual diagram illustrating the interception of sequences using Do is shown below:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/MoreLIN.InteractiveTheUltimateImperative_737/image_4.png"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/MoreLIN.InteractiveTheUltimateImperative_737/image_thumb_4.png" width="640" height="141" /></a> </p>
</blockquote>
<br /><p>In fact, one can make Do surface through query syntax as well, by providing an extension method overload for e.g. Where (note: this is purely for illustration purposes, and admittedly over-overloading and misusing existing operators :-)):</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static class </span><span style="color:#2b91af;">DoEnumerable<br /></span>{<br />    <span style="color:blue;">public static </span><span style="color:#2b91af;">IEnumerable</span>&lt;T&gt; Where&lt;T&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">IEnumerable</span>&lt;T&gt; source, <span style="color:#2b91af;">Action</span>&lt;T&gt; action)<br />    {<br />        <span style="color:blue;">return </span>source.Do(action);<br />    }<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The resulting usage pattern is the following:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>res = <span style="color:blue;">from </span>x <span style="color:blue;">in </span>GetRandomNumbers(100).Take(10)<br />          <span style="color:green;">/*do*/ </span><span style="color:blue;">where </span><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Source  -&gt; {0}&quot;</span>, x)<br />          <span style="color:blue;">where </span>x % 2 == 0<br />          <span style="color:green;">/*do*/ </span><span style="color:blue;">where </span><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Where   -&gt; {0}&quot;</span>, x)<br />          <span style="color:blue;">orderby </span>x<br />          <span style="color:green;">/*do*/ </span><span style="color:blue;">where </span><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;OrderBy -&gt; {0}&quot;</span>, x)<br />          <span style="color:blue;">select </span>x + 1 <span style="color:blue;">into </span>x<br />          <span style="color:green;">/*do*/ </span><span style="color:blue;">where </span><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Select  -&gt; {0}&quot;</span>, x)<br />          <span style="color:blue;">select </span>x;</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p><a href="http://bartdesmet.net/images_wlw/MoreLIN.InteractiveTheUltimateImperative_737/image_5.png"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/MoreLIN.InteractiveTheUltimateImperative_737/image_thumb_5.png" width="500" height="380" /></a></p><br /><br /><p>&#160;</p><br />
<h1>A lame semi-cooperative scheduler</h1><br /><br /><p>Let’s first say there’s no good justification (this is the <em>lame</em> part) for doing this sample other than for educational purposes showing use of a sequence purely for its side-effects. The idea of the below is to declare a worker thread with varying priorities for portions of its code. Sure, we could have set thread priorities directly in the code, but the special part of it is feeding back desired priorities to the driver loop (“Start”) of the <em>scheduler</em> that can decide how to implement this prioritization scheme. The <em>cooperative </em>nature is the fact the worker threads yield their run by signaling a new priority, effectively handing over control to the driver loop. I’m calling it <em>semi</em> just because of the following sample implementation relying on preemptive scheduling as provided by the Thread class, though the reader challenge will be to shake off that part.</p><br /><br /><p>First of all, work is declared by an iterator that yields priorities followed by the work that will run under that priority. The driver can decide whether or not to call MoveNext, effectively causing the iterator to proceed till the next yield return statement. For example:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">static </span><span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">ThreadPriority</span>&gt; Work1()<br />{<br />    <span style="color:blue;">int </span>i = 0;<br />    <span style="color:#2b91af;">Action </span>print = () =&gt;<br />    {<br />        <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;{0} @ {1} -&gt; {2}&quot;</span>, <span style="color:#2b91af;">Thread</span>.CurrentThread.ManagedThreadId, <span style="color:#2b91af;">Thread</span>.CurrentThread.Priority, i++);<br />        <span style="color:blue;">for </span>(<span style="color:blue;">int </span>j = 0; j &lt; 10000000; j++)<br />            ;<br />    };<br />    <span style="color:blue;">yield return </span><span style="color:#2b91af;">ThreadPriority</span>.Normal;<br />    {<br />        print();<br />    }<br />    <span style="color:blue;">yield return </span><span style="color:#2b91af;">ThreadPriority</span>.Lowest;<br />    {<br />        print();<br />    }<br />    <span style="color:blue;">yield return </span><span style="color:#2b91af;">ThreadPriority</span>.Normal;<br />    {<br />        print();<br />    }<br />    <span style="color:blue;">yield return </span><span style="color:#2b91af;">ThreadPriority</span>.Highest;<br />    {<br />        print();<br />    }<br />    <span style="color:blue;">yield return </span><span style="color:#2b91af;">ThreadPriority</span>.Highest;<br />    {<br />        print();<br />    }<br />}</pre>
</blockquote>
<br /><p>The block-based work item declaration after a yield syntactically groups work items and their priorities. Obviously we fake work to illustrate the point. A driver loop, called Start, can be implemented as lame as relying on the managed Thread type:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">static void </span>Start(<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">ThreadPriority</span>&gt; work)<br />{<br />    <span style="color:blue;">new </span><span style="color:#2b91af;">Thread</span>(() =&gt;<br />    {<br />        work.Do(p =&gt; <span style="color:#2b91af;">Thread</span>.CurrentThread.Priority = p).Run();<br />    }).Start();<br />}</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>In here, we’re using both Run and Do to respectively run the work and cause the side-effect of adjusting the priority of the thread hosting the work. The reader is invited to cook their own dispatcher with the following signature:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">static void </span>Start(<span style="color:blue;">params </span><span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">ThreadPriority</span>&gt;[] workers);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>The idea of this one will be to implement a prioritization scheme – just for fun and definitely no profit other than intellectual stimulus – by hand: run all the work on the same thread, with MoveNext calls standing for an uninterruptible quantum. During a MoveNext call, the worker will proceed till the next yield return is encountered, so you may cause an unfair worker to run away and do work forever. This pinpoints the very nature of cooperative scheduling: you need trust in the individual workers. But when you regain control, retrieving the priority for the next work item the worker plans to do, you can make a decision whether you let it go for another quantum (by calling MoveNext) or let another worker from the worker list take a turn (tip: use an ordering operator to select the next worker to get a chance to run). This process continues till all workers have no more work items left, indicated by MoveNext returning false (tip: keep a list of “schedulable” items).</p><br /><br /><p>In the scope of this post, the sole reason I showed this sample is because of the use of Do and Run to drive home the point of those operators. Sure, you can achieve the same result (if desired at all) by tweaking the managed thread priority directly in each worker.</p><br /><br /><p>&#160;</p><br />
<h1>Next on More LINQ</h1><br /><br /><p>Dealing with exceptions caused by sequence iteration.</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=14925" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/12/25/more-linq-with-system-interactive-getting-started.aspx">More LINQ with System.Interactive – Getting Started</a></div><div class="moreinfo"><span class="date">Friday, December 25, 2009</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><p>With the recent release of the <a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx">Reactive Extensions for .NET (Rx)</a> on <a href="http://msdn.microsoft.com/en-us/devlabs/default.aspx">DevLabs</a>, you’ll hear quite a bit about reactive programming, based on the IObservable&lt;T&gt; and IObserver&lt;T&gt; interfaces. A great amount of resources is available <a href="http://channel9.msdn.com/tags/Rx/">on Channel 9</a>. In this series, I’ll focus on the <a href="http://channel9.msdn.com/shows/Going+Deep/Expert-to-Expert-Brian-Beckman-and-Erik-Meijer-Inside-the-NET-Reactive-Framework-Rx/">dual</a> of the System.Reactive assembly, which is System.Interactive, providing a bunch of extensions to the <a href="http://www.codeplex.com/LINQSQO">LINQ Standard Query Operators</a> for IEnumerable&lt;T&gt;. In today’s installment we’ll talk about getting started with System.Interactive, also touching briefly on the deep duality.</p>  <p>&#160;</p>  <h1>Where to get it?</h1>  <p>To get the Reactive Extensions, which include System.Interactive, visit the landing page on DevLabs <a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx">over here</a>. Downloads are available for .NET Framework 3.5 SP1, .NET Framework 4.0 Beta 2 and Silverlight 3. In this series, I’ll be using the “desktop CLR” distributions from Visual Studio 2008 and Visual Studio 2010.</p>  <p><img style="display:inline;margin-left:0px;margin-right:0px;" title="" alt="" src="http://i.msdn.microsoft.com/ee794896.DevLabs_Rx_Project(en-us).png" /></p>  <p>The differences between the various distributions are of a technical nature and have to do with backporting certain essentials Rx relies on, to the .NET Framework 3.5 SP1 stack. For instance, the IObservable&lt;T&gt; and IObserver&lt;T&gt; interfaces exist in .NET 4.0 but don’t in .NET 3.5. Similarly, the Task Parallel Library (TPL) is available in .NET 4.0’s System.Threading namespace, while Rx redistributes it to run on .NET 3.5 SP1.</p>  <p>&#160;</p>  <h1>What’s in it?</h1>  <p>Once you’ve installed, have a look at your Program Files (x86) folder, under Microsoft Reactive Extensions. I’m using the “DesktopV2” version here, which refers to CLR 2.0 and the .NET Framework 3.5 SP1 package. The main difference with the “DesktopV4” version is the presence of System.Threading, which contains the Parallel Extensions that ship in .NET 4.0:</p>  <p><a href="http://bartdesmet.net/images_wlw/MoreLINQwithSy.InteractiveGettingStarted_12E2F/image.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/MoreLINQwithSy.InteractiveGettingStarted_12E2F/image_thumb.png" width="940" height="452" /></a> </p>  <p>A brief introduction to the remaining assemblies:</p>  <ul>   <li><strong>System.CoreEx.dll</strong> contains some commonly used types like Action and Func delegates with bigger arities (up to 16 parameters), new Property&lt;T&gt; primitives, a Unit type, an Event type wrapping “object sender, EventArgs e” pairs, a Notification&lt;T&gt; (which will be discussed extensively) and some notions of time in the form of TimeInterval&lt;T&gt; and Timestamped&lt;T&gt;.</li>    <li><strong>System.Interactive.dll</strong>, the subject of this new series, contains extension methods for IEnumerable&lt;T&gt; and additional LINQ to Objects operators, provided in a type called EnumerableEx.</li>    <li><strong>System.Reactive.dll</strong>, which is where Rx gets its name for and which will be discussed in future series, is the home for reactive programming tools. It contains IObservable&lt;T&gt; and IObserver&lt;T&gt;, as well as various combinators over it (sometimes referred to as “LINQ to Events”). In addition, it provides primitives like subjects and contains a join library (more about this in a separate installment).</li> </ul>  <p>&#160;</p>  <h1>Duality? Help!</h1>  <p>As we like to use expensive words like “mathematical dual” it makes sense to provide some easy to grasp introduction to the subject. The first thing to look at is the distinction between interactive and reactive programming. In the diagram below, this is illustrated:</p>  <p><a href="http://bartdesmet.net/images_wlw/MoreLINQwithSy.InteractiveGettingStarted_12E2F/image_3.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/MoreLINQwithSy.InteractiveGettingStarted_12E2F/image_thumb_3.png" width="922" height="435" /></a> </p>  <p>In the world of <strong>interactive</strong> programming, the application <strong>asks</strong> for more information. It <strong>pulls</strong> data out of a sequence that represents some data source, in particular <strong>by calling</strong> MoveNext on an enumerator object. The application is quite <strong>active</strong> in the data retrieval process: besides getting an enumerator (by calling GetEnumerator on an enumerable), it also decides about the pace of the retrieval by calling MoveNext at its own convenience.</p>  <p>In the world of <strong>reactive </strong>programming, the application is <strong>told </strong>about more information. Data is <strong>pushed</strong> to it from a data source <strong>by getting called</strong> on the OnNext method of an observer object. The application is quite <strong>passive </strong>in the data retrieval process: apart from subscribing to an observable source, it can’t do anything but reacting to the data pushed to it by means of OnNext calls.</p>  <p>The nice thing about those two worlds is that they’re dual. The highlighted words in the paragraphs above have dual meanings. Because of this observation, it’s desirable to search for dualities on a more formal and technical level as well. In particular, the interfaces being used here are the exact duals of one another: IEnumerable&lt;T&gt; is to IObservable&lt;T&gt; as IEnumerator&lt;T&gt; is to IObserver&lt;T&gt;. Dualization can be achieved by turning inputs (e.g. method parameters) into output (e.g. return values):</p>  <p><a href="http://bartdesmet.net/images_wlw/MoreLINQwithSy.InteractiveGettingStarted_12E2F/image_4.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/MoreLINQwithSy.InteractiveGettingStarted_12E2F/image_thumb_4.png" width="964" height="394" /></a> </p>  <p>Lots of dualities exist in various disciplines, providing for great knowledge transfers between different domains. For example, in formal logic, De Morgan’s law allows converting expressions built from conjunctions into ones built from disjunctions, and vice versa. In electronics, similarities exist between the behavior of capacitors and inductances: know one and how to go back and forth between domains, and you know the other. Fourier calculus provides duals between time and frequency domains.</p>  <p>One thing all those have in common is a way to go back and forth between domains. Such a mechanism exists in the world of System.Reactive and System.Interactive as well. Every observable collection can be turned into an enumerable one and vice versa, using operators called ToEnumerable and ToObservable. To get a feel about how those work, imagine an enumerable collection first. The only thing one can do to retrieve its data is enumerate over it. For all the values received, signal them on the resulting observable’s observer. In the opposite direction, you subscribe on an observable collection to receive the values thrown at you and keep them so that the resulting enumerable can fetch them.</p>  <p>In this series, we’ll not look over the garden wall to the reactive world just yet. Instead, we’ll get our hands dirty in the world of System.Interactive, a logical extension to .NET 3.5’s IEnumerable&lt;T&gt; extension methods, known as the Standard Query Operators.</p>  <p>&#160;</p>  <h1>Operators overview</h1>  <p>The System.Linq.EnumerableEx static class in System.Interactive contains various (extension) methods that operator on IEnumerable&lt;T&gt; enumerable collections. It should be seen as a logical extension to the System.Linq.Enumerable class in System.Core. In the illustration below I’ve summarize the various categories those new operators fall into. Some could be considered to fall in multiple categories, so take this with a grain of salt. Nevertheless, we’ll look at those big buckets in subsequent posts in this series:</p>  <ul>   <li><strong>Imperative use</strong> – provides operators that execute a sequence (Run) and inject side-effecting Actions in a chain of query operator calls (Do), which is handy for debugging.</li>    <li><strong>Exceptions</strong> – enumeration of sequences can cause exceptions (e.g. if you write an iterator, but also by other means – see later), which may need to be handled somehow. Methods like Catch, Finally, Using, OnErrorResumeNext and Retry provide means to make a sequence resilient in face of exceptions.</li>    <li><strong>Constructors</strong> – instead of creating an iterator yourself, it’s possible to let the system create a sequence on your behalf, e.g. by providing it a generator function (Generate), by composing sequences and elements (Return, StartWith, Throw), or triggering the call of a deferred constructor function when a client start enumerating (Defer).</li>    <li><strong>Code = Data</strong> – the triplet of OnNext, OnError and OnComplete seen on IObserver&lt;T&gt; is a very code-centric way of signaling various outcomes of data consumption. An alternative view is to treat those outcomes as pieces of data, called notifications (Notification&lt;T&gt;). Using Materialize and Dematerialize, one can transfer back and forth between those two domains.</li>    <li><strong>Combinators</strong> – producing sequences out of one or more existing sequences is what combinators generally do. One can repeat a sequence a number of times (Repeat), zip two sequences together (Zip), let two sequences battle to provide a result the fastest (Amb), and more. Those operators are most “in line” with what you already know from System.Linq today.</li>    <li><strong>Functional</strong> – while the imperative and exception categories acknowledge the possibility for sequence to exhibit side-effects, the functional category is meant to tame the side-effects, typically in one-producer-many-consumer scenarios. When a sequence may produce side-effects during iteration, it may be desirable to avoid duplication of those when multiple consumers iterate.</li>    <li><strong>Miscellaneous</strong> – just that, miscellaneous.</li> </ul>  <p><a href="http://bartdesmet.net/images_wlw/MoreLINQwithSy.InteractiveGettingStarted_12E2F/image_5.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/MoreLINQwithSy.InteractiveGettingStarted_12E2F/image_thumb_5.png" width="526" height="480" /></a> </p>  <p>Next time, we’ll start by looking at the “Imperative use” category. Download the libraries today and start exploring!</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=14924" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/12/06/reader-challenge-fault-handlers-in-c.aspx">Reader Challenge – Fault Handlers in C#</a></div><div class="moreinfo"><span class="date">Sunday, December 06, 2009</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><p>The CLR’s exception handling facilities provide for <em>protected blocks</em> (“try”) one can associate a <em>handler</em> with. There are four kinds of handlers, and exactly one can be associated with a protected block (but nesting can be used to associate multiple handlers with a block of code):</p>  <ul>   <li>A <strong>finally handler </strong>is executed whenever the block is exited, regardless of whether this happened by normal control flow or an unhandled exception. C# exposes this using the finally keyword.</li>    <li>A <strong>type-filtered handler</strong> handles an exception of a specified class or any of its subclasses. Better known as a “catch block”, C# provides this through its catch keyword.</li>    <li>A <strong>user-filtered handler</strong> runs user-specified code to determine whether the exception should be ignored, handled by the associated handler, or passed on to the next protected block. C# doesn’t expose this, but Visual Basic does by means of its When keyword.</li>    <li>A <strong>fault handler </strong>is executed if an exception occurs, but not on completion of normal control flow. Neither C# nor Visual Basic provide a fault handler language feature.</li> </ul>  <p>In this reader challenge, we’re going to focus on fault handlers. Due to their lack of language surface, their effect is often mimicked by using some local state to determine whether the protected block exited gracefully or not:</p>  <blockquote>   <p><font face="Courier New"><font color="#0000ff">bool </font>success = <font color="#0000ff">false</font>;        <br /><font color="#0000ff">try</font>        <br />{        <br /></font><font face="Courier New"><font color="#008000">&#160;&#160;&#160; // Do stuff         <br /></font>&#160;&#160;&#160; success = <font color="#0000ff">true</font>;        <br />}        <br /><font color="#0000ff">finally</font>        <br />{        <br />&#160;&#160; <font color="#0000ff">if </font>(!success)        <br />&#160;&#160; {        <br /><font color="#008000">&#160;&#160;&#160;&#160;&#160;&#160; // There was a fault. Do something special.</font>        <br />&#160;&#160; }        <br /><font color="#008000">&#160;&#160; // Fault or not; this is what finally does.</font>        <br />}</font></p> </blockquote>  <p>If an exception happens during “Do stuff”, we end up in the finally block and come to conclude success was never set to true. This indicates an error happened, and we should handle the fault case. However, this technique can get a bit tricky when there are different paths exiting the try block: one could return from the enclosing method in various places, requiring the “success = true” code to be sprinkled around. This is exactly what exception handling was designed for: reducing clutter in your code that has to do with error condition/code tracking. So, we’re defeating that purpose.</p>  <p>Today’s challenge is to create a true fault handler in C#, just for the sake of it. This is merely a brain teaser, encouraging readers to find out what happens behind the scenes of compiled C# code. We won’t be addressing certain concerns like non-local return (the case I mentioned above) but will be hunting for the true “fault” handler treasure hidden deeply in the C# compiler’s IL code emitter. The operational specification is the following:</p>  <blockquote>   <p><font face="Courier New"><font color="#0000ff">var </font>f = Fault(() =&gt; <font color="#008080">Console</font>.WriteLine(<font color="#800000">&quot;Okay&quot;</font>),        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; () =&gt; <font color="#008080">Console</font>.WriteLine(<font color="#800000">&quot;Fault&quot;</font>));        <br />f();        <br /><font color="#008080">Console</font>.WriteLine(); </font></p>    <p><font face="Courier New"><font color="#0000ff">var </font>g = Fault(() =&gt; { <font color="#0000ff">throw new </font><font color="#008080">Exception</font>(<font color="#800000">&quot;Oops&quot;</font>); },        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; () =&gt; <font color="#008080">Console</font>.WriteLine(<font color="#800000">&quot;Fault&quot;</font>));        <br /><font color="#0000ff">try</font>        <br />{        <br />&#160;&#160;&#160; g();        <br />}        <br /><font color="#0000ff">catch </font>(<font color="#008080">Exception </font>ex)        <br />{        <br />&#160;&#160;&#160; <font color="#008080">Console</font>.WriteLine(ex);        <br />} </font></p> </blockquote>  <p>The above should produce the following output:</p>  <blockquote>   <p><font face="Courier New">Okay </font></p>    <p><font face="Courier New">Fault       <br />System.Exception: Oops        <br />&#160;&#160; at Program.&lt;Main&gt;b__2()        <br />&#160;&#160; <em>(I won’t reveal the secrets here yet…)         <br /></em>&#160;&#160; at Program.Main()</font></p> </blockquote>  <p>Action f illustrates the non-exceptional case where the fault handler is not invoked (a finally handler would get invoked). Action g illustrates the exceptional case where the fault handler gets invoked and the exception bubbles up to the catch-block surrounding its invocation.</p>  <p>It’s strictly forbidden to use local state in Fault (or a method it calls) to track the successful execution of the protected block. Therefore, the below is an invalid solution:</p>  <blockquote>   <p><font face="Courier New"><font color="#0000ff">static</font> <font color="#008080">Action </font>Fault(<font color="#008080">Action </font>protectedBlock, <font color="#008080">Action </font>faultHandler)        <br />{        <br />&#160;&#160;&#160; <font color="#0000ff">return</font> () =&gt;        <br />&#160;&#160;&#160; {        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <font color="#0000ff">bool </font>success = <font color="#0000ff">false</font>;        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <font color="#0000ff">try</font>        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; protectedBlock();        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; success = <font color="#0000ff">true</font>;        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <font color="#0000ff">finally</font>        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <font color="#0000ff">if </font>(!success)        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; faultHandler();        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }        <br />&#160;&#160;&#160; };        <br />}</font></p> </blockquote>  <p>Moreover, execution of your Fault method should really use a fault handler as encountered in IL code. It should <strong>be</strong> a fault handler, <strong>not mimic</strong> one. In addition, you should not go for a solution where you write a Fault method in ILASM by hand and link it as a netmodule in a C# project, using al.exe:</p>  <blockquote>   <p><font face="Courier New"><font color="#0000ff">.class private </font><font color="#008080">FaultClosure</font>        <br />{        <br />&#160; <font color="#0000ff">.field class </font>[System.Core]<font color="#008080">System.Action</font> protectedBlock        <br />&#160; <font color="#0000ff">.field class </font>[System.Core]<font color="#008080">System.Action</font> faultHandler </font></p>    <p><font face="Courier New">&#160; <font color="#0000ff">.method void </font>.ctor()        <br />&#160; {        <br />&#160;&#160;&#160; <font color="#0000ff">ldarg.0</font>        <br />&#160;&#160;&#160; <font color="#0000ff">call instance void </font>[mscorlib]<font color="#008080">System.Object</font>::.ctor()        <br />&#160;&#160;&#160; <font color="#0000ff">ret</font>        <br />&#160; } </font></p>    <p><font face="Courier New"><font color="#0000ff">&#160; .method void </font>Do()        <br />&#160; {        <br /><font color="#0000ff">&#160;&#160;&#160; .try</font>        <br />&#160;&#160;&#160; {        <br />&#160;&#160;&#160;&#160;&#160; <font color="#0000ff">ldarg.0</font>        <br />&#160;&#160;&#160;&#160;&#160; <font color="#0000ff">ldfld</font>&#160;<font color="#0000ff">class </font>[System.Core]<font color="#008080">System.Action</font> <font color="#008080">Program</font>/<font color="#008080">FaultClosure</font>::protectedBlock        <br />&#160;&#160;&#160;&#160;&#160; <font color="#0000ff">callvirt instance void </font>[System.Core]<font color="#008080">System.Action</font>::Invoke()        <br />&#160;&#160;&#160;&#160;&#160; <font color="#0000ff">leave.s</font> END        <br />&#160;&#160;&#160; }        <br />&#160;&#160;&#160; <font color="#0000ff"><strong><u>fault</u></strong></font>        <br />&#160;&#160;&#160; {        <br />&#160;&#160;&#160;&#160;&#160; <font color="#0000ff">ldarg.0</font>        <br />&#160;&#160;&#160;&#160;&#160; <font color="#0000ff">ldfld class </font>[System.Core]<font color="#008080">System.Action</font> <font color="#008080">Program</font>/<font color="#008080">FaultClosure</font>::faultHandler        <br />&#160;&#160;&#160;&#160;&#160; <font color="#0000ff">callvirt instance void </font>[System.Core]<font color="#008080">System.Action</font>::Invoke()        <br />&#160;&#160;&#160;&#160;&#160; <font color="#0000ff">endfault</font>        <br />&#160;&#160;&#160; }        <br />&#160;&#160;&#160; END: <font color="#0000ff">ret</font>        <br />&#160; }        <br />} </font></p>    <p><font face="Courier New"><font color="#0000ff">.method static class </font>[System.Core]<font color="#008080">System.Action</font> Fault(<font color="#0000ff">class </font>[System.Core]<font color="#008080">System.Action</font> protectedBlock, <font color="#0000ff">class </font>[System.Core]<font color="#008080">System.Action</font> faultHandler)        <br />{        <br />&#160; <font color="#0000ff">.locals init </font>(<font color="#0000ff">class </font><font color="#008080">Program</font>/<font color="#008080">FaultClosure </font>V_0)        <br />&#160; <font color="#0000ff">newobj void </font><font color="#008080">Program</font>/<font color="#008080">FaultClosure</font>::.ctor()        <br /></font><font face="Courier New"><font color="#0000ff">&#160; stloc.0         <br />&#160; ldloc.0          <br />&#160; ldarg.0          <br />&#160; stfld class </font>[System.Core]<font color="#008080">System.Action Program</font>/<font color="#008080">FaultClosure</font>::protectedBlock        <br /></font><font face="Courier New"><font color="#0000ff">&#160; ldloc.0         <br />&#160; ldarg.1          <br />&#160; stfld class </font>[System.Core]<font color="#008080">System.Action</font> <font color="#008080">Program</font>/<font color="#008080">FaultClosure</font>::faultHandler        <br /><font color="#0000ff">&#160; ldloc.0</font>        <br />&#160; <font color="#0000ff">ldftn instance void </font><font color="#008080">Program</font>/<font color="#008080">FaultClosure</font>::Do()        <br />&#160; <font color="#0000ff">newobj void </font>[System.Core]<font color="#008080">System.Action</font>::.ctor(<font color="#0000ff">object</font>, <font color="#0000ff">native int</font>)        <br />&#160; <font color="#0000ff">ret</font>        <br />}</font></p> </blockquote>  <p>Again, this exercise is just for fun with no profit other than brain stimulation. Hint: what C# 2.0 or later feature may cause a “fault” block to be emitted (i.e. if you ildasm a compiled valid C# application, you can find a “fault” keyword)?</p>  <p>Happy holidays!</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=14892" width="1" height="1"></p></div><div class="entry"><div class="title"><a href="http://community.bartdesmet.net/blogs/bart/archive/2009/11/08/jumping-the-trampoline-in-c-stack-friendly-recursion.aspx">Jumping the trampoline in C# – Stack-friendly recursion</a></div><div class="moreinfo"><span class="date">Sunday, November 08, 2009</span> &nbsp;|&nbsp; <span class="source">From <a target="_blank" href="http://community.bartdesmet.net/blogs/bart/rss.aspx">B# .NET Blog</a></span></div><p><h1>Introduction</h1>  <p>Recursion is a widely known technique to decompose a problem in smaller “instances” of the same problem. For example, performing tree operations (e.g. in the context of data structures, user interfaces, hierarchical stores, XML, etc) can be expressed in terms of a navigation strategy over the tree where one performs the same operation to subtrees. A base case takes care of the algorithm’s “bounding”; in case of tree operations that role is played by the leaf nodes of the tree.</p>  <p>Looking at mathematical definitions, one often finds recursive definitions, as well as more imperative style operations:</p>  <blockquote>   <p><b>Imperative</b></p>    <p><a href="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/clip_image002.gif"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="clip_image002" border="0" alt="clip_image002" src="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/clip_image002_thumb.gif" width="126" height="51" /></a></p>    <p><b>Recursive</b></p>    <p><a href="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/clip_image004.gif"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="clip_image004" border="0" alt="clip_image004" src="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/clip_image004_thumb.gif" width="225" height="37" /></a></p> </blockquote>  <p>In here, the first definition lends itself nicely for implementation in an imperative language like C#, e.g. using a foreach-loop. Or, in a more declarative and functionally inspired style, one could write this one using LINQ’s Aggregate operator (which really is a <a href="http://en.wikipedia.org/wiki/Catamorphism">catamorphism</a>):</p>  <blockquote>   <p><font face="Courier New"><font color="#008080">Func</font>&lt;<font color="#0000ff">int</font>, <font color="#0000ff">int</font>&gt; </font><font face="Courier New">fac = n =&gt; <font color="#008080">Enumerable</font>.Range(1, n).Aggregate(1, (p, i) =&gt; p * i);</font></p> </blockquote>  <p>It’s left as an exercise to the reader to define all other catamorphic operators in LINQ in terms of the Aggregate operator:</p>  <ul>   <li>Simple: (Long)<a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.count.aspx">Count</a>, <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.sum.aspx">Sum</a>, <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.average.aspx">Average</a>, <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.min.aspx">Min</a>, <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.max.aspx">Max</a> </li>    <li>A bit harder: <a href="http://msdn.microsoft.com/en-us/library/bb548541.aspx">All</a>, <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.any.aspx">Any</a>, <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.contains.aspx">Contains</a> </li>    <li>More thinking: <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.first.aspx">First</a>(OrDefault), <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.last.aspx">Last</a>(OrDefault), <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.single.aspx">Single</a>(OrDefault) </li> </ul>  <p>But this is not what we’re here for today. Instead, we’re going to focus on the recursive definition. We all know how to write this down in C#, as follows:</p>  <blockquote>   <p><font face="Courier New"><font color="#0000ff">int </font>fac(<font color="#0000ff">int </font>n)         <br />{         <br /></font><font face="Courier New">&#160;&#160;&#160; <font color="#0000ff">return </font>n == 0 ? 1 : n * fac(n – 1);         <br /></font><font face="Courier New">}</font></p> </blockquote>  <p>Or, we could go for lambda expressions, requiring a little additional trick to make this work:</p>  <blockquote>   <p><font face="Courier New"><font color="#008080">Func</font>&lt;<font color="#0000ff">int</font>, <font color="#0000ff">int</font>&gt; fac = <font color="#0000ff">null</font>;         <br />fac = n =&gt; n == 0 ? 1 : n * <strong>fac</strong>(n – 1);</font></p> </blockquote>  <p>The intermediate assignment with the null literal is required to satisfy the definite assignment rules at the point fac is used in the body of the lambda expression, as indicated in bold. What goes on here is quite interesting. When the compiler sees that the fac local variable is used inside a lambda’s body, it’s hoisted into a closure object. In other words, the local variable is not that local:</p>  <blockquote>   <p><font face="Courier New"><font color="#0000ff">var </font>closure = <font color="#0000ff">new </font>{ fac = (<font color="#008080">Func</font>&lt;<font color="#0000ff">int</font>, <font color="#0000ff">int</font>&gt;)<font color="#0000ff">null </font>};         <br />closure.fac = n =&gt; n == 0 ? 1 : n * closure.fac(n – 1);</font></p> </blockquote>  <p>Because of the heap-allocated nature of a closure, we can pass it around – including all of its “context” – to other locations in the code, potentially lower on the call stack. Let’s not go there, but focus on the little null-assignment trick we had to play here. Turns out we can eliminate this.</p>  <p>&#160;</p>  <h1>Please tell me … Y</h1>  <p>Our two-step recursive definition of a lambda expression isn’t too bad, but it should stimulate the reader’s curiosity: can’t we do a one-liner recursive definition instead? The following doesn’t work for reasons alluded to above (try it yourself in your C# compiler):</p>  <blockquote><font face="Courier New"><font color="#008080">Func</font>&lt;<font color="#0000ff">int</font>, <font color="#0000ff">int</font>&gt; fac = n =&gt; n == 0 ? 1 : n * <strong>fac</strong>(n – 1);</font></blockquote>  <p>In languages like F#, a separate recursive definition variant of “let” exists:</p>  <blockquote>   <p><font face="Courier New"><font color="#0000ff">let rec </font>fac n = <font color="#0000ff">if </font>n = 0 <font color="#0000ff">then </font>1 <font color="#0000ff">else </font>n * fac (n – 1)</font></p> </blockquote>  <p>An interesting (well, in my opinion at least) question is whether we can do something similar in C#, realizing “anonymous recursion”. What’s anonymous about it? Well, just having a single <em>expression</em>, without any variable assignments, that captures the intent of the recursive function. In other words, I’d like to be able to:</p>  <blockquote>   <p><font face="Courier New">ThisMethodExpectsUnaryFunctionIntToInt(<font color="#008000">/* I want to pass the factorial function here, defining it inline */</font>)</font></p> </blockquote>  <p>To do this, in the factorial-function-defining expression we can’t <em>refer </em>to a <em>local variable</em>, as we did in the C# (and the F#) fragment. Yet, we need to be able to <em>refer </em>to the function being defined to realize the recursion. If it ain’t a local variable, and we need to refer to it, it ought to be a parameter to the lambda expression:</p>  <blockquote>   <p><font face="Courier New"><strong>fac </strong>=&gt; n =&gt; n == 0 ? 1 : n * <strong>fac</strong>(n – 1)</font></p> </blockquote>  <p>Now we can start to think about types here. On the outer level, we have a function that takes in a “fac” and produces a function “n =&gt; …”. The latter function, at the inner level, is a function that takes in “n” and produces “n == 0 ? …”. That last part is simple to type: Func&lt;int, int&gt;. Back to the outer layer of the lambda onion, what has to be the type of fac? Well, we’re <em>using</em> fac inside the lambda expression, giving it an int and expecting an int back (see “fac(n – 1)”), hence it needs to be a Func&lt;int, int&gt; as well. Pasting all pieces together, the type of the thing above is:</p>  <blockquote>   <p><font face="Courier New"><font color="#008080">Func</font>&lt;<font color="#008080">Func</font>&lt;<font color="#0000ff">int</font>, <font color="#0000ff">int</font>&gt;, <font color="#008080">Func</font>&lt;<font color="#0000ff">int</font>, <font color="#0000ff">int</font>&gt;&gt;</font></p> </blockquote>  <p>Or, in a full-typed form, the expression looks as follows:</p>  <blockquote>   <p><font face="Courier New"><font color="#008080">Func</font>&lt;<font color="#008080">Func</font>&lt;<font color="#0000ff">int</font>, <font color="#0000ff">int</font>&gt;, <font color="#008080">Func</font>&lt;<font color="#0000ff">int</font>, <font color="#0000ff">int</font>&gt;&gt; f = (<font color="#008080">Func</font>&lt;<font color="#0000ff">int</font>, <font color="#0000ff">int</font>&gt; fac) =&gt; ((<font color="#0000ff">int</font> n) =&gt; n == 0 ? 1 : n * fac(n - 1))</font></p> </blockquote>  <p>But the “ThisMethodExpectsUnaryFunctionIntToInt” method expects, well, a Func&lt;int, int&gt;. We somehow need to shake off one of the seemingly redundant Func&lt;int, int&gt; parts of the resulting lambda expression. In fact, we need to <em>fix</em> the lambda expression by eliminating the fac parameter, substituting it for the recursive function itself. So far, we can misuse the function above:</p>  <blockquote>   <p><font face="Courier New">f(<strong>n =&gt; n * 2</strong>)(5) –&gt; 40</font></p> </blockquote>  <p>The bold part somehow needs to be the factorial function itself. This can be realized by means of a <strong>fixpoint combinator</strong>. From a typing perspective, it has the following meaning:</p>  <blockquote>   <p><font face="Courier New"><font color="#008080">Func</font>&lt;<font color="#0000ff">int</font>, <font color="#0000ff">int</font>&gt; Fix(<font color="#008080">Func</font>&lt;<font color="#008080">Func</font>&lt;<font color="#0000ff">int</font>, <font color="#0000ff">int</font>&gt;, <font color="#008080">Func</font>&lt;<font color="#0000ff">int</font>, <font color="#0000ff">int</font>&gt;&gt; f)</font></p> </blockquote>  <p>In other words, we should be able to:</p>  <blockquote>   <p><font face="Courier New">ThisMethodExpectsUnaryFunctionIntToInt(<strong>Fix</strong>(<font face="Courier New">fac =&gt; n =&gt; n == 0 ? 1 : n * fac(n – 1)</font>))</font></p> </blockquote>  <p>and leave the magic of realizing the recursion to Fix. This method can be define as follows (warning: danger for brain explosion):</p>  <blockquote>   <p><font face="Courier New"><font color="#008080">Func</font>&lt;T, R&gt; Fix&lt;T, R&gt;(<font color="#008080">Func</font>&lt;<font color="#008080">Func</font>&lt;T, R&gt;, <font color="#008080">Func</font>&lt;T, R&gt;&gt; f)</font>       <br /><font face="Courier New">{        <br />&#160;&#160;&#160; <font color="#008080">FuncRec</font>&lt;T, R&gt; fRec = r=&gt; t =&gt; f(r(r))(t);         <br />&#160;&#160;&#160; <font color="#0000ff">return </font>fRec(fRec);         <br />}         <br />        <br /><font color="#0000ff">delegate </font><font color="#008080">Func</font>&lt;T, R&gt; <font color="#008080">FuncRec</font>&lt;T, R&gt;(<font color="#008080">FuncRec</font>&lt;T, R&gt; f);</font></p> </blockquote>  <p>To see how the Fix method works, step through it, feeding it our factorial definition. The mechanics of it are less interesting in the context of this blog post, suffice to say it can be done. By the way, this Fix method is inspired by the <a href="http://en.wikipedia.org/wiki/Fixed_point_combinator">Y combinator</a>, a fixpoint combinator created by lambda calculus high priests.</p>  <p>&#160;</p>  <h1>Oops … there goes my stack :-(</h1>  <p>So far, so good. We have a generic fixpoint method called “Fix”, allowing us to define the factorial function (amongst others of course) as follows:</p>  <blockquote>   <p><font face="Courier New"><strong>Fix</strong>(fac =&gt; n =&gt; n == 0 ? 1 : n * fac(n – 1))</font></p> </blockquote>  <p>Since factorial grows incredibly fast, our Int32-based calculation will overflow in no time, so feel free to use .NET 4’s new BigInteger instead:</p>  <blockquote>   <pre class="code"><span style="color:blue;">var </span>factorial = Fix&lt;<span style="color:#2b91af;">BigInteger</span>, <span style="color:#2b91af;">BigInteger</span>&gt;(fac =&gt; n =&gt; n == <span style="color:brown;">0 </span>? <span style="color:brown;">1 </span>: n * fac(n - <span style="color:brown;">1</span>));<br />factorial(<span style="color:brown;">10000</span>);</pre>
</blockquote>
<br /><p>Either way, let’s see what happens under the debugger:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image.png"><img style="border-right-width:0px;display:inline;border-top-width:0px;border-bottom-width:0px;border-left-width:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_thumb.png" width="1047" height="693" /></a> </p>
</blockquote>
<br /><p>That doesn’t look too good, does it? All the magic that Fix did was to realize the recursion, but we’re still using recursive calls to compute the value. After some 5000 recursive calls, the call stack blew up. Clearly we need to do something if we are to avoid this, whilst staying in the comfort zone of recursive algorithm implementations. One such technique is a trampoline. But before we go there, it’s worthwhile to talk about tail calls.</p><br /><br /><p>&#160;</p><br />
<h1>Don’t stand on my tail!</h1><br /><br /><p>One of the inherent problems with this kind of recursion is the fact we need the result of the recursive call after we return from a recursive call. That seems logical but think about it for a while. When we’re computing factorial of 5, we really are doing this:</p><br /><br /><blockquote><br />  <p><font face="Courier New">fac 5 =<br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; fac 4 =<br /><br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; fac 3 = <br /><br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; fac 2 =<br /><br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; fac 1 =<br /><br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 1<br /><br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 2 = <strong>2 *</strong> 1<br /><br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 6 = <strong>3 *</strong> 2<br /><br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 24 = <strong>4 *</strong> 6<br /><br />      <br />120 = <strong>5 *</strong> 24</font></p>
</blockquote>
<br /><p>What happens here is that after we return from the recursive call, we still have to carry out a multiplication. It’s from this observation it follows that we need a call stack frame to keep track of the computation going on. One way to improve on the situation is by avoiding the need to do computation after a recursive call returns. This can achieved by accumulating the result of recursive calls, effectively carrying the result “forward” till the point we hit the base case. In essence, we’re dragging along the partial computed result on every recursive call. In the case of factorial this accumulator will contain the partial multiplication, starting with a value of 1:</p><br /><br /><blockquote><br />  <p><font face="Courier New">fac 5 1 =<br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; fac 4 (5 * 1) =<br /><br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; fac 3 (4 * 5) =&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; fac 2 (3 * 20) =<br /><br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; fac 1 (2 * 60) =<br /><br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 120</font></p>
</blockquote>
<br /><p>In here, the second parameter is the accumulated product so far. In the base case, we simply return the accumulated value. Now we don’t need to do any more work after the recursive call returns. In other words, we’ve eliminated a “tail” of computation after a recursive call. Compilers can come to this insight and eliminate the recursive call. Below is a sample of an accumulating factorial definition in F#:</p><br /><br /><blockquote><br />  <p><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_thumb_3.png" width="677" height="342" /></p>
</blockquote>
<br /><p>If we compile this code in the F# compiler (instead of just staring at F# interactive) and disassemble it, we get to see exactly this optimization carried out by the compiler:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_3.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_thumb_4.png" width="506" height="400" /></a> </p>
</blockquote>
<br /><p>In fact, this code is equivalent to the following piece of C#:</p><br /><br /><blockquote><br />  <p><font face="Courier New">int Fac(int n, int a)<br />      <br />{<br /><br />      <br />&#160;&#160;&#160; while (n &gt; 1)<br /><br />      <br />&#160;&#160;&#160; {<br /><br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; a *= n;<br /><br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; n—;<br /><br />      <br />&#160;&#160;&#160; }<br /><br />      <br />&#160;&#160;&#160; return a;<br /><br />      <br />}</font></p>
</blockquote>
<br /><p>Wonderful, isn’t it? While we preserved a recursive definition, we really got the performance of an imperative loop-construct and are not exhausting the call stack in any way. The C# compiler on the other hand wouldn’t figure this out. In what follows, we will be using this definition of factorial in combination with a trampoline to realize the same kind of stack-friendly recursion in C#.</p><br /><br /><p>&#160;</p><br />
<h1>The art of jumping the trampoline</h1><br /><br /><p>One main characteristics of trampolines is that they bounce back. Jump on them and you’ll be catapulted in the air because you’re given a kinetic energy boost. While in the air you can make funny transformations (corresponding to the body of the recursive function as we shall see), but in the end you’ll end up on the trampoline again. The whole cycle repeats till you run out of energy and just stay at rest on the trampoline. That state will correspond to the end of the recursion.</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_4.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_thumb_5.png" width="486" height="316" /></a> </p>
</blockquote>
<br /><p>This all may sound very vague but things will become clear in a moment. The core idea of a trampoline is to throw a (recursive) function call on a trampoline, let it compute and have it land on the trampoline with a new function. It’s important to see that both the function <em>and</em> its arguments are jumping on there. Compare it to an acrobat that jumps on the trampoline and counts down every time he bounces. The function is the acrobat, the argument is the counter he maintains. When that counter reaches a base case, the <em>breaks</em> from the bouncing by carefully landing next to the trampoline.</p><br /><br /><p>How can we realize such a thing is C# for functions of various arities? To grasp the concept, it helps to start from the simplest case, i.e. an Action with no arguments and – obviously, as we’re talking about actions – no return value. We want to be able to write something like this, but without exhausting the call stack:</p><br /><br /><blockquote><br />  <p><font face="Courier New">void Motivate()<br />      <br /></font><font face="Courier New">{<br />      <br /></font><font face="Courier New">&#160;&#160;&#160; Console.WriteLine(“Go!”);<br />      <br /></font><font face="Courier New">&#160;&#160;&#160; Motivate();<br />      <br /></font><font face="Courier New">}</font></p>
</blockquote>
<br /><p>It goes without saying this can be achieved using a simple loop construct, but it’s no surprise the base case of our investigation is trivial. Keep in mind most of my blog blog posts are about esoteric programming, so don’t ask “Why?” just yet. To realize this recursion, we should start from the signature of a recursive action delegate. To get the trampoline behavior, a recursive action should not just return “void” but return another instance of itself to signal the trampoline what to call next. Compare it with the acrobat again: his capability (a “function” that can be called by the ring master initially: “start jumping!”) to jump up returns the capability (a function again, to be called by the trampoline upon landing) to jump another time. This leads to the following (type-recursive!) signature:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">delegate </span><span style="color:#2b91af;">ActionRec ActionRec</span>();</pre>
</blockquote>
<br /><p>To write an anonymous recursive function, we use the same fixpoint technique as we saw before. In other words, the action is going to be passed as a parameter to a lambda expression, so that it can be called – to realize the recursion – inside the lambda expression’s body. For example, our Motivation sample can be written like this:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>, <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>&gt;&gt; _motivate = motivate =&gt; () =&gt;<br />                                             {<br />                                                 <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Go!&quot;</span>);<br />                                                 <span style="color:blue;">return </span>motivate();<br />                                             };</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Read the lambda expression from left to right to grasp it: given an ActionRec (which will be fixed to the while action itself further on by means of a Fix call), we’re tasked with providing something the trampoline can call (with no arguments in our simple case) to run the next “bounce”. This by itself should return an ActionRec to facilitate the further recursion. Apart from the return keyword and some lambda arrow tokens this looks quite similar to the typical recursive C# method shown earlier. To get the real recursive function with a regular Action signature, we’ll call a fixpoint method called Fix:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Action </span>Motivate = _motivate.Fix();</pre>
</blockquote>
<br /><p>Now can can call Motivate and should see no StackOverflowException even though the function will run forever. The obvious question is how the Fix method works. Since we have no control over the Func delegate type used to define the non-fixed _motivate delegate, it ought to be an extension method. The signature therefore looks like this:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Action </span>Fix(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>, <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>&gt;&gt; f)</pre>
</blockquote>
<br /><p>Now let’s reason about what the Fix method can do. Obviously it has to return an Action, which looks like “return () =&gt; { /* TODO */ };”. Question is what the body of the action has to do. Well, it will have to call f at some point, passing in an ActionRec. This returns a function that, when called, will give us another of those ActionRec delegates. As long as a non-null delegate object is returned (null will be used later on as a way to break from the recursion), we can keep calling it in a loop. And that’s where the stack-friendly nature comes from: we realize the recursion using a <strong>loop</strong>. Here’s how it looks:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Action </span>Fix(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>, <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>&gt;&gt; f)<br />{<br />    <span style="color:blue;">return </span>() =&gt;<br />    {<br />        <span style="color:#2b91af;">ActionRec </span>a = <span style="color:blue;">null</span>;<br />        <span style="color:blue;">for </span>(a = () =&gt; a; a != <span style="color:blue;">null</span>; a = f(a)())<br />            ;<br />    };<br />}</pre>
</blockquote>
<br /><p>The last part of the for-statement is the most explanatory one: it calls the user-defined function with the recursive action, which returns an ActionRec. That gets called with the arguments, which for a plain vanilla action are empty, (). To get started, we use the definite assignment “closure over self” trick we saw at the very start of the post (starting with null):</p><br /><br /><blockquote><font face="Courier New"><font color="#008080">Func</font>&lt;<font color="#0000ff">int</font>, <font color="#0000ff">int</font>&gt; <u>fac</u> = <font color="#0000ff"><u>null</u></font>; <br /><br />    <br /><u>fac</u> = n =&gt; n == 0 ? 1 : n * <strong><u>fac</u></strong>(n – 1);</font></blockquote>
<br /><p>That’s essentially the fixpoint part of Fix. It will definitely help the reader to trace through the code for the Motivate sample step by step. You’ll see how code in the Fix trampoline will get interleaved with calls to your own delegate:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_5.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_thumb_6.png" width="675" height="385" /></a> </p>
</blockquote>
<br /><p>The second frame in the callstack is the trampoline that lives in the anonymous action inside the Fix method. We’re currently broken in the debugger inside the recursive call to our own delegate. Notice though the call stack’s depth is constant at two frames (ignoring Main), even though we’ve already made calls. Contrast this to the original C#-style Motive definition, which would already have grown the stack to 10 frames:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_6.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_thumb_7.png" width="675" height="495" /></a> </p>
</blockquote>
<br /><p>The way to break from a trampoline-based recursion is by returning null from the trampolined function. While that works, we want to add a bit of syntactical surface to it for reasons that will become apparent later (hint: we’ll need a place to stick return values on). So, we define a trivial Break extension method that will return a null-valued ActionRec:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">ActionRec </span>Break(<span style="color:blue;">this </span><span style="color:#2b91af;">ActionRec </span>a) { <span style="color:blue;">return null</span>; }</pre>
</blockquote>
<br /><p>Based on certain conditions we can now decide to break out of the recursion, simply by calling Break on the ActionRec passed in. For example, we could capture a local variable from the outer scope, to act as a counter:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Action of arity 0&quot;</span>);<br />{<br />    <span style="color:blue;">int </span>i = <span style="color:brown;">0</span>;<br />    <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>, <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>&gt;&gt; f = a =&gt; () =&gt; { <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Go! &quot; </span>+ i++); <span style="color:blue;">return </span>i &lt; <span style="color:brown;">10 </span>? a() : a.Break(); };<br />    f.Fix()();<br />}<br /><span style="color:#2b91af;">Console</span>.WriteLine();</pre>
</blockquote>
<br /><p>This will just print 10 Go! messages. Notice I’ve omitted an intermediate variable for the f.Fix() result and call the resulting Action delegate in one go.</p><br /><br /><p>&#160;</p><br />
<h1>More recursive Action types</h1><br /><br /><p>To do something more useful, we want to support higher arities for recursive Action and Func delegates. Let’s start by looking at the Action delegates since we’ve already looked at the simplest case of a recursive Action delegate before. Below is a sample of a recursive Action delegate with one parameter, printing the powers of two with exponents 0 to 9:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Action of arity 1&quot;</span>);<br />{<br />    <span style="color:blue;">int </span>i = <span style="color:brown;">0</span>;<br />    <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>&lt;<span style="color:blue;">int</span>&gt;, <span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>, <span style="color:#2b91af;">ActionRec</span>&lt;<span style="color:blue;">int</span>&gt;&gt;&gt; f = a =&gt; x =&gt; { <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;2^&quot; </span>+ i++ + <span style="color:#a31515;">&quot; = &quot; </span>+ x); <span style="color:blue;">return </span>i &lt; <span style="color:brown;">10 </span>? a(x * <span style="color:brown;">2</span>) : a.Break(); };<br />    f.Fix()(<span style="color:brown;">1</span>);<br />}<br /><span style="color:#2b91af;">Console</span>.WriteLine();</pre>
</blockquote>
<br /><p>Notice we’re cheating a bit by using a captured outer local variable to restrict the number of recursive calls. It’s left as an exercise to the reader to define another such recursive function where the input parameter is used to represent the “to” argument, i.e. specifying the largest exponent to calculate a power of two for.</p><br /><br /><p>In here, the ActionRec&lt;T&gt; delegate represents a recursive action delegate with one generic argument:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">delegate </span><span style="color:#2b91af;">ActionRec</span>&lt;T&gt; <span style="color:#2b91af;">ActionRec</span>&lt;T&gt;(T t);</pre>
</blockquote>
<br /><p>In order to define the recursive action that produces the powers of two, we use a regular function that maps such a recursive action onto a function that can create a new one of those, given an int as the input. Changing the names of the parameters may help to grasp this:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Action of arity 1&quot;</span>);<br />{<br />    <span style="color:blue;">int </span>i = <span style="color:brown;">0</span>;<br />    <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>&lt;<span style="color:blue;">int</span>&gt;, <span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>, <span style="color:#2b91af;">ActionRec</span>&lt;<span style="color:blue;">int</span>&gt;&gt;&gt; _printPowersOfTwo = printPowersOfTwo =&gt; x =&gt;<br />                                                                        {<br />                                                                            <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;2^&quot; </span>+ i++ + <span style="color:#a31515;">&quot; = &quot; </span>+ x);<br />                                                                            <span style="color:blue;">return </span>i &lt; <span style="color:brown;">10 </span>? printPowersOfTwo(x * <span style="color:brown;">2</span>) : printPowersOfTwo.Break();<br />                                                                        };<br />    <span style="color:#2b91af;">Action</span>&lt;<span style="color:blue;">int</span>&gt; PrintPowersOfTwo = _printPowersOfTwo.Fix();<br />    PrintPowersOfTwo(<span style="color:brown;">1</span>);<br />}<br /><span style="color:#2b91af;">Console</span>.WriteLine();</pre>
</blockquote>
<br /><p>Now the indented block reads like “void printPowersOfTo(int x) { … }”. The Fix method’s trampoline is a bit more tricky than the one we saw before, as it needs to deal with the one parameter that has to be fed to the called delegate. There’s a bit of voodoo here since the argument can change every time one makes a recursive call. After all, it’s an argument to the delegate. In the sample above, printPowersOfTwo is fed consecutive powers of two. The little hack is shown below:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Action</span>&lt;T&gt; Fix&lt;T&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>&lt;T&gt;, <span style="color:#2b91af;">Func</span>&lt;T, <span style="color:#2b91af;">ActionRec</span>&lt;T&gt;&gt;&gt; f)<br />{<br />    <span style="color:blue;">return </span>t =&gt;<br />    {<br />        <span style="color:#2b91af;">ActionRec</span>&lt;T&gt; a = <span style="color:blue;">null</span>;<br />        <span style="color:blue;">for </span>(a = <strong>t_</strong> =&gt; { <strong>t = t_;</strong> <span style="color:blue;">return </span>a; }; a != <span style="color:blue;">null</span>; a = f(a)(t))<br />            ;<br />    };<br />}</pre>
</blockquote>
<br /><p>Trace through this for the PrintPowersOfTwo sample, where t starts as value 1. Clearly, a is non-null at that point (due to the assigned lambda expression in the initializer of the for-loop), so we get to call f with that action and argument 1. Now we’re in our code where 1 got assigned to parameter x, causing 2^0 = 1 to be printed to the screen. Ultimately this results in a call to printPowersOfTwo with argument 2. This happens on the action delegate “a” created by the first iteration of the trampoline’s for-loop:</p><br /><br /><blockquote><br />  <p><font face="Courier New">a = <strong>t_</strong> =&gt; { <strong>t = t_;</strong> <span style="color:blue;">return </span>a; }</font></p>
</blockquote>
<br /><p>So, as a side-effect of calling this delegate, the local variable t got assigned the value 2. And the returned object from this call, “a”, gets assigned in the trampoline’s driver loop to the local variable “a”. In the next iteration, 2 will be fed to the recursive delegate. And so on:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_7.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_thumb_8.png" width="677" height="342" /></a> </p>
</blockquote>
<br /><p>Increasing the number of arguments with one more is done in a completely similar way:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Action of arity 2&quot;</span>);<br />{<br />    <span style="color:blue;">int </span>i = <span style="color:brown;">0</span>;<br />    <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>&gt;, <span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>, <span style="color:#2b91af;">ActionRec</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>&gt;&gt;&gt; f = a =&gt; (x, y) =&gt; { <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;2^&quot; </span>+ x + <span style="color:#a31515;">&quot; = &quot; </span>+ y); <span style="color:blue;">return </span>++i &lt; <span style="color:brown;">10 </span>? a(x + <span style="color:brown;">1</span>, y * <span style="color:brown;">2</span>) : a.Break(); };<br />    f.Fix()(<span style="color:brown;">0</span>, <span style="color:brown;">1</span>);<br />}<br /><span style="color:#2b91af;">Console</span>.WriteLine();</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Where the new ActionRec delegate takes two generic parameters:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">delegate </span><span style="color:#2b91af;">ActionRec</span>&lt;T1, T2&gt; <span style="color:#2b91af;">ActionRec</span>&lt;T1, T2&gt;(T1 t1, T2 t2);</pre>
</blockquote>
<br /><p>In this sample we use two input parameters, on to represent the exponents and one to accumulate the powers of two. The Fix method now has to deal with two input parameters that need to be captured upon recursive calls. This is achieved as follows:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Action</span>&lt;T1, T2&gt; Fix&lt;T1, T2&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>&lt;T1, T2&gt;, <span style="color:#2b91af;">Func</span>&lt;T1, T2, <span style="color:#2b91af;">ActionRec</span>&lt;T1, T2&gt;&gt;&gt; f)<br />{<br />    <span style="color:blue;">return </span>(t1, t2) =&gt;<br />    {<br />        <span style="color:#2b91af;">ActionRec</span>&lt;T1, T2&gt; a = <span style="color:blue;">null</span>;<br />        <span style="color:blue;">for </span>(a = (t1_, t2_) =&gt; { t1 = t1_; t2 = t2_; <span style="color:blue;">return </span>a; }; a != <span style="color:blue;">null</span>; a = f(a)(t1, t2))<br />            ;<br />    };<br />}</pre>
</blockquote>
<br /><p>What we haven’t mentioned over and over again is the definition of the Break method that returns null to signal to break from the recursion. Here they are for completeness:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">ActionRec</span>&lt;T&gt; Break&lt;T&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">ActionRec</span>&lt;T&gt; a) { <span style="color:blue;">return null</span>; }<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">ActionRec</span>&lt;T1, T2&gt; Break&lt;T1, T2&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">ActionRec</span>&lt;T1, T2&gt; a) { <span style="color:blue;">return null</span>; }</pre>
</blockquote>
<br /><p>Below is an insight-providing screenshot illustrating the way recursion happens:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_8.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_thumb_9.png" width="844" height="634" /></a> </p>
</blockquote>
<br /><p>In Main, we called the fixed delegate with arguments 0 and 1. This caused us to enter the outermost lambda expression in Fix with t1 and t2 respectively set to 0 and 1. This is the second frame on the call stack (read from the bottom). The for-loop has proceeded to the first call of its update expression, resulting in a call to f with argument a and a subsequent invocation on the result with arguments 0 and 1. As a result, our lambda expression, lexically nested in the Main method, got called as observed by the third frame on the call stack, with x and y respectively set to 0 and 1. Here the recursive call happens by invoking the a delegate with arguments 1 (x + 1) and 2 (y * 2). Finally, this put us back in the trampoline where those two values will be captured in t1 and t2, and that’s where the debugger is currently sitting.</p><br /><br /><p>Moving on from here, we’ll back out of the trampoline and return the result of the apparent recursive call on “a” from lambda “f” in Main. This by itself puts us back in the driver for-loop, where “a” will be tested for null (which it isn’t yet) and the whole cycle starts again. This illustrates the key essence of the trampoline: instead of having the user directly causing a recursive call, callbacks to the trampoline code cause it to capture enough state information to make the call later on. This effectively flattens recursive calls into the for-loop. What we lost is the ability to do work after the recursive call returns (something we could work around by getting into the land of continuations).</p><br /><br /><p>&#160;</p><br />
<h1>Recursive Func types</h1><br /><br /><p>The essential tricks to deal with input parameters have been explored above. However, Func delegate types have one more property we haven’t investigated just yet: the ability to return a value. We’ve seen the Break method before, but for Action delegates it doesn’t do anything but returning null. In case of recursive Func types, we’ll have to do something in addition to this, in order to return an object to the caller.</p><br /><br /><p>Let’s get started by defining the FuncRec delegate types. Again, those are mirrored after the regular Func delegates, but we have to sacrifice the return type position for a FuncRec:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">delegate </span><span style="color:#2b91af;">FuncRec</span>&lt;R&gt; <span style="color:#2b91af;">FuncRec</span>&lt;R&gt;();<br /><span style="color:blue;">delegate </span><span style="color:#2b91af;">FuncRec</span>&lt;T, R&gt; <span style="color:#2b91af;">FuncRec</span>&lt;T, R&gt;(T t);<br /><span style="color:blue;">delegate </span><span style="color:#2b91af;">FuncRec</span>&lt;T1, T2, R&gt; <span style="color:#2b91af;">FuncRec</span>&lt;T1, T2, R&gt;(T1 t1, T2 t2);</pre>
</blockquote>
<br /><p>Returning from a recursive FuncRec delegate will be done through the Break methods that now will take an argument for the return value:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">FuncRec</span>&lt;R&gt; Break&lt;R&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">FuncRec</span>&lt;R&gt; a, R res) { _brr[a] = res; <span style="color:blue;">return </span>a; }<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">FuncRec</span>&lt;T, R&gt; Break&lt;T, R&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">FuncRec</span>&lt;T, R&gt; a, R res) { _brr[a] = res; <span style="color:blue;">return </span>a; }<br /><span style="color:blue;">public static </span><span style="color:#2b91af;">FuncRec</span>&lt;T1, T2, R&gt; Break&lt;T1, T2, R&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">FuncRec</span>&lt;T1, T2, R&gt; a, R res) { _brr[a] = res; <span style="color:blue;">return </span>a; }</pre>
</blockquote>
<br /><p>What’s happening inside those Break methods will be discussed further on. For now, it suffices to see the signatures, taking in an R parameter to hold the return value of the recursive call. Also notice how those methods return “a” instead of null.</p><br /><br /><p>Before we dig any deeper in the implementation, let’s see a couple of recursive functions in action:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Function of arity 0&quot;</span>);<br />{<br />    <span style="color:blue;">int </span>i = <span style="color:brown;">0</span>;<br />    <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">FuncRec</span>&lt;<span style="color:blue;"><strong><u>int</u></strong></span>&gt;, <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">FuncRec</span>&lt;<span style="color:blue;"><strong><u>int</u></strong></span>&gt;&gt;&gt; f = a =&gt; () =&gt; { <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Fun! &quot; </span>+ i++); <span style="color:blue;">return </span>i &lt; <span style="color:brown;">10 </span>? a() : <strong><u>a.Break(i)</u></strong>; };<br />    <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Result: &quot; </span>+ f.Fix()());<br />}<br /><span style="color:#2b91af;">Console</span>.WriteLine();<br /><br /><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Function of arity 1&quot;</span>);<br />{<br />    <span style="color:blue;">int </span>i = <span style="color:brown;">0</span>;<br />    <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">FuncRec</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;"><strong><u>int</u></strong></span>&gt;, <span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>, <span style="color:#2b91af;">FuncRec</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;"><strong><u>int</u></strong></span>&gt;&gt;&gt; f = a =&gt; x =&gt; { <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;2^&quot; </span>+ i++ + <span style="color:#a31515;">&quot; = &quot; </span>+ x); <span style="color:blue;">return </span>i &lt; <span style="color:brown;">10 </span>? a(x * <span style="color:brown;">2</span>) : <strong><u>a.Break(i)</u></strong>; };<br />    <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Result: &quot; </span>+ f.Fix()(<span style="color:brown;">1</span>));<br />}<br /><span style="color:#2b91af;">Console</span>.WriteLine();<br /><br /><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Function of arity 2&quot;</span>);<br />{<br />    <span style="color:blue;">int </span>i = <span style="color:brown;">0</span>;<br />    <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">FuncRec</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>, <span style="color:blue;"><strong><u>int</u></strong></span>&gt;, <span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>, <span style="color:#2b91af;">FuncRec</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>, <span style="color:blue;"><strong><u>int</u></strong></span>&gt;&gt;&gt; f = a =&gt; (x, y) =&gt; { <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;2^&quot; </span>+ x + <span style="color:#a31515;">&quot; = &quot; </span>+ y); <span style="color:blue;">return </span>++i &lt; <span style="color:brown;">10 </span>? a(x + <span style="color:brown;">1</span>, y * <span style="color:brown;">2</span>) : <strong><u>a.Break(i)</u></strong>; };<br />    <span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Result: &quot; </span>+ f.Fix()(<span style="color:brown;">0</span>, <span style="color:brown;">1</span>));<br />}<br /><span style="color:#2b91af;">Console</span>.WriteLine();</pre>
</blockquote>
<br /><p>We bound the recursion again by means of some outer local variable, but this is not a requirement. But in order to show all functions without one running away, such a bound is desirable. Concerning the input parameters, things look identical to the ActionRec samples. What’s different are the Break calls and the output types specified in the FuncRec type parameters. We’ve simply used the bounding variable “i” as the return value for illustration purposes. Later, when we see factorial again, the output value will be more interesting.</p><br /><br /><p>How does Fix work this time? Let’s show one sample for the function with one argument:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">public static </span><span style="color:#2b91af;">Func</span>&lt;T, R&gt; Fix&lt;T, R&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">FuncRec</span>&lt;T, R&gt;, <span style="color:#2b91af;">Func</span>&lt;T, <span style="color:#2b91af;">FuncRec</span>&lt;T, R&gt;&gt;&gt; f)<br />{<br />    <span style="color:blue;">return </span>t =&gt;<br />    {<br />        <span style="color:blue;">object </span>res_;<br />        <span style="color:#2b91af;">FuncRec</span>&lt;T, R&gt; a = <span style="color:blue;">null</span>;<br />        <span style="color:blue;">for </span>(a = t_ =&gt; { t = t_; <span style="color:blue;">return </span>a; }; !_brr.TryGetValue(a, <span style="color:blue;">out </span>res_); a = f(a)(t))<br />            ;<br />        <span style="color:blue;">var </span>res = (R)res_;<br />        _brr.Remove(a);<br />        <span style="color:blue;">return </span>res;<br />    };<br />}</pre>
</blockquote>
<br /><p>I’m using an ugly trick here to store the return value. Have a look at the Break methods that do stick the specified result in a dictionary, which is typed as follows:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:green;">// Would really like to store result on a property on the delegate,<br />// but can&#39;t derive from Delegate manually in C#... This is &quot;brr&quot;.<br /></span><span style="color:blue;">private static </span><span style="color:#2b91af;">Dictionary</span>&lt;<span style="color:#2b91af;">Delegate</span>, <span style="color:blue;">object</span>&gt; _brr = <span style="color:blue;">new </span><span style="color:#2b91af;">Dictionary</span>&lt;<span style="color:#2b91af;">Delegate</span>, <span style="color:blue;">object</span>&gt;();</pre>
</blockquote>
<br /><p>Break add the return value to this dictionary, while the trampoline driver loop checks for such a value repeatedly. If one is found, a Break call has been done and the loop terminates, stopping the recursion and sending the answer to the caller. Alternative potentially cleaner tricks can be thought of, but I haven’t spent much more time thinking about this.</p><br /><br /><p>All in all, the core Fix is pretty much the same as for the action-based delegates, apart from the TryGetValue call in the condition, and some dictionary-related cleanup code. Below is our destination factorial sample:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Factorial&quot;</span>);<br />{<br />    <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">FuncRec</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>, <span style="color:blue;">int</span>&gt;, <span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>, <span style="color:#2b91af;">FuncRec</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>, <span style="color:blue;">int</span>&gt;&gt;&gt; fac_ = f =&gt; (x, a) =&gt; x &lt;= <span style="color:brown;">1 </span>? f.Break(a) : f(x - <span style="color:brown;">1</span>, a * x);<br />    <span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>&gt; fac = (<span style="color:blue;">int </span>n) =&gt; fac_.Fix()(n, <span style="color:brown;">1</span>);<br />    <span style="color:#2b91af;">Enumerable</span>.Range(<span style="color:brown;">1</span>, <span style="color:brown;">10</span>).Select(n =&gt; <span style="color:blue;">new </span>{ n, fac = fac(n) }).Do(<span style="color:#2b91af;">Console</span>.WriteLine).Run();<br />}<br /><span style="color:#2b91af;">Console</span>.WriteLine();</pre>
</blockquote>
<br /><p>The type of the intermediate function definition is quite impressive due to the fixpoint structure, but the essence of the function is quite easy to grasp:</p><br /><br /><blockquote><br />  <p><font face="Courier New">f =&gt; (x, a) =&gt; x &lt;= <span style="color:brown;">1 </span>? f.Break(a) : f(x - <span style="color:brown;">1</span>, a * x)</font></p>
</blockquote>
<br /><p>Given a function (that will represent the fixed factorial definition, i.e. itself) and two arguments, one to count down and one to represent the accumulated product, we simply continue multiplying till we hit the base case, where we return (using Break) the accumulated value. The next line creates a simple wrapper function to hide away the accumulator base value of 1:</p><br /><br /><blockquote><br />  <p><font face="Courier New"><span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>&gt; fac = (<span style="color:blue;">int </span>n) =&gt; fac_.Fix()(n, <span style="color:brown;">1</span>);</font></p>
</blockquote>
<br /><p>And now we have a simple factorial function we can call in the regular manner we’re used to, using delegate invocation syntax. To illustrate it for multiple values, I&#39;m using a simple LINQ <em>statement</em>, projecting each value from 1 to 10 onto an anonymous object with both that number and the corresponding factorial value. The Do and Run methods will be introduced in the Reactive Framework as new extensions to IEnumerable:</p><br /><br /><blockquote><br />  <p><font face="Courier New"><font color="#0000ff">public static </font><font color="#008080">IEnumerable</font>&lt;T&gt; Do&lt;T&gt;(<font color="#0000ff">this </font><font color="#008080">IEnumerable</font>&lt;T&gt; src, <font color="#008080">Action</font>&lt;T&gt; a)<br /><br />      <br />{<br /><br />      <br />&#160;&#160;&#160; <font color="#0000ff">foreach </font>(<font color="#0000ff">var </font>item <font color="#0000ff">in </font>src)<br /><br />      <br />&#160;&#160;&#160; {<br /><br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; a(item);<br /><br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <font color="#0000ff">yield return </font>item;<br /><br />      <br />&#160;&#160;&#160; }<br /><br />      <br />}<br /><br />      <br /><br /><br />      <br /><font color="#0000ff">public static void </font>Run&lt;T&gt;(<font color="#0000ff">this </font><font color="#008080">IEnumerable</font>&lt;T&gt; src)<br /><br />      <br />{<br /><br />      <br />&#160;&#160;&#160; <font color="#0000ff">foreach </font>(<font color="#0000ff">var </font>_ <font color="#0000ff">in </font>src)<br /><br />      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ;<br /><br />      <br />}</font></p>
</blockquote>
<br /><p>To prove the stack utilization remains constant, we can extend the sample using the handy System.Diagnostics.StackTrace class and the .NET 4.0 Tuple class. In the non-trampolined version, we’d see the stack grow on every call, reaching its maximum depth at the point we return from the base case. So, watching the stack depth at the point of the base case’s return call (using Break) will be a good metric of success:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Factorial + stack analysis&quot;</span>);<br />{<br />    <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">FuncRec</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>, <span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>&gt;&gt;, <span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>, <span style="color:#2b91af;">FuncRec</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>, <span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>&gt;&gt;&gt;&gt; fac_ =<br />        f =&gt; (x, a) =&gt; x &lt;= <span style="color:brown;">1 </span>? f.Break(<span style="color:blue;">new </span><span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">int</span>,<span style="color:blue;">int</span>&gt;(a, <u><span style="color:blue;">new </span><span style="color:#2b91af;">StackTrace</span>().FrameCount</u>)) : f(x - <span style="color:brown;">1</span>, a * x);<br />    <span style="color:#2b91af;">Func</span>&lt;<span style="color:blue;">int</span>, <span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>&gt;&gt; fac = (<span style="color:blue;">int </span>n) =&gt; fac_.Fix()(n, <span style="color:brown;">1</span>);<br />    (<span style="color:blue;">from </span>n <span style="color:blue;">in </span><span style="color:#2b91af;">Enumerable</span>.Range(<span style="color:brown;">1</span>, <span style="color:brown;">10</span>)<br />     <span style="color:blue;">let </span>f = fac(n)<br />     <span style="color:blue;">select new </span>{ n, fac = f.Item1, <u>stack = f.Item2</u> }).Do(<span style="color:#2b91af;">Console</span>.WriteLine).Run();<br />}<br /><span style="color:#2b91af;">Console</span>.WriteLine();</pre>
</blockquote>
<br /><p>The result is shown below:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_9.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_thumb_10.png" width="677" height="186" /></a> </p>
</blockquote>
<br /><p>This looks good, doesn’t it? If you get tried of the long generic Func types, simply call the Fix method directly, passing in the types of the arguments and return value:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:blue;">var </span>fac_ = <span style="color:#2b91af;">Ext</span>.Fix&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>, <span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>&gt;&gt;(f =&gt; (x, a) =&gt; <br />    x &lt;= <span style="color:brown;">1 </span>? f.Break(<span style="color:blue;">new </span><span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">int</span>, <span style="color:blue;">int</span>&gt;(a, <span style="color:blue;">new </span><span style="color:#2b91af;">StackTrace</span>().FrameCount)) : f(x - <span style="color:brown;">1</span>, a * x)<br />);</pre><br />  <a href="http://11011.net/software/vspaste"></a></blockquote>
<br /><p>Beautiful! Almost reads like a regular C# method declaration (with plenty of imagination the author possesses).</p><br /><br /><p>&#160;</p><br />
<h1>Putting the pieces together</h1><br /><br /><p>Since readers often want to try out the thing as a whole, here’s the implementation of my latest Esoteric namespace:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:green;">// Trampoline for tail recursive Action and Func delegate creation and invocation in constant stack space<br />// bartde - 10/29/2009<br /><br /></span><span style="color:blue;">using </span>System;<br /><span style="color:blue;">using </span>System.Collections.Generic;<br /><br /><span style="color:blue;">namespace </span>Esoteric<br />{<br />    <span style="color:blue;">delegate </span><span style="color:#2b91af;">ActionRec ActionRec</span>();<br />    <span style="color:blue;">delegate </span><span style="color:#2b91af;">ActionRec</span>&lt;T&gt; <span style="color:#2b91af;">ActionRec</span>&lt;T&gt;(T t);<br />    <span style="color:blue;">delegate </span><span style="color:#2b91af;">ActionRec</span>&lt;T1, T2&gt; <span style="color:#2b91af;">ActionRec</span>&lt;T1, T2&gt;(T1 t1, T2 t2);<br /><br />    <span style="color:blue;">delegate </span><span style="color:#2b91af;">FuncRec</span>&lt;R&gt; <span style="color:#2b91af;">FuncRec</span>&lt;R&gt;();<br />    <span style="color:blue;">delegate </span><span style="color:#2b91af;">FuncRec</span>&lt;T, R&gt; <span style="color:#2b91af;">FuncRec</span>&lt;T, R&gt;(T t);<br />    <span style="color:blue;">delegate </span><span style="color:#2b91af;">FuncRec</span>&lt;T1, T2, R&gt; <span style="color:#2b91af;">FuncRec</span>&lt;T1, T2, R&gt;(T1 t1, T2 t2);<br /><br />    <span style="color:blue;">static class </span><span style="color:#2b91af;">Ext<br />    </span>{<br />        <span style="color:blue;">public static </span><span style="color:#2b91af;">ActionRec </span>Break(<span style="color:blue;">this </span><span style="color:#2b91af;">ActionRec </span>a) { <span style="color:blue;">return null</span>; }<br />        <span style="color:blue;">public static </span><span style="color:#2b91af;">ActionRec</span>&lt;T&gt; Break&lt;T&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">ActionRec</span>&lt;T&gt; a) { <span style="color:blue;">return null</span>; }<br />        <span style="color:blue;">public static </span><span style="color:#2b91af;">ActionRec</span>&lt;T1, T2&gt; Break&lt;T1, T2&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">ActionRec</span>&lt;T1, T2&gt; a) { <span style="color:blue;">return null</span>; }<br /><br />        <span style="color:blue;">public static </span><span style="color:#2b91af;">Action </span>Fix(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>, <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>&gt;&gt; f)<br />        {<br />            <span style="color:blue;">return </span>() =&gt;<br />            {<br />                <span style="color:#2b91af;">ActionRec </span>a = <span style="color:blue;">null</span>;<br />                <span style="color:blue;">for </span>(a = () =&gt; a; a != <span style="color:blue;">null</span>; a = f(a)())<br />                    ;<br />            };<br />        }<br /><br />        <span style="color:blue;">public static </span><span style="color:#2b91af;">Action</span>&lt;T&gt; Fix&lt;T&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>&lt;T&gt;, <span style="color:#2b91af;">Func</span>&lt;T, <span style="color:#2b91af;">ActionRec</span>&lt;T&gt;&gt;&gt; f)<br />        {<br />            <span style="color:blue;">return </span>t =&gt;<br />            {<br />                <span style="color:#2b91af;">ActionRec</span>&lt;T&gt; a = <span style="color:blue;">null</span>;<br />                <span style="color:blue;">for </span>(a = t_ =&gt; { t = t_; <span style="color:blue;">return </span>a; }; a != <span style="color:blue;">null</span>; a = f(a)(t))<br />                    ;<br />            };<br />        }<br /><br />        <span style="color:blue;">public static </span><span style="color:#2b91af;">Action</span>&lt;T1, T2&gt; Fix&lt;T1, T2&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>&lt;T1, T2&gt;, <span style="color:#2b91af;">Func</span>&lt;T1, T2, <span style="color:#2b91af;">ActionRec</span>&lt;T1, T2&gt;&gt;&gt; f)<br />        {<br />            <span style="color:blue;">return </span>(t1, t2) =&gt;<br />            {<br />                <span style="color:#2b91af;">ActionRec</span>&lt;T1, T2&gt; a = <span style="color:blue;">null</span>;<br />                <span style="color:blue;">for </span>(a = (t1_, t2_) =&gt; { t1 = t1_; t2 = t2_; <span style="color:blue;">return </span>a; }; a != <span style="color:blue;">null</span>; a = f(a)(t1, t2))<br />                    ;<br />            };<br />        }<br /><br />        <span style="color:green;">// Would really like to store result on a property on the delegate,<br />        // but can&#39;t derive from Delegate manually in C#... This is &quot;brr&quot;.<br />        </span><span style="color:blue;">private static </span><span style="color:#2b91af;">Dictionary</span>&lt;<span style="color:#2b91af;">Delegate</span>, <span style="color:blue;">object</span>&gt; _brr = <span style="color:blue;">new </span><span style="color:#2b91af;">Dictionary</span>&lt;<span style="color:#2b91af;">Delegate</span>, <span style="color:blue;">object</span>&gt;();<br /><br />        <span style="color:blue;">public static </span><span style="color:#2b91af;">FuncRec</span>&lt;R&gt; Break&lt;R&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">FuncRec</span>&lt;R&gt; a, R res) { _brr[a] = res; <span style="color:blue;">return </span>a; }<br />        <span style="color:blue;">public static </span><span style="color:#2b91af;">FuncRec</span>&lt;T, R&gt; Break&lt;T, R&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">FuncRec</span>&lt;T, R&gt; a, R res) { _brr[a] = res; <span style="color:blue;">return </span>a; }<br />        <span style="color:blue;">public static </span><span style="color:#2b91af;">FuncRec</span>&lt;T1, T2, R&gt; Break&lt;T1, T2, R&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">FuncRec</span>&lt;T1, T2, R&gt; a, R res) { _brr[a] = res; <span style="color:blue;">return </span>a; }<br /><br />        <span style="color:blue;">public static </span><span style="color:#2b91af;">Func</span>&lt;R&gt; Fix&lt;R&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">FuncRec</span>&lt;R&gt;, <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">FuncRec</span>&lt;R&gt;&gt;&gt; f)<br />        {<br />            <span style="color:blue;">return </span>() =&gt;<br />            {<br /><span style="color:green;">                </span><span style="color:blue;">object </span>res_;<br />                <span style="color:#2b91af;">FuncRec</span>&lt;R&gt; a = <span style="color:blue;">null</span>;<br />                <span style="color:blue;">for </span>(a = () =&gt; a; !_brr.TryGetValue(a, <span style="color:blue;">out </span>res_); a = f(a)())<br />                    ;<br />                <span style="color:blue;">var </span>res = (R)res_;<br />                _brr.Remove(a);<br />                <span style="color:blue;">return </span>res;<br />            };<br />        }<br /><br />        <span style="color:blue;">public static </span><span style="color:#2b91af;">Func</span>&lt;T, R&gt; Fix&lt;T, R&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">FuncRec</span>&lt;T, R&gt;, <span style="color:#2b91af;">Func</span>&lt;T, <span style="color:#2b91af;">FuncRec</span>&lt;T, R&gt;&gt;&gt; f)<br />        {<br />            <span style="color:blue;">return </span>t =&gt;<br />            {<br />                <span style="color:blue;">object </span>res_;<br />                <span style="color:#2b91af;">FuncRec</span>&lt;T, R&gt; a = <span style="color:blue;">null</span>;<br />                <span style="color:blue;">for </span>(a = t_ =&gt; { t = t_; <span style="color:blue;">return </span>a; }; !_brr.TryGetValue(a, <span style="color:blue;">out </span>res_); a = f(a)(t))<br />                    ;<br />                <span style="color:blue;">var </span>res = (R)res_;<br />                _brr.Remove(a);<br />                <span style="color:blue;">return </span>res;<br />            };<br />        }<br /><br />        <span style="color:blue;">public static </span><span style="color:#2b91af;">Func</span>&lt;T1, T2, R&gt; Fix&lt;T1, T2, R&gt;(<span style="color:blue;">this </span><span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">FuncRec</span>&lt;T1, T2, R&gt;, <span style="color:#2b91af;">Func</span>&lt;T1, T2, <span style="color:#2b91af;">FuncRec</span>&lt;T1, T2, R&gt;&gt;&gt; f)<br />        {<br />            <span style="color:blue;">return </span>(t1, t2) =&gt;<br />            {<br />                <span style="color:blue;">object </span>res_;<br />                <span style="color:#2b91af;">FuncRec</span>&lt;T1, T2, R&gt; a = <span style="color:blue;">null</span>;<br />                <span style="color:blue;">for </span>(a = (t1_, t2_) =&gt; { t1 = t1_; t2 = t2_; <span style="color:blue;">return </span>a; }; !_brr.TryGetValue(a, <span style="color:blue;">out </span>res_); a = f(a)(t1, t2))<br />                    ;<br />                <span style="color:blue;">var </span>res = (R)res_;<br />                _brr.Remove(a);<br />                <span style="color:blue;">return </span>res;<br />            };<br />        }<br />    }<br />}</pre>
</blockquote>
<br /><p>Another sample illustrating the stack-friendly nature of the trampoline, is shown below:</p><br /><br /><blockquote><br />  <pre class="code"><span style="color:#2b91af;">Console</span>.WriteLine(<span style="color:#a31515;">&quot;Forever! (CTRL-C to terminate)&quot;</span>);<br />{<br />    <span style="color:blue;">bool </span>boom = <span style="color:blue;">false</span>;<br />    <span style="color:#2b91af;">Console</span>.CancelKeyPress += (s, e) =&gt;<br />    {<br />        boom = <span style="color:blue;">true</span>;<br />        e.Cancel = <span style="color:blue;">true</span>;<br />    };</pre><br /><br />  <pre class="code">    <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>, <span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">ActionRec</span>&gt;&gt; f = a =&gt; () =&gt;<br />    {<br />        <span style="color:blue;">if </span>(boom)<br />            <span style="color:blue;">throw new </span><span style="color:#2b91af;">Exception</span>(<span style="color:#a31515;">&quot;Stack use is constant!&quot;</span>);<br />        <span style="color:blue;">return </span>a();<br />    };</pre><br /><br />  <pre class="code">    <span style="color:blue;">try<br />    </span>{<br />        f.Fix()();<br />    }<br />    <span style="color:blue;">catch </span>(<span style="color:#2b91af;">Exception </span>ex)<br />    {<br />        <span style="color:green;">// Inspect stack trace here<br />        </span><span style="color:#2b91af;">Console</span>.WriteLine(ex);<br />    }<br />}</pre>
</blockquote>
<br /><p>This function never returns unless you force it by pressing CTRL-C. At that point, you’ll see the exception’s stack trace being printed, revealing the constant stack space:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_10.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_thumb_11.png" width="677" height="150" /></a> </p>
</blockquote>
<br /><p>It also illustrates how the trampoline is sandwiched between our call to the recursive function (f.Fix()<strong>()</strong>) and the callback to the code we wrote (<strong>f</strong>).</p><br /><br /><p>&#160;</p><br />
<h1>Homework</h1><br /><br /><p>The reader is invited to think about realizing mutual recursion in a stack-friendly way. For example, the sample below is an F# mutual recursive set of two functions used to determine whether a number is odd or even:</p><br /><br /><blockquote><br />  <p><font face="Courier New">let rec isEven n =<br />      <br />&#160; if n = 0 then<br /><br />      <br />&#160;&#160;&#160; true<br /><br />      <br />&#160; else<br /><br />      <br />&#160;&#160;&#160; isOdd (n - 1)<br /><br />      <br />and isOdd n =<br /><br />      <br />&#160; if n = 0 then<br /><br />      <br />&#160;&#160;&#160; false<br /><br />      <br />&#160; else<br /><br />      <br />&#160;&#160;&#160; isEven (n - 1)</font></p>
</blockquote>
<br /><p>Its use is shown below:</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_11.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_thumb_12.png" width="677" height="438" /></a> </p>
</blockquote>
<br /><p>In fact, the F# implementation generates mutually recursive calls here, but in a stack-friendly way by using tail calls (only shown for the isEven function below, but similar for isOdd):</p><br /><br /><blockquote><br />  <p><a href="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_12.png"><img style="border-bottom:0px;border-left:0px;display:inline;border-top:0px;border-right:0px;" title="image" border="0" alt="image" src="http://bartdesmet.net/images_wlw/JumpingthetrampolineinCStackfriendlyrecu_C5F5/image_thumb_13.png" width="477" height="320" /></a> </p>
</blockquote>
<br /><p>Tail calls reuse the current stack frame, therefore not exhausting the stack upon recursion. The same can be achieved by means of a trampoline if you’re brave enough to give it a try. Hint: notice how mutually recursive functions in F# are subtly bundled by means of an “and” keyword.</p><br /><br /><p>As an additional piece of homework, think about ways we could use a trampoline to call functions that still return a useful value, to be used in code after the call returns. As an example, consider the classic definition of factorial:</p><br /><br /><blockquote><font face="Courier New"><font color="#0000ff">int </font>fac(<font color="#0000ff">int </font>n) <br /><br />    <br />{ <br /><br />    <br /></font><font face="Courier New">&#160;&#160;&#160; <font color="#0000ff">return </font>n == 0 ? 1 : <strong>n * </strong>fac(n – 1); <br /><br />    <br /></font><font face="Courier New">}</font></blockquote>
<br /><p>How would you realize exactly the code above, using trampolines and whatnot, without exhausting call stack space? Recall the problem with the above is the fact we need to do a multiplication after the recursive fac call returns. Hint: think of continuations and maybe even the typical “von Neumann machine trade-off” between code (CPU) and data (memory).</p><br /><br /><p>Happy jumping!</p><img src="http://community.bartdesmet.net/aggbug.aspx?PostID=14869" width="1" height="1"></p></div><div class="accentbar"><span class="left">&nbsp;</span>B# .NET Blog News Feed<span class="right">&nbsp;</span></div></div></div><div class="ClearBoth"></div>